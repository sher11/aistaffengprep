<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 12: Rate Limiting - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="../assets/css/animations.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        /* Interactive Token Bucket Demo */
        .bucket-demo {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 1rem;
            padding: 2rem;
            margin: 1.5rem 0;
        }

        .bucket-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .bucket-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: 600;
            color: white;
            transition: all 0.3s ease;
        }

        .bucket-btn.request {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .bucket-btn.burst {
            background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
        }

        .bucket-btn.reset {
            background: linear-gradient(135deg, #a0aec0 0%, #718096 100%);
        }

        .bucket-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .bucket-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .bucket-viz {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 2rem;
            min-height: 300px;
            margin: 1.5rem 0;
        }

        .bucket-container {
            position: relative;
            width: 120px;
            height: 200px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: none;
            border-radius: 0 0 1rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        .bucket-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, #ffd700 0%, #ff8c00 100%);
            transition: height 0.3s ease;
        }

        .bucket-tokens {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-content: flex-end;
            padding: 0.25rem;
            gap: 0.25rem;
        }

        .token {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3), inset 0 1px 2px rgba(255, 255, 255, 0.3);
            animation: token-appear 0.3s ease;
        }

        @keyframes token-appear {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .token.consumed {
            animation: token-consumed 0.3s ease forwards;
        }

        @keyframes token-consumed {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); background: #48bb78; }
            100% { transform: scale(0); opacity: 0; }
        }

        .bucket-label {
            text-align: center;
            color: white;
            font-weight: 600;
            margin-top: 0.5rem;
        }

        .bucket-capacity {
            font-size: 0.8rem;
            color: #a0aec0;
        }

        .refill-indicator {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd700;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .request-queue {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
        }

        .request-item {
            width: 40px;
            height: 40px;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            animation: request-enter 0.3s ease;
        }

        .request-item.pending {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .request-item.allowed {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            animation: request-allowed 0.5s ease forwards;
        }

        .request-item.rejected {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            animation: request-rejected 0.5s ease forwards;
        }

        @keyframes request-enter {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes request-allowed {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: translateX(100px) scale(0); opacity: 0; }
        }

        @keyframes request-rejected {
            0% { transform: scale(1); }
            50% { transform: scale(1.2) rotate(10deg); }
            100% { transform: translateY(50px) rotate(45deg) scale(0); opacity: 0; }
        }

        .bucket-stats {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .bucket-stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            text-align: center;
            color: white;
            min-width: 100px;
        }

        .bucket-stat-value {
            font-size: 1.25rem;
            font-weight: 700;
        }

        .bucket-stat-value.allowed { color: #48bb78; }
        .bucket-stat-value.rejected { color: #f56565; }
        .bucket-stat-value.tokens { color: #ffd700; }

        .bucket-stat-label {
            font-size: 0.75rem;
            color: #a0aec0;
            margin-top: 0.25rem;
        }

        .bucket-log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.5rem;
            padding: 1rem;
            max-height: 120px;
            overflow-y: auto;
            font-family: 'Fira Code', monospace;
            font-size: 0.75rem;
            color: #a0aec0;
            margin-top: 1rem;
        }

        .bucket-log-entry {
            padding: 0.2rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bucket-log-entry.allowed { color: #48bb78; }
        .bucket-log-entry.rejected { color: #f56565; }
        .bucket-log-entry.refill { color: #ffd700; }

        .settings-panel {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .setting-label {
            font-size: 0.8rem;
            color: #a0aec0;
        }

        .setting-input {
            width: 80px;
            padding: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.25rem;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            text-align: center;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="../coding-rounds/index.html">Coding</a></li>
                <li><a href="index.html" style="color: var(--primary-color);">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
                <li><a href="../generative-ai/index.html">Gen AI</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Concepts</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Scalability Fundamentals
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Database Systems
                    </a>
                    <a href="module-03.html" class="sidebar-link" data-module="3">
                        <span class="sidebar-link-number">3</span>Distributed Systems
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Storage & Data Processing
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Seminal Papers
                    </a>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">6</span>API Design
                    </a>
                    <a href="module-10.html" class="sidebar-link" data-module="10">
                        <span class="sidebar-link-number">7</span>Numbers to Know
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Patterns</div>
                    <a href="module-11.html" class="sidebar-link" data-module="11">
                        <span class="sidebar-link-number">8</span>Real-time Updates
                    </a>
                    <a href="module-12.html" class="sidebar-link active" data-module="12">
                        <span class="sidebar-link-number">9</span>Rate Limiting
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Problem Breakdowns</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">10</span>Common Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">11</span>Framework Mastery
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">12</span>Mock Interviews
                    </a>
                </div>
            </nav>
        </aside>

        <button class="sidebar-toggle" id="sidebarToggle">‚ò∞</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <main class="main-content">
            <h1>Module 12: Rate Limiting Pattern</h1>

            <div class="card mt-3">
                <h3>Learning Objectives</h3>
                <ul>
                    <li>Understand why rate limiting is essential</li>
                    <li>Compare different rate limiting algorithms</li>
                    <li>Design distributed rate limiters</li>
                    <li>Handle rate limiting in API design</li>
                </ul>
            </div>

            <h2 class="mt-4">Why Rate Limiting?</h2>

            <div class="card-grid">
                <div class="card">
                    <h4>Prevent Abuse</h4>
                    <p>Stop malicious users from overwhelming your system with requests.</p>
                </div>
                <div class="card">
                    <h4>Protect Resources</h4>
                    <p>Ensure fair usage and prevent any single user from monopolizing resources.</p>
                </div>
                <div class="card">
                    <h4>Control Costs</h4>
                    <p>Manage infrastructure costs by limiting expensive operations.</p>
                </div>
                <div class="card">
                    <h4>Ensure Stability</h4>
                    <p>Prevent cascading failures during traffic spikes.</p>
                </div>
            </div>

            <!-- Interactive Token Bucket Demo -->
            <h2 class="mt-4">üéÆ Interactive Token Bucket Demo</h2>
            <p class="text-muted">Visualize how token bucket rate limiting works. Send requests and watch tokens being consumed and refilled!</p>

            <div class="bucket-demo" id="bucket-demo">
                <div class="settings-panel">
                    <div class="setting-item">
                        <label class="setting-label">Bucket Capacity</label>
                        <input type="number" class="setting-input" id="bucket-capacity" value="10" min="1" max="20">
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Refill Rate (tokens/sec)</label>
                        <input type="number" class="setting-input" id="refill-rate" value="2" min="1" max="10">
                    </div>
                </div>

                <div class="bucket-controls">
                    <button class="bucket-btn request" onclick="sendRequest()">üì§ Send Request</button>
                    <button class="bucket-btn burst" onclick="sendBurst()">‚ö° Send Burst (5)</button>
                    <button class="bucket-btn reset" onclick="resetBucket()">üîÑ Reset</button>
                </div>

                <div class="bucket-viz">
                    <div class="request-queue" id="request-queue">
                        <div style="color: #a0aec0; font-size: 0.8rem; margin-bottom: 0.5rem;">Requests</div>
                    </div>

                    <div style="position: relative;">
                        <div class="refill-indicator" id="refill-indicator">+1 token</div>
                        <div class="bucket-container">
                            <div class="bucket-tokens" id="bucket-tokens"></div>
                        </div>
                        <div class="bucket-label">
                            <span id="token-count">10</span> / <span id="max-tokens">10</span> tokens
                        </div>
                        <div class="bucket-capacity">Token Bucket</div>
                    </div>

                    <div style="text-align: center;">
                        <div style="color: #a0aec0; font-size: 0.8rem; margin-bottom: 0.5rem;">Result</div>
                        <div id="result-area" style="width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; font-size: 2rem;">
                        </div>
                    </div>
                </div>

                <div class="bucket-stats">
                    <div class="bucket-stat">
                        <div class="bucket-stat-value tokens" id="stat-tokens">10</div>
                        <div class="bucket-stat-label">Current Tokens</div>
                    </div>
                    <div class="bucket-stat">
                        <div class="bucket-stat-value allowed" id="stat-allowed">0</div>
                        <div class="bucket-stat-label">Allowed</div>
                    </div>
                    <div class="bucket-stat">
                        <div class="bucket-stat-value rejected" id="stat-rejected">0</div>
                        <div class="bucket-stat-label">Rejected</div>
                    </div>
                    <div class="bucket-stat">
                        <div class="bucket-stat-value" id="stat-rate" style="color: #667eea;">0%</div>
                        <div class="bucket-stat-label">Success Rate</div>
                    </div>
                </div>

                <div class="bucket-log" id="bucket-log">
                    <div class="bucket-log-entry">Token bucket initialized with 10 tokens. Refill rate: 2 tokens/second.</div>
                </div>
            </div>

            <div class="card mt-2" style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 140, 0, 0.2)); border-left: 4px solid #ffd700;">
                <strong>üí° Try this:</strong> Click "Send Burst" to quickly deplete tokens, then watch them refill over time. This shows how token bucket allows controlled bursts while maintaining long-term rate limits!
            </div>

            <h2 class="mt-4">Rate Limiting Algorithms</h2>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>1. Token Bucket</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <div class="diagram-container">
                        <div class="mermaid">
flowchart LR
    subgraph "Token Bucket"
        R[Refill Rate] -->|Add tokens| B[(Bucket)]
        B -->|Take token| P[Process Request]
    end
                        </div>
                    </div>

                    <h4>How It Works</h4>
                    <ul>
                        <li>Bucket holds tokens (max = bucket size)</li>
                        <li>Tokens added at fixed rate (refill rate)</li>
                        <li>Each request consumes one token</li>
                        <li>Request rejected if bucket is empty</li>
                    </ul>

                    <div class="code-block">
                        <code>
class TokenBucket:<br>
    def __init__(self, capacity, refill_rate):<br>
        self.capacity = capacity<br>
        self.tokens = capacity<br>
        self.refill_rate = refill_rate  # tokens per second<br>
        self.last_refill = time.time()<br>
<br>
    def allow_request(self):<br>
        self._refill()<br>
        if self.tokens >= 1:<br>
            self.tokens -= 1<br>
            return True<br>
        return False<br>
<br>
    def _refill(self):<br>
        now = time.time()<br>
        tokens_to_add = (now - self.last_refill) * self.refill_rate<br>
        self.tokens = min(self.capacity, self.tokens + tokens_to_add)<br>
        self.last_refill = now
                        </code>
                    </div>

                    <div class="card mt-2" style="background: var(--success-bg);">
                        <strong>Pros:</strong> Allows bursts, memory efficient, widely used<br>
                        <strong>Cons:</strong> May be harder to tune<br>
                        <strong>Used by:</strong> AWS, Stripe
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>2. Leaky Bucket</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <div class="diagram-container">
                        <div class="mermaid">
flowchart TB
    R[Requests] -->|Queue| B[(Bucket/Queue)]
    B -->|Fixed rate| P[Process]
    B -->|Overflow| D[Drop]
                        </div>
                    </div>

                    <h4>How It Works</h4>
                    <ul>
                        <li>Requests added to a queue (bucket)</li>
                        <li>Processed at a fixed rate (leak rate)</li>
                        <li>If queue full, new requests dropped</li>
                        <li>Smooths out bursty traffic</li>
                    </ul>

                    <div class="card mt-2" style="background: var(--success-bg);">
                        <strong>Pros:</strong> Smooth output rate, prevents bursts<br>
                        <strong>Cons:</strong> Doesn't allow bursts, may increase latency<br>
                        <strong>Used by:</strong> Network traffic shaping
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>3. Fixed Window Counter</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Divide time into fixed windows and count requests per window.</p>

                    <div class="code-block">
                        <code>
Window: [0:00 - 1:00] ‚Üí Count: 100 requests<br>
Window: [1:00 - 2:00] ‚Üí Count: 0 requests (new window)<br>
<br>
# Problem: Boundary burst<br>
[0:59] ‚Üí 100 requests (allowed)<br>
[1:01] ‚Üí 100 requests (allowed)<br>
# Result: 200 requests in 2 seconds!
                        </code>
                    </div>

                    <div class="card mt-2" style="background: var(--error-bg);">
                        <strong>Problem:</strong> Requests at window boundaries can exceed limit (2x burst)
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>4. Sliding Window Log</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Keep timestamps of all requests in the current window.</p>

                    <div class="code-block">
                        <code>
class SlidingWindowLog:<br>
    def __init__(self, limit, window_seconds):<br>
        self.limit = limit<br>
        self.window = window_seconds<br>
        self.timestamps = []<br>
<br>
    def allow_request(self):<br>
        now = time.time()<br>
        cutoff = now - self.window<br>
        # Remove old timestamps<br>
        self.timestamps = [t for t in self.timestamps if t > cutoff]<br>
        if len(self.timestamps) < self.limit:<br>
            self.timestamps.append(now)<br>
            return True<br>
        return False
                        </code>
                    </div>

                    <div class="card mt-2" style="background: var(--success-bg);">
                        <strong>Pros:</strong> Very accurate<br>
                        <strong>Cons:</strong> Memory intensive (stores all timestamps)
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>5. Sliding Window Counter</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Combines fixed window with weighted previous window for smooth transitions.</p>

                    <div class="code-block">
                        <code>
# Current window: 30% through<br>
# Previous window count: 84<br>
# Current window count: 36<br>
<br>
# Weighted count = prev * (1 - position) + current<br>
# = 84 * 0.7 + 36 = 58.8 + 36 = 94.8<br>
<br>
# If limit is 100, request allowed (94.8 < 100)
                        </code>
                    </div>

                    <div class="card mt-2" style="background: var(--success-bg);">
                        <strong>Pros:</strong> Memory efficient, smooths boundary issue<br>
                        <strong>Cons:</strong> Not 100% accurate but good enough<br>
                        <strong>Recommended:</strong> Best balance of accuracy and memory
                    </div>
                </div>
            </div>

            <h2 class="mt-4">Algorithm Comparison</h2>

            <div class="card">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Algorithm</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Memory</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Accuracy</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Burst</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Token Bucket</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Low</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Good</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Allows</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Leaky Bucket</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Low</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Good</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Prevents</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Fixed Window</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Low</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Poor</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">2x burst</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Sliding Log</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">High</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Exact</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">None</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Sliding Counter</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Low</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Good</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Minimal</td></tr>
                    </tbody>
                </table>
            </div>

            <h2 class="mt-4">Distributed Rate Limiting</h2>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>Architecture</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <div class="diagram-container">
                        <div class="mermaid">
flowchart TB
    subgraph "Clients"
        C1[Client]
        C2[Client]
    end

    subgraph "API Gateway"
        GW[Rate Limiter]
    end

    subgraph "Storage"
        Redis[(Redis)]
    end

    subgraph "Backend"
        S1[Server 1]
        S2[Server 2]
    end

    C1 --> GW
    C2 --> GW
    GW <--> Redis
    GW --> S1
    GW --> S2
                        </div>
                    </div>

                    <h4>Key Considerations</h4>
                    <ul>
                        <li><strong>Centralized counter:</strong> Use Redis for atomic operations</li>
                        <li><strong>Race conditions:</strong> Use Lua scripts or Redis MULTI/EXEC</li>
                        <li><strong>Latency:</strong> Each request adds Redis RTT (~1ms)</li>
                        <li><strong>Failure handling:</strong> Fail open or closed?</li>
                    </ul>

                    <div class="code-block">
                        <code>
-- Redis Lua script for atomic rate limiting<br>
local key = KEYS[1]<br>
local limit = tonumber(ARGV[1])<br>
local window = tonumber(ARGV[2])<br>
<br>
local current = redis.call('INCR', key)<br>
if current == 1 then<br>
    redis.call('EXPIRE', key, window)<br>
end<br>
<br>
if current > limit then<br>
    return 0  -- Rate limited<br>
end<br>
return 1  -- Allowed
                        </code>
                    </div>
                </div>
            </div>

            <h2 class="mt-4">HTTP Response Headers</h2>

            <div class="card">
                <div class="code-block">
                    <code>
HTTP/1.1 429 Too Many Requests<br>
X-RateLimit-Limit: 100<br>
X-RateLimit-Remaining: 0<br>
X-RateLimit-Reset: 1640000000<br>
Retry-After: 60<br>
<br>
{<br>
  "error": {<br>
    "code": "RATE_LIMIT_EXCEEDED",<br>
    "message": "Rate limit exceeded. Try again in 60 seconds."<br>
  }<br>
}
                    </code>
                </div>
            </div>

            <h2 class="mt-4">Failure Scenarios</h2>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Redis Rate Limiter Failure</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <h4>The Decision: Fail Open vs Fail Closed</h4>
                    <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Strategy</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Behavior</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">When to Use</th>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Fail Open</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Allow all requests when Redis is down</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">User-facing APIs, availability priority</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Fail Closed</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Reject all requests when Redis is down</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Financial APIs, security priority</td>
                        </tr>
                    </table>

                    <div class="code-block">
                        <code>
# Python - Rate limiter with configurable failure mode

import redis
from enum import Enum

class FailureMode(Enum):
    FAIL_OPEN = "open"    # Allow requests on failure
    FAIL_CLOSED = "closed"  # Deny requests on failure

class ResilientRateLimiter:
    def __init__(
        self,
        redis_client: redis.Redis,
        limit: int,
        window_seconds: int,
        failure_mode: FailureMode = FailureMode.FAIL_OPEN
    ):
        self.redis = redis_client
        self.limit = limit
        self.window = window_seconds
        self.failure_mode = failure_mode
        self.local_fallback = {}  # In-memory fallback

    def is_allowed(self, key: str) -> tuple[bool, dict]:
        """
        Returns (allowed: bool, metadata: dict)
        """
        try:
            return self._check_redis(key)
        except redis.ConnectionError:
            return self._handle_redis_failure(key)

    def _check_redis(self, key: str) -> tuple[bool, dict]:
        current = self.redis.incr(key)
        if current == 1:
            self.redis.expire(key, self.window)

        remaining = max(0, self.limit - current)
        return (
            current <= self.limit,
            {"limit": self.limit, "remaining": remaining, "source": "redis"}
        )

    def _handle_redis_failure(self, key: str) -> tuple[bool, dict]:
        if self.failure_mode == FailureMode.FAIL_OPEN:
            # Log for monitoring, but allow the request
            print(f"WARN: Rate limiter Redis down, failing OPEN for {key}")
            return (True, {"limit": self.limit, "remaining": -1, "source": "failopen"})
        else:
            # Conservative: deny during outage
            print(f"WARN: Rate limiter Redis down, failing CLOSED for {key}")
            return (False, {"limit": self.limit, "remaining": 0, "source": "failclosed"})


# Production usage with circuit breaker
class RateLimiterWithCircuitBreaker:
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
        self.circuit_open = False
        self.failure_count = 0
        self.failure_threshold = 5
        self.last_failure_time = 0
        self.recovery_timeout = 30  # seconds

    def is_allowed(self, key: str, limit: int, window: int) -> bool:
        # Circuit breaker check
        if self.circuit_open:
            if time.time() - self.last_failure_time > self.recovery_timeout:
                self.circuit_open = False
                self.failure_count = 0
            else:
                return True  # Fail open during circuit break

        try:
            # Try Redis
            result = self._check_redis(key, limit, window)
            self.failure_count = 0
            return result
        except redis.RedisError:
            self.failure_count += 1
            self.last_failure_time = time.time()
            if self.failure_count >= self.failure_threshold:
                self.circuit_open = True
                print("Circuit breaker OPEN - rate limiting disabled")
            return True  # Fail open
                        </code>
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Race Conditions in Distributed Rate Limiting</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Multiple servers checking and incrementing simultaneously can exceed limits.</p>

                    <h4>Problem Illustration</h4>
                    <div class="diagram-container">
                        <div class="mermaid">
sequenceDiagram
    participant S1 as Server 1
    participant S2 as Server 2
    participant R as Redis

    Note over R: Counter = 99, Limit = 100
    S1->>R: GET counter
    S2->>R: GET counter
    R-->>S1: 99
    R-->>S2: 99
    Note over S1: 99 < 100, allow!
    Note over S2: 99 < 100, allow!
    S1->>R: INCR counter
    S2->>R: INCR counter
    Note over R: Counter = 101
    Note over S1,S2: BOTH allowed, limit exceeded!
                        </div>
                    </div>

                    <h4>Solution: Atomic Lua Script</h4>
                    <div class="code-block">
                        <code>
-- Redis Lua script for atomic rate limiting
-- Returns: 1 if allowed, 0 if rate limited

local key = KEYS[1]
local limit = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local now = tonumber(ARGV[3])

-- Clean old entries (sliding window)
redis.call('ZREMRANGEBYSCORE', key, 0, now - window * 1000)

-- Count current requests
local count = redis.call('ZCARD', key)

if count < limit then
    -- Add this request
    redis.call('ZADD', key, now, now .. ':' .. math.random())
    redis.call('EXPIRE', key, window)
    return 1
else
    return 0
end
                        </code>
                    </div>

                    <div class="code-block">
                        <code>
# Python - Using Lua script for atomic rate limiting

import redis
import time

class AtomicRateLimiter:
    LUA_SCRIPT = """
    local key = KEYS[1]
    local limit = tonumber(ARGV[1])
    local window = tonumber(ARGV[2])
    local now = tonumber(ARGV[3])

    redis.call('ZREMRANGEBYSCORE', key, 0, now - window * 1000)
    local count = redis.call('ZCARD', key)

    if count < limit then
        redis.call('ZADD', key, now, now .. ':' .. math.random())
        redis.call('EXPIRE', key, window)
        return {1, limit - count - 1}
    else
        return {0, 0}
    end
    """

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.script = self.redis.register_script(self.LUA_SCRIPT)

    def is_allowed(self, key: str, limit: int, window_seconds: int) -> tuple[bool, int]:
        """
        Returns (allowed, remaining_requests)
        Guaranteed atomic - no race conditions.
        """
        now_ms = int(time.time() * 1000)
        result = self.script(
            keys=[f"ratelimit:{key}"],
            args=[limit, window_seconds, now_ms]
        )
        return (result[0] == 1, result[1])


# Usage
limiter = AtomicRateLimiter(redis.Redis())
allowed, remaining = limiter.is_allowed("user:123", limit=100, window_seconds=60)
                        </code>
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Cascading Failures from Rate Limiting</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Aggressive rate limiting can cause problems when legitimate retries are blocked.</p>

                    <h4>Retry Amplification Problem</h4>
                    <ol>
                        <li>Service A calls Service B</li>
                        <li>Service B rate limits Service A</li>
                        <li>Service A retries (with backoff)</li>
                        <li>Meanwhile, new requests arrive at Service A</li>
                        <li>Service A queues all requests, waiting for retry window</li>
                        <li>When retry window opens, all queued requests flood Service B</li>
                        <li>Service B rate limits again - cycle continues</li>
                    </ol>

                    <h4>Mitigation Strategies</h4>
                    <div class="code-block">
                        <code>
# Python - Client with adaptive rate limiting

import time
import random

class AdaptiveRateLimitedClient:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.local_limit = float('inf')  # Start unlimited
        self.window_reset = 0
        self.consecutive_429s = 0

    async def make_request(self, path: str, data: dict) -> dict:
        # Check local rate limit
        if not self._local_limit_allows():
            await asyncio.sleep(self._backoff_time())

        try:
            response = await self._http_request(path, data)

            if response.status == 429:
                self._handle_rate_limit(response)
                # Don't immediately retry - let other requests through
                raise RateLimitedException()

            # Reset on success
            self.consecutive_429s = 0
            self._update_limits_from_headers(response)
            return await response.json()

        except RateLimitedException:
            raise

    def _local_limit_allows(self) -> bool:
        """Pre-flight check to avoid unnecessary requests."""
        if time.time() < self.window_reset:
            return self.local_limit > 0
        return True

    def _handle_rate_limit(self, response):
        self.consecutive_429s += 1

        # Parse headers
        retry_after = int(response.headers.get('Retry-After', 60))
        self.window_reset = time.time() + retry_after
        self.local_limit = 0

    def _backoff_time(self) -> float:
        """Exponential backoff with jitter."""
        base = min(60, 2 ** self.consecutive_429s)
        jitter = random.uniform(0.5, 1.5)
        return base * jitter

    def _update_limits_from_headers(self, response):
        """Track server-reported limits."""
        remaining = response.headers.get('X-RateLimit-Remaining')
        if remaining:
            self.local_limit = int(remaining)
                        </code>
                    </div>

                    <h4>Server-Side: Graduated Response</h4>
                    <div class="code-block">
                        <code>
# Python - Graduated rate limiting response

class GraduatedRateLimiter:
    """
    Instead of hard 429, gradually degrade service quality.
    Helps prevent retry storms.
    """
    def __init__(self, soft_limit: int, hard_limit: int):
        self.soft_limit = soft_limit  # Start degrading
        self.hard_limit = hard_limit  # Full reject

    def check_and_respond(self, count: int) -> dict:
        if count <= self.soft_limit:
            # Full service
            return {"status": "ok", "degraded": False}

        elif count <= self.hard_limit:
            # Degraded service
            degradation_pct = (count - self.soft_limit) / (self.hard_limit - self.soft_limit)
            return {
                "status": "ok",
                "degraded": True,
                "skip_features": self._features_to_skip(degradation_pct)
            }
        else:
            # Full rejection
            return {"status": "rate_limited", "retry_after": 60}

    def _features_to_skip(self, pct: float) -> list:
        """Progressively disable features."""
        features = []
        if pct > 0.25:
            features.append("analytics_tracking")
        if pct > 0.50:
            features.append("recommendations")
        if pct > 0.75:
            features.append("search_suggestions")
        return features
                        </code>
                    </div>
                </div>
            </div>

            <h2 class="mt-4">Self-Check Quiz</h2>
            <div class="quiz-container" id="module-quiz"></div>

            <div class="flex flex-between mt-4">
                <a href="module-11.html" class="btn btn-secondary">&larr; Previous Module</a>
                <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
            </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        // ===== Interactive Token Bucket Demo =====
        const bucketState = {
            tokens: 10,
            capacity: 10,
            refillRate: 2,
            allowed: 0,
            rejected: 0,
            refillInterval: null,
            requestId: 0
        };

        function initBucket() {
            bucketState.capacity = parseInt(document.getElementById('bucket-capacity').value) || 10;
            bucketState.refillRate = parseInt(document.getElementById('refill-rate').value) || 2;
            bucketState.tokens = bucketState.capacity;

            renderTokens();
            startRefill();
        }

        function renderTokens() {
            const container = document.getElementById('bucket-tokens');
            container.innerHTML = '';

            for (let i = 0; i < bucketState.tokens; i++) {
                const token = document.createElement('div');
                token.className = 'token';
                token.style.animationDelay = (i * 0.05) + 's';
                container.appendChild(token);
            }

            document.getElementById('token-count').textContent = bucketState.tokens;
            document.getElementById('max-tokens').textContent = bucketState.capacity;
            document.getElementById('stat-tokens').textContent = bucketState.tokens;
        }

        function startRefill() {
            if (bucketState.refillInterval) {
                clearInterval(bucketState.refillInterval);
            }

            const refillMs = 1000 / bucketState.refillRate;
            bucketState.refillInterval = setInterval(() => {
                if (bucketState.tokens < bucketState.capacity) {
                    bucketState.tokens++;
                    renderTokens();

                    // Flash refill indicator
                    const indicator = document.getElementById('refill-indicator');
                    indicator.style.opacity = '1';
                    setTimeout(() => indicator.style.opacity = '0.5', 200);

                    addBucketLog(`ü™ô Token refilled (${bucketState.tokens}/${bucketState.capacity})`, 'refill');
                }
            }, refillMs);
        }

        function sendRequest() {
            bucketState.requestId++;
            const reqId = bucketState.requestId;

            // Show request in queue
            showRequestInQueue(reqId);

            // Process after brief delay
            setTimeout(() => {
                if (bucketState.tokens > 0) {
                    // Allowed
                    bucketState.tokens--;
                    bucketState.allowed++;
                    renderTokens();
                    markRequestAllowed(reqId);
                    showResult('‚úÖ');
                    addBucketLog(`‚úÖ Request #${reqId} allowed (${bucketState.tokens} tokens left)`, 'allowed');
                } else {
                    // Rejected
                    bucketState.rejected++;
                    markRequestRejected(reqId);
                    showResult('‚ùå');
                    addBucketLog(`‚ùå Request #${reqId} rejected (no tokens available)`, 'rejected');
                }
                updateBucketStats();
            }, 200);
        }

        function sendBurst() {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => sendRequest(), i * 100);
            }
        }

        function resetBucket() {
            bucketState.tokens = bucketState.capacity;
            bucketState.allowed = 0;
            bucketState.rejected = 0;
            bucketState.requestId = 0;

            renderTokens();
            updateBucketStats();
            document.getElementById('result-area').innerHTML = '';
            addBucketLog('üîÑ Bucket reset to full capacity', 'refill');
        }

        function showRequestInQueue(reqId) {
            const queue = document.getElementById('request-queue');
            const item = document.createElement('div');
            item.className = 'request-item pending';
            item.id = `req-${reqId}`;
            item.textContent = 'üì§';
            queue.appendChild(item);
        }

        function markRequestAllowed(reqId) {
            const item = document.getElementById(`req-${reqId}`);
            if (item) {
                item.className = 'request-item allowed';
                item.textContent = '‚úÖ';
                setTimeout(() => item.remove(), 500);
            }
        }

        function markRequestRejected(reqId) {
            const item = document.getElementById(`req-${reqId}`);
            if (item) {
                item.className = 'request-item rejected';
                item.textContent = '‚ùå';
                setTimeout(() => item.remove(), 500);
            }
        }

        function showResult(emoji) {
            const area = document.getElementById('result-area');
            area.innerHTML = `<span style="animation: request-enter 0.3s ease">${emoji}</span>`;
            setTimeout(() => {
                if (area.innerHTML.includes(emoji)) {
                    area.innerHTML = '';
                }
            }, 1000);
        }

        function updateBucketStats() {
            document.getElementById('stat-allowed').textContent = bucketState.allowed;
            document.getElementById('stat-rejected').textContent = bucketState.rejected;

            const total = bucketState.allowed + bucketState.rejected;
            const rate = total > 0 ? Math.round((bucketState.allowed / total) * 100) : 100;
            document.getElementById('stat-rate').textContent = rate + '%';
        }

        function addBucketLog(message, type) {
            const log = document.getElementById('bucket-log');
            const entry = document.createElement('div');
            entry.className = `bucket-log-entry ${type}`;
            const time = new Date().toLocaleTimeString();
            entry.textContent = `[${time}] ${message}`;
            log.insertBefore(entry, log.firstChild);

            while (log.children.length > 20) {
                log.removeChild(log.lastChild);
            }
        }

        // Settings change handlers
        document.getElementById('bucket-capacity').addEventListener('change', function() {
            bucketState.capacity = parseInt(this.value) || 10;
            if (bucketState.tokens > bucketState.capacity) {
                bucketState.tokens = bucketState.capacity;
            }
            renderTokens();
            addBucketLog(`‚öôÔ∏è Capacity changed to ${bucketState.capacity}`, 'refill');
        });

        document.getElementById('refill-rate').addEventListener('change', function() {
            bucketState.refillRate = parseInt(this.value) || 2;
            startRefill();
            addBucketLog(`‚öôÔ∏è Refill rate changed to ${bucketState.refillRate}/sec`, 'refill');
        });

        // Initialize on load
        document.addEventListener('DOMContentLoaded', initBucket);

        // ===== Sidebar =====
        document.addEventListener('DOMContentLoaded', function() {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', () => {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', () => {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('systemDesign', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "Which rate limiting algorithm allows bursts of traffic?",
                    options: ["Leaky Bucket", "Token Bucket", "Fixed Window", "Sliding Log"],
                    correct: 1,
                    explanation: "Token Bucket allows bursts up to the bucket capacity while maintaining long-term rate limits."
                },
                {
                    question: "What's the main problem with Fixed Window rate limiting?",
                    options: ["High memory usage", "Boundary burst (2x limit)", "Complex implementation", "Slow performance"],
                    correct: 1,
                    explanation: "Fixed Window can allow up to 2x the limit at window boundaries when requests cluster."
                },
                {
                    question: "Which HTTP status code indicates rate limiting?",
                    options: ["403 Forbidden", "429 Too Many Requests", "503 Service Unavailable", "400 Bad Request"],
                    correct: 1,
                    explanation: "429 Too Many Requests is the standard HTTP status code for rate limiting."
                }
            ];
            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('systemDesign', 12);
            alert('Module 12 marked as complete!');
            window.location.href = 'module-06.html';
        }
    </script>
</body>
</html>
