<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 11: Real-time Updates - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="../coding-rounds/index.html">Coding</a></li>
                <li><a href="index.html" style="color: var(--primary-color);">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Concepts</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Scalability Fundamentals
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Database Systems
                    </a>
                    <a href="module-03.html" class="sidebar-link" data-module="3">
                        <span class="sidebar-link-number">3</span>Distributed Systems
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Storage & Data Processing
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Seminal Papers
                    </a>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">6</span>API Design
                    </a>
                    <a href="module-10.html" class="sidebar-link" data-module="10">
                        <span class="sidebar-link-number">7</span>Numbers to Know
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Patterns</div>
                    <a href="module-11.html" class="sidebar-link active" data-module="11">
                        <span class="sidebar-link-number">8</span>Real-time Updates
                    </a>
                    <a href="module-12.html" class="sidebar-link" data-module="12">
                        <span class="sidebar-link-number">9</span>Rate Limiting
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Problem Breakdowns</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">10</span>Common Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">11</span>Framework Mastery
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">12</span>Mock Interviews
                    </a>
                </div>
            </nav>
        </aside>

        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <main class="main-content">
            <h1>Module 11: Real-time Updates Pattern</h1>

            <div class="card mt-3">
                <h3>Learning Objectives</h3>
                <ul>
                    <li>Compare polling, long polling, SSE, and WebSockets</li>
                    <li>Choose the right approach for different use cases</li>
                    <li>Understand scaling challenges for real-time systems</li>
                    <li>Design notification and live update systems</li>
                </ul>
            </div>

            <h2 class="mt-4">Real-time Communication Methods</h2>

            <div class="diagram-container">
                <div class="mermaid">
flowchart LR
    subgraph "Polling"
        C1[Client] -->|Request| S1[Server]
        S1 -->|Response| C1
        C1 -->|Request again| S1
    end

    subgraph "Long Polling"
        C2[Client] -->|Request| S2[Server]
        S2 -.->|Wait...| S2
        S2 -->|Response when data| C2
    end

    subgraph "WebSocket"
        C3[Client] <-->|Bidirectional| S3[Server]
    end
                </div>
            </div>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>1. Short Polling</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Client repeatedly requests updates at fixed intervals.</p>

                    <div class="code-block">
                        <code>
// Client polls every 5 seconds<br>
setInterval(() => {<br>
  fetch('/api/updates')<br>
    .then(res => res.json())<br>
    .then(data => updateUI(data));<br>
}, 5000);
                        </code>
                    </div>

                    <h4 class="mt-3">Pros</h4>
                    <ul>
                        <li>Simple to implement</li>
                        <li>Works with any HTTP server</li>
                        <li>Easy to scale (stateless)</li>
                    </ul>

                    <h4>Cons</h4>
                    <ul>
                        <li>High latency (up to polling interval)</li>
                        <li>Wasteful - many empty responses</li>
                        <li>High server load at scale</li>
                    </ul>

                    <div class="card mt-2" style="background: var(--success-bg);">
                        <strong>Best for:</strong> Low-frequency updates, simple dashboards, data that changes infrequently
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>2. Long Polling</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Server holds the request open until new data is available.</p>

                    <div class="diagram-container">
                        <div class="mermaid">
sequenceDiagram
    participant C as Client
    participant S as Server
    C->>S: GET /updates
    Note over S: Hold connection...
    Note over S: Data arrives!
    S->>C: Response with data
    C->>S: GET /updates (immediately)
    Note over S: Hold connection...
                        </div>
                    </div>

                    <h4>Pros</h4>
                    <ul>
                        <li>Near real-time updates</li>
                        <li>Less wasteful than polling</li>
                        <li>Works through most firewalls/proxies</li>
                    </ul>

                    <h4>Cons</h4>
                    <ul>
                        <li>Holds server connections open (resource intensive)</li>
                        <li>Connection timeouts require reconnection</li>
                        <li>Server-to-client only</li>
                    </ul>

                    <div class="card mt-2" style="background: var(--success-bg);">
                        <strong>Best for:</strong> Chat applications, notifications where WebSocket isn't feasible
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>3. Server-Sent Events (SSE)</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Server pushes updates over a persistent HTTP connection.</p>

                    <div class="code-block">
                        <code>
// Client<br>
const eventSource = new EventSource('/api/stream');<br>
eventSource.onmessage = (event) => {<br>
  const data = JSON.parse(event.data);<br>
  updateUI(data);<br>
};<br><br>

// Server response format<br>
data: {"message": "Hello"}\n\n<br>
data: {"message": "World"}\n\n
                        </code>
                    </div>

                    <h4>Pros</h4>
                    <ul>
                        <li>Built-in reconnection</li>
                        <li>Works over HTTP/1.1</li>
                        <li>Simpler than WebSockets</li>
                        <li>Automatic event ID tracking</li>
                    </ul>

                    <h4>Cons</h4>
                    <ul>
                        <li>Server-to-client only (no bidirectional)</li>
                        <li>Limited to ~6 connections per browser (HTTP/1.1)</li>
                        <li>Text-only (no binary data)</li>
                    </ul>

                    <div class="card mt-2" style="background: var(--success-bg);">
                        <strong>Best for:</strong> Live feeds, stock tickers, news updates, social media timelines
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>4. WebSockets</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Full-duplex communication over a single TCP connection.</p>

                    <div class="diagram-container">
                        <div class="mermaid">
sequenceDiagram
    participant C as Client
    participant S as Server
    C->>S: HTTP Upgrade Request
    S->>C: 101 Switching Protocols
    Note over C,S: WebSocket Connection Established
    C->>S: Message
    S->>C: Message
    S->>C: Push notification
    C->>S: Acknowledgment
                        </div>
                    </div>

                    <div class="code-block">
                        <code>
// Client<br>
const ws = new WebSocket('wss://api.example.com/ws');<br>
ws.onmessage = (event) => handleMessage(event.data);<br>
ws.send(JSON.stringify({ type: 'subscribe', channel: 'updates' }));
                        </code>
                    </div>

                    <h4>Pros</h4>
                    <ul>
                        <li>True bidirectional communication</li>
                        <li>Low latency</li>
                        <li>Efficient for high-frequency updates</li>
                        <li>Supports binary data</li>
                    </ul>

                    <h4>Cons</h4>
                    <ul>
                        <li>Stateful - harder to scale</li>
                        <li>Requires WebSocket servers</li>
                        <li>Connection management complexity</li>
                        <li>May have proxy/firewall issues</li>
                    </ul>

                    <div class="card mt-2" style="background: var(--success-bg);">
                        <strong>Best for:</strong> Real-time gaming, collaborative editing, chat, live trading
                    </div>
                </div>
            </div>

            <h2 class="mt-4">Comparison Table</h2>

            <div class="card">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Method</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Latency</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Direction</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Scalability</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Complexity</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Short Polling</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">High</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Client→Server</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Easy</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Low</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Long Polling</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Medium</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Server→Client</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Medium</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Medium</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">SSE</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Low</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Server→Client</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Medium</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Low</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">WebSockets</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Low</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Bidirectional</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Hard</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">High</td></tr>
                    </tbody>
                </table>
            </div>

            <h2 class="mt-4">Scaling WebSockets</h2>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Architecture for Scale</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <div class="diagram-container">
                        <div class="mermaid">
flowchart TB
    subgraph "Clients"
        C1[Client 1]
        C2[Client 2]
        C3[Client 3]
    end

    subgraph "Load Balancer"
        LB[Sticky Sessions / IP Hash]
    end

    subgraph "WebSocket Servers"
        WS1[WS Server 1]
        WS2[WS Server 2]
    end

    subgraph "Pub/Sub"
        Redis[(Redis Pub/Sub)]
    end

    C1 --> LB --> WS1
    C2 --> LB --> WS1
    C3 --> LB --> WS2
    WS1 <--> Redis
    WS2 <--> Redis
                        </div>
                    </div>

                    <h4>Key Strategies</h4>
                    <ul>
                        <li><strong>Sticky Sessions:</strong> Route same client to same server</li>
                        <li><strong>Pub/Sub Layer:</strong> Redis/Kafka for cross-server messaging</li>
                        <li><strong>Connection State:</strong> Store in Redis for failover</li>
                        <li><strong>Horizontal Scaling:</strong> Add servers behind load balancer</li>
                    </ul>

                    <h4 class="mt-3">Production WebSocket Server - Python</h4>
                    <div class="code-block">
                        <code>
# Python - Scalable WebSocket server with FastAPI
import asyncio
import json
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from typing import Dict, Set
import redis.asyncio as redis
from dataclasses import dataclass
import uuid

app = FastAPI()

@dataclass
class ConnectionManager:
    server_id: str = str(uuid.uuid4())[:8]

    def __post_init__(self):
        self.active_connections: Dict[str, Set[WebSocket]] = {}
        self.redis: redis.Redis = None

    async def connect(self):
        self.redis = await redis.from_url("redis://localhost")
        # Start listening for cross-server messages
        asyncio.create_task(self._listen_for_broadcasts())

    async def register(self, user_id: str, websocket: WebSocket):
        await websocket.accept()

        if user_id not in self.active_connections:
            self.active_connections[user_id] = set()
        self.active_connections[user_id].add(websocket)

        # Track user -> server mapping
        await self.redis.hset("ws:user_servers", user_id, self.server_id)
        await self.redis.sadd(f"ws:server:{self.server_id}:users", user_id)

        print(f"User {user_id} connected to server {self.server_id}")

    async def disconnect(self, user_id: str, websocket: WebSocket):
        if user_id in self.active_connections:
            self.active_connections[user_id].discard(websocket)
            if not self.active_connections[user_id]:
                del self.active_connections[user_id]
                await self.redis.hdel("ws:user_servers", user_id)
                await self.redis.srem(f"ws:server:{self.server_id}:users", user_id)

    async def send_to_user(self, user_id: str, message: dict):
        """Send message to user, routing across servers if needed."""
        # Check if user is on this server
        if user_id in self.active_connections:
            await self._send_local(user_id, message)
        else:
            # Publish to Redis for other servers
            await self.redis.publish(
                f"ws:messages:{user_id}",
                json.dumps(message)
            )

    async def broadcast_to_channel(self, channel: str, message: dict):
        """Broadcast to all subscribers of a channel."""
        # Publish to Redis channel
        await self.redis.publish(
            f"ws:channel:{channel}",
            json.dumps(message)
        )

    async def _send_local(self, user_id: str, message: dict):
        """Send to local WebSocket connections."""
        connections = self.active_connections.get(user_id, set())
        dead_connections = set()

        for ws in connections:
            try:
                await ws.send_json(message)
            except Exception:
                dead_connections.add(ws)

        # Clean up dead connections
        for ws in dead_connections:
            await self.disconnect(user_id, ws)

    async def _listen_for_broadcasts(self):
        """Listen for messages from other servers."""
        pubsub = self.redis.pubsub()
        await pubsub.psubscribe("ws:messages:*", "ws:channel:*")

        async for message in pubsub.listen():
            if message["type"] == "pmessage":
                pattern = message["pattern"].decode()
                channel = message["channel"].decode()
                data = json.loads(message["data"])

                if pattern == "ws:messages:*":
                    # Direct message to user
                    user_id = channel.split(":")[-1]
                    if user_id in self.active_connections:
                        await self._send_local(user_id, data)
                elif pattern == "ws:channel:*":
                    # Channel broadcast - send to all local subscribers
                    # (subscription logic not shown for brevity)
                    pass


manager = ConnectionManager()

@app.on_event("startup")
async def startup():
    await manager.connect()

@app.websocket("/ws/{user_id}")
async def websocket_endpoint(websocket: WebSocket, user_id: str):
    await manager.register(user_id, websocket)
    try:
        while True:
            data = await websocket.receive_json()
            # Handle different message types
            if data.get("type") == "message":
                await manager.send_to_user(
                    data["to"],
                    {"from": user_id, "content": data["content"]}
                )
            elif data.get("type") == "subscribe":
                # Subscribe to channel
                pass
    except WebSocketDisconnect:
        await manager.disconnect(user_id, websocket)
                        </code>
                    </div>

                    <h4 class="mt-3">Production WebSocket Server - Go</h4>
                    <div class="code-block">
                        <code>
// Go - High-performance WebSocket server with gorilla/websocket

package main

import (
    "encoding/json"
    "log"
    "net/http"
    "sync"

    "github.com/gorilla/websocket"
    "github.com/redis/go-redis/v9"
)

type Client struct {
    UserID string
    Conn   *websocket.Conn
    Send   chan []byte
}

type Hub struct {
    clients    map[string]map[*Client]bool // userID -> clients
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
    redis      *redis.Client
    mu         sync.RWMutex
}

func newHub(redisAddr string) *Hub {
    return &Hub{
        clients:    make(map[string]map[*Client]bool),
        broadcast:  make(chan []byte, 256),
        register:   make(chan *Client),
        unregister: make(chan *Client),
        redis:      redis.NewClient(&redis.Options{Addr: redisAddr}),
    }
}

func (h *Hub) run() {
    for {
        select {
        case client := <-h.register:
            h.mu.Lock()
            if h.clients[client.UserID] == nil {
                h.clients[client.UserID] = make(map[*Client]bool)
            }
            h.clients[client.UserID][client] = true
            h.mu.Unlock()

        case client := <-h.unregister:
            h.mu.Lock()
            if clients, ok := h.clients[client.UserID]; ok {
                delete(clients, client)
                close(client.Send)
                if len(clients) == 0 {
                    delete(h.clients, client.UserID)
                }
            }
            h.mu.Unlock()

        case message := <-h.broadcast:
            h.mu.RLock()
            for _, clients := range h.clients {
                for client := range clients {
                    select {
                    case client.Send <- message:
                    default:
                        close(client.Send)
                        delete(clients, client)
                    }
                }
            }
            h.mu.RUnlock()
        }
    }
}

func (h *Hub) sendToUser(userID string, message []byte) {
    h.mu.RLock()
    clients, ok := h.clients[userID]
    h.mu.RUnlock()

    if ok {
        for client := range clients {
            select {
            case client.Send <- message:
            default:
                // Buffer full, skip
            }
        }
    }
}

var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024,
    CheckOrigin:     func(r *http.Request) bool { return true },
}

func serveWs(hub *Hub, w http.ResponseWriter, r *http.Request) {
    userID := r.URL.Query().Get("user_id")
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Println(err)
        return
    }

    client := &Client{
        UserID: userID,
        Conn:   conn,
        Send:   make(chan []byte, 256),
    }
    hub.register <- client

    // Start read/write pumps
    go client.writePump()
    go client.readPump(hub)
}

func (c *Client) writePump() {
    defer c.Conn.Close()
    for message := range c.Send {
        if err := c.Conn.WriteMessage(websocket.TextMessage, message); err != nil {
            return
        }
    }
}

func (c *Client) readPump(hub *Hub) {
    defer func() {
        hub.unregister <- c
        c.Conn.Close()
    }()

    for {
        _, message, err := c.Conn.ReadMessage()
        if err != nil {
            break
        }
        // Process message
        var msg map[string]interface{}
        json.Unmarshal(message, &msg)
        // Route to recipient
    }
}
                        </code>
                    </div>
                </div>
            </div>

            <h2 class="mt-4">Failure Scenarios</h2>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>WebSocket Server Crash</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <h4>What Happens</h4>
                    <ol>
                        <li>Server crashes, all connections drop</li>
                        <li>Clients detect disconnect (no pong/heartbeat)</li>
                        <li>Clients reconnect to load balancer</li>
                        <li>Routed to different server</li>
                        <li>Must sync missed messages</li>
                    </ol>

                    <div class="diagram-container">
                        <div class="mermaid">
sequenceDiagram
    participant C as Client
    participant LB as Load Balancer
    participant S1 as Server 1
    participant S2 as Server 2
    participant R as Redis

    C->>LB: Connect
    LB->>S1: Route
    S1->>R: Register user
    Note over S1: Server 1 CRASHES
    C->>C: Detect disconnect
    C->>LB: Reconnect
    LB->>S2: Route to healthy server
    S2->>R: Re-register user
    S2->>R: Get pending messages
    S2->>C: Deliver missed messages
                        </div>
                    </div>

                    <h4>Recovery Implementation</h4>
                    <div class="code-block">
                        <code>
# Python - Client-side reconnection with message sync

class ResilientWebSocketClient:
    def __init__(self, url: str, user_id: str):
        self.url = url
        self.user_id = user_id
        self.last_message_id = None
        self.reconnect_delay = 1.0
        self.max_delay = 30.0

    async def connect_with_retry(self):
        while True:
            try:
                await self._connect()
                self.reconnect_delay = 1.0  # Reset on success
            except Exception as e:
                print(f"Connection failed: {e}")
                await asyncio.sleep(self.reconnect_delay)
                # Exponential backoff with jitter
                self.reconnect_delay = min(
                    self.reconnect_delay * 2 * (0.5 + random.random()),
                    self.max_delay
                )

    async def _connect(self):
        async with websockets.connect(self.url) as ws:
            # Request messages since last known ID
            await ws.send(json.dumps({
                "type": "sync",
                "last_message_id": self.last_message_id
            }))

            async for message in ws:
                data = json.loads(message)
                self.last_message_id = data.get("message_id")
                await self.handle_message(data)
                        </code>
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Redis Pub/Sub Failure</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>If Redis fails, cross-server messaging breaks down.</p>

                    <h4>Mitigation Strategies</h4>
                    <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Strategy</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Implementation</th>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Redis Sentinel/Cluster</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Automatic failover to replica</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Local queue buffering</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Queue messages during Redis outage, flush when recovered</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Fallback to polling</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Degrade to HTTP polling if WebSocket infra fails</td>
                        </tr>
                    </table>

                    <div class="code-block">
                        <code>
# Python - Message buffering during Redis outage

class ResilientPubSub:
    def __init__(self):
        self.redis = None
        self.buffer = []
        self.buffer_limit = 10000
        self.is_connected = False

    async def publish(self, channel: str, message: dict):
        if self.is_connected:
            try:
                await self.redis.publish(channel, json.dumps(message))
            except redis.ConnectionError:
                self.is_connected = False
                self._buffer_message(channel, message)
        else:
            self._buffer_message(channel, message)
            await self._try_reconnect()

    def _buffer_message(self, channel: str, message: dict):
        if len(self.buffer) < self.buffer_limit:
            self.buffer.append((channel, message, time.time()))
        else:
            # Drop oldest messages
            self.buffer.pop(0)
            self.buffer.append((channel, message, time.time()))

    async def _try_reconnect(self):
        try:
            await self.redis.ping()
            self.is_connected = True
            await self._flush_buffer()
        except:
            pass

    async def _flush_buffer(self):
        while self.buffer:
            channel, message, timestamp = self.buffer.pop(0)
            # Skip messages older than 5 minutes
            if time.time() - timestamp < 300:
                await self.redis.publish(channel, json.dumps(message))
                        </code>
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Thundering Herd on Reconnection</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>When a server restarts, all disconnected clients try to reconnect simultaneously.</p>

                    <h4>Prevention</h4>
                    <ul>
                        <li><strong>Jittered reconnection:</strong> Clients wait random delay before reconnecting</li>
                        <li><strong>Connection rate limiting:</strong> Server rejects connections above threshold</li>
                        <li><strong>Gradual rollout:</strong> Only accept percentage of reconnections initially</li>
                    </ul>

                    <div class="code-block">
                        <code>
# Go - Server-side connection rate limiting

type ConnectionLimiter struct {
    maxConnPerSecond int
    tokens           chan struct{}
}

func NewConnectionLimiter(maxPerSecond int) *ConnectionLimiter {
    cl := &ConnectionLimiter{
        maxConnPerSecond: maxPerSecond,
        tokens:           make(chan struct{}, maxPerSecond),
    }

    // Refill tokens every second
    go func() {
        ticker := time.NewTicker(time.Second)
        for range ticker.C {
            // Refill to max
            for len(cl.tokens) < maxPerSecond {
                select {
                case cl.tokens <- struct{}{}:
                default:
                }
            }
        }
    }()

    return cl
}

func (cl *ConnectionLimiter) AllowConnection() bool {
    select {
    case <-cl.tokens:
        return true
    default:
        return false
    }
}

// Usage in WebSocket handler
func handleConnection(w http.ResponseWriter, r *http.Request) {
    if !limiter.AllowConnection() {
        w.Header().Set("Retry-After", "5")
        http.Error(w, "Too many connections", 503)
        return
    }
    // Accept connection...
}
                        </code>
                    </div>
                </div>
            </div>

            <h2 class="mt-4">Self-Check Quiz</h2>
            <div class="quiz-container" id="module-quiz"></div>

            <div class="flex flex-between mt-4">
                <a href="module-10.html" class="btn btn-secondary">&larr; Previous Module</a>
                <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
            </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', () => {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', () => {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('systemDesign', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "Which method is best for a live stock ticker that only needs server-to-client updates?",
                    options: ["Short Polling", "WebSockets", "Server-Sent Events (SSE)", "Long Polling"],
                    correct: 2,
                    explanation: "SSE is ideal for server-to-client streaming with built-in reconnection and simpler than WebSockets."
                },
                {
                    question: "What is the main challenge when scaling WebSocket servers?",
                    options: ["CPU usage", "Memory limits", "Stateful connections", "Network bandwidth"],
                    correct: 2,
                    explanation: "WebSocket connections are stateful, requiring sticky sessions and pub/sub for cross-server messaging."
                },
                {
                    question: "Which real-time method supports bidirectional communication?",
                    options: ["SSE", "Long Polling", "WebSockets", "Short Polling"],
                    correct: 2,
                    explanation: "WebSockets provide full-duplex bidirectional communication over a single TCP connection."
                }
            ];
            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('systemDesign', 11);
            alert('Module 11 marked as complete!');
            window.location.href = 'module-12.html';
        }
    </script>
</body>
</html>
