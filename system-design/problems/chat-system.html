<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design Chat System - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="../../coding-rounds/index.html">Coding</a></li>
                <li><a href="../index.html" style="color: var(--primary-color);">System Design</a></li>
                <li><a href="../../company-specific/index.html">Companies</a></li>
                <li><a href="../../behavioral/index.html">Behavioral</a></li>
                <li><a href="../../generative-ai/index.html">Gen AI</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Problem Breakdowns</div>
                    <a href="url-shortener.html" class="sidebar-link">URL Shortener</a>
                    <a href="news-feed.html" class="sidebar-link">News Feed</a>
                    <a href="chat-system.html" class="sidebar-link active">Chat System</a>
                    <a href="video-streaming.html" class="sidebar-link">Video Streaming</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Back to Course</div>
                    <a href="../index.html" class="sidebar-link">System Design Home</a>
                </div>
            </nav>
        </aside>

        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <main class="main-content">
            <h1>Design: Chat System</h1>
            <p class="text-muted">Examples: WhatsApp, Slack, Discord, Facebook Messenger</p>

            <div class="card mt-3" style="background: var(--success-bg);">
                <strong>Difficulty:</strong> Medium-Hard | <strong>Time:</strong> 45-50 minutes
            </div>

            <h2 class="mt-4">1. Requirements</h2>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>Functional Requirements</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <ul>
                        <li>1:1 messaging</li>
                        <li>Group messaging (up to 100 members)</li>
                        <li>Online/offline status</li>
                        <li>Message read receipts</li>
                        <li>Push notifications</li>
                        <li>Media sharing (images, files)</li>
                    </ul>
                </div>
            </div>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>Non-Functional Requirements</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <ul>
                        <li><strong>Low latency:</strong> Real-time delivery (~100ms)</li>
                        <li><strong>High availability:</strong> 99.99% uptime</li>
                        <li><strong>Ordering:</strong> Messages in correct sequence</li>
                        <li><strong>At-least-once delivery</strong></li>
                    </ul>
                </div>
            </div>

            <h2 class="mt-4">2. High-Level Design</h2>

            <div class="diagram-container">
                <div class="mermaid">
flowchart TB
    subgraph "Clients"
        C1[User A]
        C2[User B]
    end

    subgraph "Connection Layer"
        WS1[WebSocket Server 1]
        WS2[WebSocket Server 2]
    end

    subgraph "Services"
        MS[Message Service]
        PS[Presence Service]
        NS[Notification Service]
    end

    subgraph "Data"
        MQ[Message Queue]
        DB[(Message DB)]
        Cache[(Redis)]
    end

    C1 <-->|WebSocket| WS1
    C2 <-->|WebSocket| WS2
    WS1 & WS2 --> MS
    MS --> MQ --> DB
    MS --> Cache
    WS1 & WS2 <--> Cache
    PS --> Cache
    NS --> C1 & C2
                </div>
            </div>

            <h2 class="mt-4">3. Key Components</h2>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>WebSocket Connection Management</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <ul>
                        <li>Use WebSockets for bidirectional real-time communication</li>
                        <li>Store user → WebSocket server mapping in Redis</li>
                        <li>Heartbeat to detect disconnections</li>
                        <li>Reconnection logic with message sync</li>
                    </ul>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Message Flow</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <ol>
                        <li>User A sends message via WebSocket</li>
                        <li>Message Service assigns message ID (monotonic)</li>
                        <li>Message persisted to database</li>
                        <li>Look up User B's WebSocket server</li>
                        <li>Route message to User B's server</li>
                        <li>Deliver to User B (or queue for offline)</li>
                    </ol>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Presence (Online Status)</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <ul>
                        <li>Update status on connect/disconnect</li>
                        <li>Heartbeat every 30 seconds</li>
                        <li>Store in Redis with TTL</li>
                        <li>Pub/Sub to notify friends of status changes</li>
                    </ul>
                </div>
            </div>

            <h2 class="mt-4">4. Message Storage</h2>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Database Choice</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Option</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Best For</th>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Cassandra</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">High write throughput, time-series data</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">HBase</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Wide column, message history</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">PostgreSQL</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">ACID, smaller scale</td>
                        </tr>
                    </table>
                </div>
            </div>

            <h2 class="mt-4">5. Working Implementation</h2>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>WebSocket Chat Server (Python)</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <div class="code-block">
                        <code>
# Python - Chat server with FastAPI WebSocket
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from dataclasses import dataclass, field
from typing import Dict, Set, Optional
import json
import time
import uuid
import redis.asyncio as redis
import asyncio

app = FastAPI()

@dataclass
class Message:
    id: str
    sender_id: str
    recipient_id: str
    content: str
    timestamp: int
    delivered: bool = False
    read: bool = False

    def to_dict(self):
        return {
            "id": self.id,
            "sender_id": self.sender_id,
            "recipient_id": self.recipient_id,
            "content": self.content,
            "timestamp": self.timestamp,
            "delivered": self.delivered,
            "read": self.read
        }

class ChatServer:
    def __init__(self):
        self.connections: Dict[str, WebSocket] = {}
        self.redis: Optional[redis.Redis] = None
        self.server_id = str(uuid.uuid4())[:8]

    async def connect_redis(self):
        self.redis = await redis.from_url("redis://localhost")
        # Start listening for messages from other servers
        asyncio.create_task(self._subscribe_to_messages())

    async def register(self, user_id: str, websocket: WebSocket):
        await websocket.accept()
        self.connections[user_id] = websocket

        # Store user -> server mapping
        await self.redis.hset("chat:user_servers", user_id, self.server_id)

        # Update presence
        await self.redis.hset("chat:presence", user_id, json.dumps({
            "status": "online",
            "last_seen": int(time.time())
        }))

        # Deliver pending messages
        await self._deliver_pending_messages(user_id, websocket)

        # Notify friends about online status
        await self._broadcast_presence(user_id, "online")

    async def disconnect(self, user_id: str):
        if user_id in self.connections:
            del self.connections[user_id]

        await self.redis.hdel("chat:user_servers", user_id)
        await self.redis.hset("chat:presence", user_id, json.dumps({
            "status": "offline",
            "last_seen": int(time.time())
        }))

        await self._broadcast_presence(user_id, "offline")

    async def send_message(self, message: Message):
        # Generate message ID (Snowflake-style)
        message.id = f"{int(time.time() * 1000)}-{uuid.uuid4().hex[:8]}"
        message.timestamp = int(time.time() * 1000)

        # Store message in database (async)
        await self._persist_message(message)

        # Try to deliver
        recipient_server = await self.redis.hget("chat:user_servers", message.recipient_id)

        if recipient_server:
            if recipient_server.decode() == self.server_id:
                # Same server - deliver directly
                await self._deliver_to_local(message)
            else:
                # Different server - publish via Redis
                await self.redis.publish(
                    f"chat:messages:{message.recipient_id}",
                    json.dumps(message.to_dict())
                )
        else:
            # User offline - queue for later
            await self._queue_for_offline(message)

        # Send acknowledgment to sender
        if message.sender_id in self.connections:
            await self.connections[message.sender_id].send_json({
                "type": "ack",
                "message_id": message.id,
                "status": "sent"
            })

    async def _deliver_to_local(self, message: Message):
        if message.recipient_id in self.connections:
            ws = self.connections[message.recipient_id]
            await ws.send_json({
                "type": "message",
                "data": message.to_dict()
            })
            message.delivered = True
            await self._mark_delivered(message.id)

    async def _queue_for_offline(self, message: Message):
        # Store in Redis list for offline delivery
        await self.redis.lpush(
            f"chat:pending:{message.recipient_id}",
            json.dumps(message.to_dict())
        )
        # Trim to prevent unbounded growth
        await self.redis.ltrim(f"chat:pending:{message.recipient_id}", 0, 999)

    async def _deliver_pending_messages(self, user_id: str, websocket: WebSocket):
        # Get all pending messages
        messages = await self.redis.lrange(f"chat:pending:{user_id}", 0, -1)

        for msg_json in reversed(messages):  # Oldest first
            msg = json.loads(msg_json)
            await websocket.send_json({
                "type": "message",
                "data": msg
            })

        # Clear pending messages
        await self.redis.delete(f"chat:pending:{user_id}")

    async def _subscribe_to_messages(self):
        pubsub = self.redis.pubsub()
        await pubsub.psubscribe("chat:messages:*")

        async for msg in pubsub.listen():
            if msg["type"] == "pmessage":
                channel = msg["channel"].decode()
                user_id = channel.split(":")[-1]
                data = json.loads(msg["data"])

                if user_id in self.connections:
                    await self.connections[user_id].send_json({
                        "type": "message",
                        "data": data
                    })

    async def _persist_message(self, message: Message):
        # In production: write to Cassandra/ScyllaDB
        await self.redis.hset(
            f"chat:msg:{message.id}",
            mapping=message.to_dict()
        )

    async def _mark_delivered(self, message_id: str):
        await self.redis.hset(f"chat:msg:{message_id}", "delivered", "true")

    async def _broadcast_presence(self, user_id: str, status: str):
        # Get user's contacts and notify them
        # Simplified - in production, get from social graph
        pass


chat_server = ChatServer()

@app.on_event("startup")
async def startup():
    await chat_server.connect_redis()

@app.websocket("/ws/{user_id}")
async def websocket_endpoint(websocket: WebSocket, user_id: str):
    await chat_server.register(user_id, websocket)
    try:
        while True:
            data = await websocket.receive_json()

            if data["type"] == "message":
                message = Message(
                    id="",  # Will be generated
                    sender_id=user_id,
                    recipient_id=data["to"],
                    content=data["content"],
                    timestamp=0
                )
                await chat_server.send_message(message)

            elif data["type"] == "typing":
                # Broadcast typing indicator
                pass

            elif data["type"] == "read":
                # Mark message as read
                pass

    except WebSocketDisconnect:
        await chat_server.disconnect(user_id)
                        </code>
                    </div>
                </div>
            </div>

            <h2 class="mt-4">6. Failure Scenarios</h2>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Message Ordering and Delivery Guarantees</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <h4>Challenge: Out-of-Order Messages</h4>
                    <p>Network delays can cause messages to arrive in wrong order.</p>

                    <div class="code-block">
                        <code>
# Python - Client-side message ordering

class MessageBuffer:
    """
    Buffer and reorder messages on the client side.
    Uses sequence numbers for ordering.
    """
    def __init__(self, conversation_id: str):
        self.conversation_id = conversation_id
        self.expected_seq = 0
        self.buffer: Dict[int, Message] = {}
        self.delivered: List[Message] = []

    def add_message(self, message: Message) -> List[Message]:
        """
        Add message and return any messages that can be delivered.
        """
        seq = message.sequence_number

        if seq == self.expected_seq:
            # In order - deliver immediately
            result = [message]
            self.expected_seq += 1

            # Check buffer for consecutive messages
            while self.expected_seq in self.buffer:
                result.append(self.buffer.pop(self.expected_seq))
                self.expected_seq += 1

            return result

        elif seq > self.expected_seq:
            # Out of order - buffer it
            self.buffer[seq] = message
            return []

        else:
            # Duplicate - ignore
            return []
                        </code>
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Connection Loss and Recovery</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Scenario</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">What Happens</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Solution</th>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">User goes offline mid-conversation</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Messages queued in Redis</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Deliver when user reconnects</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Server crashes</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">All connections on that server lost</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Client reconnects to different server</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Redis pub/sub down</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Cross-server messages fail</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Fallback to polling database</td>
                        </tr>
                    </table>

                    <div class="code-block">
                        <code>
# Client-side reconnection with message sync
class ChatClient:
    def __init__(self, user_id: str, server_url: str):
        self.user_id = user_id
        self.server_url = server_url
        self.last_message_id = None
        self.pending_acks: Set[str] = set()

    async def connect(self):
        while True:
            try:
                async with websockets.connect(
                    f"{self.server_url}/ws/{self.user_id}"
                ) as ws:
                    # Sync messages since last known
                    await ws.send(json.dumps({
                        "type": "sync",
                        "last_message_id": self.last_message_id
                    }))

                    # Resend any unacknowledged messages
                    for msg in self.pending_acks:
                        await ws.send(msg)

                    await self._message_loop(ws)

            except websockets.ConnectionClosed:
                await asyncio.sleep(self._backoff())

    async def send_message(self, to: str, content: str):
        msg = {
            "type": "message",
            "to": to,
            "content": content,
            "client_id": str(uuid.uuid4())  # For deduplication
        }
        self.pending_acks.add(json.dumps(msg))
        await self.ws.send(json.dumps(msg))

    def _handle_ack(self, ack):
        # Remove from pending when server acknowledges
        for msg in list(self.pending_acks):
            if json.loads(msg).get("client_id") == ack["client_id"]:
                self.pending_acks.remove(msg)
                break
                        </code>
                    </div>
                </div>
            </div>

            <h2 class="mt-4">7. Summary</h2>

            <div class="card">
                <table style="width: 100%; border-collapse: collapse;">
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Protocol</strong></td>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">WebSocket</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Message ID</strong></td>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Snowflake ID (monotonic)</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Presence</strong></td>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Redis with TTL</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Key Challenge</strong></td>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Message ordering, offline delivery</td>
                    </tr>
                </table>
            </div>

            <div class="flex flex-between mt-4">
                <a href="news-feed.html" class="btn btn-secondary">&larr; News Feed</a>
                <a href="video-streaming.html" class="btn btn-primary">Next: Video Streaming &rarr;</a>
            </div>
        </main>
    </div>

    <script src="../../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', () => {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', () => {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });
        });
    </script>
</body>
</html>
