<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design News Feed - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="../../coding-rounds/index.html">Coding</a></li>
                <li><a href="../index.html" style="color: var(--primary-color);">System Design</a></li>
                <li><a href="../../company-specific/index.html">Companies</a></li>
                <li><a href="../../behavioral/index.html">Behavioral</a></li>
                <li><a href="../../generative-ai/index.html">Gen AI</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Problem Breakdowns</div>
                    <a href="url-shortener.html" class="sidebar-link">URL Shortener</a>
                    <a href="news-feed.html" class="sidebar-link active">News Feed</a>
                    <a href="chat-system.html" class="sidebar-link">Chat System</a>
                    <a href="video-streaming.html" class="sidebar-link">Video Streaming</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Back to Course</div>
                    <a href="../index.html" class="sidebar-link">System Design Home</a>
                    <a href="../module-06.html" class="sidebar-link">Common Problems</a>
                </div>
            </nav>
        </aside>

        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <main class="main-content">
            <h1>Design: News Feed System</h1>
            <p class="text-muted">Examples: Facebook, Twitter, Instagram, LinkedIn Feed</p>

            <div class="card mt-3" style="background: var(--success-bg);">
                <strong>Difficulty:</strong> Medium-Hard | <strong>Time:</strong> 45-50 minutes
            </div>

            <h2 class="mt-4">1. Requirements Clarification</h2>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>Functional Requirements</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <ul>
                        <li>Users can create posts (text, images, videos)</li>
                        <li>Users can follow other users</li>
                        <li>News feed shows posts from followed users</li>
                        <li>Feed should be personalized and relevant</li>
                        <li>Support likes, comments, shares</li>
                    </ul>
                </div>
            </div>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>Non-Functional Requirements</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <ul>
                        <li><strong>Low latency:</strong> Feed loads in < 200ms</li>
                        <li><strong>High availability:</strong> 99.9% uptime</li>
                        <li><strong>Scalability:</strong> Handle 500M+ DAU</li>
                        <li><strong>Eventually consistent:</strong> OK if feed slightly delayed</li>
                    </ul>
                </div>
            </div>

            <h2 class="mt-4">2. Capacity Estimation</h2>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>Scale Numbers</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <div class="card" style="background: var(--code-bg); color: #e2e8f0;">
                        <strong>Assumptions:</strong><br>
                        - 500M DAU<br>
                        - Each user follows avg 200 people<br>
                        - Each user creates 2 posts/day<br>
                        - Each user checks feed 10 times/day<br><br>

                        <strong>Posts Created:</strong><br>
                        500M * 2 = 1B posts/day ≈ 12,000/sec<br><br>

                        <strong>Feed Requests:</strong><br>
                        500M * 10 = 5B/day ≈ 60,000/sec<br><br>

                        <strong>Storage per post:</strong><br>
                        Text: 500 bytes, Metadata: 200 bytes<br>
                        1B posts * 700 bytes ≈ 700 GB/day
                    </div>
                </div>
            </div>

            <h2 class="mt-4">3. High-Level Design</h2>

            <div class="diagram-container">
                <div class="mermaid">
flowchart TB
    subgraph "Clients"
        C[Mobile/Web]
    end

    subgraph "Load Balancing"
        LB[Load Balancer]
    end

    subgraph "Services"
        PS[Post Service]
        FS[Feed Service]
        US[User Service]
        NS[Notification Service]
    end

    subgraph "Data"
        Cache[(Redis Cache)]
        PostDB[(Posts DB)]
        UserDB[(User/Graph DB)]
        FeedCache[(Feed Cache)]
    end

    subgraph "Async"
        MQ[Message Queue]
        FG[Feed Generator]
    end

    C --> LB
    LB --> PS & FS & US
    PS --> PostDB
    PS --> MQ
    MQ --> FG
    FG --> FeedCache
    FS --> FeedCache
    FS --> Cache
    US --> UserDB
                </div>
            </div>

            <h2 class="mt-4">4. Feed Generation Approaches</h2>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>Pull Model (Fan-out on Read)</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Generate feed when user requests it.</p>

                    <div class="diagram-container">
                        <div class="mermaid">
sequenceDiagram
    participant U as User
    participant F as Feed Service
    participant G as Graph DB
    participant P as Posts DB

    U->>F: Get Feed
    F->>G: Get followed users
    G-->>F: User IDs
    F->>P: Get recent posts from users
    P-->>F: Posts
    F->>F: Rank & merge
    F-->>U: Feed
                        </div>
                    </div>

                    <div class="card-grid">
                        <div class="card" style="background: var(--success-bg);">
                            <strong>Pros:</strong>
                            <ul>
                                <li>No wasted computation</li>
                                <li>Always fresh content</li>
                                <li>Simple for inactive users</li>
                            </ul>
                        </div>
                        <div class="card" style="background: var(--error-bg);">
                            <strong>Cons:</strong>
                            <ul>
                                <li>Slow for users with many followings</li>
                                <li>High read latency</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Push Model (Fan-out on Write)</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Pre-compute and push posts to followers' feeds when created.</p>

                    <div class="diagram-container">
                        <div class="mermaid">
sequenceDiagram
    participant A as Author
    participant P as Post Service
    participant Q as Queue
    participant W as Workers
    participant FC as Feed Cache

    A->>P: Create Post
    P->>Q: Post event
    Q->>W: Process
    W->>W: Get all followers
    W->>FC: Add to each follower's feed
                        </div>
                    </div>

                    <div class="card-grid">
                        <div class="card" style="background: var(--success-bg);">
                            <strong>Pros:</strong>
                            <ul>
                                <li>Fast read (pre-computed)</li>
                                <li>Consistent user experience</li>
                            </ul>
                        </div>
                        <div class="card" style="background: var(--error-bg);">
                            <strong>Cons:</strong>
                            <ul>
                                <li>Celebrity problem (millions of followers)</li>
                                <li>Wasted work for inactive users</li>
                                <li>Delay in seeing own posts</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Hybrid Model (Recommended)</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>Combine both approaches based on user type.</p>

                    <ul>
                        <li><strong>Regular users:</strong> Push model (fan-out on write)</li>
                        <li><strong>Celebrities (>10K followers):</strong> Pull model at read time</li>
                        <li><strong>Inactive users:</strong> Compute on demand</li>
                    </ul>

                    <div class="card mt-2" style="background: var(--success-bg);">
                        <strong>This is what Facebook/Twitter actually use!</strong>
                    </div>
                </div>
            </div>

            <h2 class="mt-4">5. Feed Ranking</h2>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Ranking Signals</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <ul>
                        <li><strong>Recency:</strong> Newer posts ranked higher</li>
                        <li><strong>Engagement:</strong> Likes, comments, shares</li>
                        <li><strong>Relationship:</strong> Close friends vs acquaintances</li>
                        <li><strong>Content type:</strong> User preferences</li>
                        <li><strong>Author popularity:</strong> Verified, influencer status</li>
                    </ul>

                    <div class="code-block">
                        <code>
score = (recency_weight * recency_score) +<br>
        (engagement_weight * engagement_score) +<br>
        (relationship_weight * relationship_score) +<br>
        (relevance_weight * ml_relevance_score)
                        </code>
                    </div>
                </div>
            </div>

            <h2 class="mt-4">6. Database Schema</h2>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Data Model</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <div class="code-block">
                        <code>
Users:<br>
- user_id (PK)<br>
- name, email, profile_pic<br>
- created_at<br><br>

Posts:<br>
- post_id (PK)<br>
- author_id (FK → Users)<br>
- content, media_urls<br>
- created_at<br>
- like_count, comment_count<br><br>

Followers (Graph):<br>
- follower_id (FK → Users)<br>
- followee_id (FK → Users)<br>
- created_at<br><br>

FeedCache (Redis):<br>
- Key: user:{user_id}:feed<br>
- Value: List of post_ids (sorted by rank)
                        </code>
                    </div>
                </div>
            </div>

            <h2 class="mt-4">7. Caching Strategy</h2>

            <div class="card">
                <ul>
                    <li><strong>Feed Cache:</strong> Store top 500 post IDs per user</li>
                    <li><strong>Post Cache:</strong> LRU cache for hot posts</li>
                    <li><strong>Social Graph Cache:</strong> User's followings/followers</li>
                    <li><strong>Session Cache:</strong> User preferences, scroll position</li>
                </ul>

                <div class="code-block" style="margin-top: 1rem;">
                    <code>
// Redis feed structure<br>
ZADD user:123:feed 1640000000 "post:456"<br>
ZADD user:123:feed 1640001000 "post:789"<br><br>

// Get feed (newest first)<br>
ZREVRANGE user:123:feed 0 19
                    </code>
                </div>
            </div>

            <h2 class="mt-4">8. Working Implementation</h2>

            <div class="collapsible open">
                <div class="collapsible-header">
                    <span>Fan-out Service Implementation</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <div class="code-block">
                        <code>
# Python - Hybrid Fan-out Feed Generator

import asyncio
from typing import List, Set
import redis.asyncio as redis
from dataclasses import dataclass
import json
import time

CELEBRITY_THRESHOLD = 10000  # Followers to be considered "celebrity"

@dataclass
class Post:
    post_id: str
    author_id: str
    content: str
    timestamp: int
    media_urls: List[str] = None

class FeedService:
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)

    async def publish_post(self, post: Post):
        """
        Handle new post with hybrid fan-out strategy.
        """
        # Get follower count
        follower_count = await self.redis.scard(f"user:{post.author_id}:followers")

        if follower_count > CELEBRITY_THRESHOLD:
            # Celebrity - don't fan out, pull at read time
            await self._store_celebrity_post(post)
        else:
            # Regular user - fan out to all followers
            await self._fan_out_to_followers(post)

    async def _fan_out_to_followers(self, post: Post):
        """
        Push post to each follower's feed cache.
        Use async workers for large follower lists.
        """
        followers = await self.redis.smembers(f"user:{post.author_id}:followers")

        # Batch updates for efficiency
        pipe = self.redis.pipeline()
        for follower_id in followers:
            follower_id = follower_id.decode()
            # Add to sorted set (score = timestamp for ordering)
            pipe.zadd(
                f"feed:{follower_id}",
                {post.post_id: post.timestamp}
            )
            # Trim feed to last 1000 posts
            pipe.zremrangebyrank(f"feed:{follower_id}", 0, -1001)

        await pipe.execute()

    async def _store_celebrity_post(self, post: Post):
        """Store celebrity post separately - will be merged at read time."""
        await self.redis.zadd(
            f"celebrity_posts:{post.author_id}",
            {post.post_id: post.timestamp}
        )

    async def get_feed(self, user_id: str, page: int = 0, size: int = 20) -> List[dict]:
        """
        Get user's feed with hybrid approach.
        """
        # 1. Get pre-computed feed (from regular users)
        start = page * size
        end = start + size - 1

        cached_posts = await self.redis.zrevrange(
            f"feed:{user_id}",
            start, end,
            withscores=True
        )

        # 2. Get posts from celebrities the user follows
        celebrities = await self._get_followed_celebrities(user_id)
        celebrity_posts = []

        for celeb_id in celebrities:
            posts = await self.redis.zrevrange(
                f"celebrity_posts:{celeb_id}",
                0, 50,  # Recent celebrity posts
                withscores=True
            )
            celebrity_posts.extend(posts)

        # 3. Merge and sort by timestamp
        all_posts = list(cached_posts) + celebrity_posts
        all_posts.sort(key=lambda x: x[1], reverse=True)

        # 4. Apply ranking (simplified - in production use ML)
        ranked = await self._apply_ranking(user_id, all_posts[:100])

        # 5. Fetch full post data
        post_ids = [p[0].decode() if isinstance(p[0], bytes) else p[0]
                    for p in ranked[:size]]
        return await self._get_posts_by_ids(post_ids)

    async def _get_followed_celebrities(self, user_id: str) -> List[str]:
        """Get celebrities that user follows."""
        following = await self.redis.smembers(f"user:{user_id}:following")
        celebrities = []

        for uid in following:
            uid = uid.decode()
            follower_count = await self.redis.scard(f"user:{uid}:followers")
            if follower_count > CELEBRITY_THRESHOLD:
                celebrities.append(uid)

        return celebrities

    async def _apply_ranking(self, user_id: str, posts: List) -> List:
        """
        Apply simple ranking based on:
        - Recency
        - Engagement (likes, comments)
        - User affinity
        """
        ranked = []
        for post_id, timestamp in posts:
            post_id = post_id.decode() if isinstance(post_id, bytes) else post_id

            # Get engagement metrics
            likes = int(await self.redis.get(f"post:{post_id}:likes") or 0)
            comments = int(await self.redis.get(f"post:{post_id}:comments") or 0)

            # Simple scoring formula
            age_hours = (time.time() - timestamp) / 3600
            engagement_score = likes + comments * 2
            recency_decay = 1 / (1 + age_hours / 24)

            score = engagement_score * recency_decay
            ranked.append((post_id, score, timestamp))

        ranked.sort(key=lambda x: x[1], reverse=True)
        return [(p[0], p[2]) for p in ranked]

    async def _get_posts_by_ids(self, post_ids: List[str]) -> List[dict]:
        """Fetch full post objects."""
        posts = []
        for post_id in post_ids:
            data = await self.redis.hgetall(f"post:{post_id}")
            if data:
                posts.append({k.decode(): v.decode() for k, v in data.items()})
        return posts
                        </code>
                    </div>
                </div>
            </div>

            <h2 class="mt-4">9. Failure Scenarios</h2>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Celebrity Post Problem</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>When a celebrity with 10M followers posts, fan-out would mean 10M Redis writes.</p>

                    <h4>Solutions</h4>
                    <ul>
                        <li><strong>Hybrid approach:</strong> Don't fan-out celebrity posts; merge at read time</li>
                        <li><strong>Async workers:</strong> Queue fan-out jobs, process in background</li>
                        <li><strong>Tiered storage:</strong> Active users get push, inactive get pull</li>
                    </ul>

                    <div class="code-block">
                        <code>
# Worker for async fan-out

class FanOutWorker:
    BATCH_SIZE = 1000

    async def process_post(self, post: Post):
        """Process fan-out in batches to avoid overwhelming Redis."""
        followers = await self._get_followers_cursor(post.author_id)

        batch = []
        async for follower_id in followers:
            batch.append(follower_id)

            if len(batch) >= self.BATCH_SIZE:
                await self._fan_out_batch(post, batch)
                batch = []
                await asyncio.sleep(0.01)  # Rate limit

        if batch:
            await self._fan_out_batch(post, batch)

    async def _fan_out_batch(self, post: Post, followers: List[str]):
        pipe = self.redis.pipeline()
        for follower_id in followers:
            pipe.zadd(f"feed:{follower_id}", {post.post_id: post.timestamp})
        await pipe.execute()
                        </code>
                    </div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Cache Stampede on Cold Cache</span>
                    <span class="collapsible-icon">&#9660;</span>
                </div>
                <div class="collapsible-content">
                    <p>When user's feed cache is empty (new user, cache eviction), rebuilding is expensive.</p>

                    <div class="code-block">
                        <code>
# Feed cache warming with request coalescing

class FeedCache:
    def __init__(self):
        self.rebuilding: Dict[str, asyncio.Future] = {}

    async def get_feed(self, user_id: str) -> List[dict]:
        # Check if cache exists
        cached = await self.redis.exists(f"feed:{user_id}")

        if cached:
            return await self._get_cached_feed(user_id)

        # Cache miss - check if already rebuilding
        if user_id in self.rebuilding:
            return await self.rebuilding[user_id]

        # Start rebuild
        future = asyncio.Future()
        self.rebuilding[user_id] = future

        try:
            feed = await self._rebuild_feed(user_id)
            future.set_result(feed)
            return feed
        finally:
            del self.rebuilding[user_id]

    async def _rebuild_feed(self, user_id: str) -> List[dict]:
        """Rebuild feed from scratch - expensive operation."""
        following = await self.redis.smembers(f"user:{user_id}:following")

        posts = []
        for author_id in following:
            author_posts = await self.db.query('''
                SELECT * FROM posts
                WHERE author_id = %s
                AND created_at > NOW() - INTERVAL 7 DAY
                ORDER BY created_at DESC
                LIMIT 50
            ''', author_id)
            posts.extend(author_posts)

        # Sort and cache
        posts.sort(key=lambda p: p['created_at'], reverse=True)

        pipe = self.redis.pipeline()
        for post in posts[:500]:
            pipe.zadd(f"feed:{user_id}", {post['id']: post['created_at']})
        pipe.expire(f"feed:{user_id}", 86400)
        await pipe.execute()

        return posts[:20]
                        </code>
                    </div>
                </div>
            </div>

            <h2 class="mt-4">10. Summary</h2>

            <div class="card">
                <table style="width: 100%; border-collapse: collapse;">
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Feed Generation</strong></td>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Hybrid (Push + Pull)</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Read QPS</strong></td>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">~60,000/sec</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Write QPS</strong></td>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">~12,000/sec</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Latency Target</strong></td>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><200ms</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);"><strong>Key Challenge</strong></td>
                        <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Celebrity problem, ranking</td>
                    </tr>
                </table>
            </div>

            <div class="flex flex-between mt-4">
                <a href="url-shortener.html" class="btn btn-secondary">&larr; URL Shortener</a>
                <a href="chat-system.html" class="btn btn-primary">Next: Chat System &rarr;</a>
            </div>
        </main>
    </div>

    <script src="../../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', () => {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', () => {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });
        });
    </script>
</body>
</html>
