<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 3: Distributed Systems - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="../coding-rounds/index.html">Coding</a></li>
                <li><a href="index.html" style="color: var(--primary-color);">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Concepts</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Scalability Fundamentals
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Database Systems
                    </a>
                    <a href="module-03.html" class="sidebar-link active" data-module="3">
                        <span class="sidebar-link-number">3</span>Distributed Systems
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Storage & Data Processing
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Seminal Papers
                    </a>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">6</span>API Design
                    </a>
                    <a href="module-10.html" class="sidebar-link" data-module="10">
                        <span class="sidebar-link-number">7</span>Numbers to Know
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Patterns</div>
                    <a href="module-11.html" class="sidebar-link" data-module="11">
                        <span class="sidebar-link-number">8</span>Real-time Updates
                    </a>
                    <a href="module-12.html" class="sidebar-link" data-module="12">
                        <span class="sidebar-link-number">9</span>Rate Limiting
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Problem Breakdowns</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">10</span>Common Problems
                    </a>
                    <a href="problems/url-shortener.html" class="sidebar-link">URL Shortener</a>
                    <a href="problems/news-feed.html" class="sidebar-link">News Feed</a>
                    <a href="problems/chat-system.html" class="sidebar-link">Chat System</a>
                    <a href="problems/video-streaming.html" class="sidebar-link">Video Streaming</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">11</span>Framework Mastery
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">12</span>Mock Interviews
                    </a>
                </div>
            </nav>
        </aside>

        <button class="sidebar-toggle" id="sidebarToggle">&#9776;</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <main class="main-content">
            <h1>Module 3: Distributed Systems Fundamentals</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Understand CAP theorem and its practical implications</li>
                <li>Learn consensus algorithms (Paxos, Raft)</li>
                <li>Master consistency models and their trade-offs</li>
                <li>Apply distributed systems patterns in design</li>
            </ul>
        </div>

        <h2 class="mt-4">CAP Theorem</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>The CAP Trade-off</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <div class="mermaid">
graph TD
    subgraph "Pick Two"
        C((Consistency))
        A((Availability))
        P((Partition Tolerance))
    end

    C --- CA[CA Systems<br>Traditional RDBMS]
    C --- CP[CP Systems<br>MongoDB, HBase]
    A --- AP[AP Systems<br>Cassandra, DynamoDB]
                    </div>
                </div>

                <h4>Definitions</h4>
                <ul>
                    <li><strong>Consistency:</strong> Every read receives the most recent write</li>
                    <li><strong>Availability:</strong> Every request receives a response</li>
                    <li><strong>Partition Tolerance:</strong> System continues despite network failures</li>
                </ul>

                <div class="card mt-2" style="background: var(--success-bg);">
                    <strong>Reality:</strong> In distributed systems, partition tolerance is required. The real choice is between CP and AP during a partition.
                </div>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Choose Consistency (CP)</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Choose Availability (AP)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Financial transactions</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Social media feeds</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Inventory management</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Content delivery</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">User authentication</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Analytics / Logging</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <h2 class="mt-4">Consistency Models</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Types of Consistency</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>Strong Consistency</h4>
                <p>Read always returns the latest write. All nodes see the same data at the same time.</p>

                <h4>Eventual Consistency</h4>
                <p>Reads may return stale data, but eventually all replicas converge to the same value.</p>

                <h4>Causal Consistency</h4>
                <p>Preserves cause-effect relationships. If A causes B, everyone sees A before B.</p>

                <h4>Read-Your-Writes</h4>
                <p>User always sees their own writes immediately, even if other users see stale data.</p>

                <div class="diagram-container">
                    <div class="mermaid">
flowchart LR
    Strong[Strong<br>Linearizable] --> Causal[Causal]
    Causal --> RYW[Read-Your-Writes]
    RYW --> Eventual[Eventual]

    style Strong fill:#d1fae5
    style Eventual fill:#fee2e2
                    </div>
                </div>
            </div>
        </div>

        <h2 class="mt-4">Consensus Algorithms</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Paxos and Raft</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>Why Consensus?</h4>
                <p>Multiple nodes must agree on a value even if some nodes fail.</p>

                <div class="diagram-container">
                    <div class="mermaid">
sequenceDiagram
    participant L as Leader
    participant R1 as Replica 1
    participant R2 as Replica 2

    L->>R1: Prepare(n)
    L->>R2: Prepare(n)
    R1-->>L: Promise(n)
    R2-->>L: Promise(n)
    L->>R1: Accept(n, v)
    L->>R2: Accept(n, v)
    R1-->>L: Accepted
    R2-->>L: Accepted
    L->>L: Commit
                    </div>
                </div>

                <h4>Raft (Simpler Alternative)</h4>
                <ul>
                    <li><strong>Leader Election:</strong> One node becomes leader</li>
                    <li><strong>Log Replication:</strong> Leader replicates entries to followers</li>
                    <li><strong>Safety:</strong> Committed entries are durable</li>
                </ul>

                <h4 class="mt-3">Raft Leader Election - Implementation</h4>
                <div class="code-block">
                    <code>
# Python - Raft Leader Election State Machine

import random
import time
from enum import Enum
from dataclasses import dataclass
from typing import List, Optional
import asyncio

class NodeState(Enum):
    FOLLOWER = "follower"
    CANDIDATE = "candidate"
    LEADER = "leader"

@dataclass
class RaftNode:
    node_id: str
    state: NodeState = NodeState.FOLLOWER
    current_term: int = 0
    voted_for: Optional[str] = None
    log: List[dict] = None
    commit_index: int = 0

    # Timing (in seconds)
    election_timeout_min: float = 0.150
    election_timeout_max: float = 0.300
    heartbeat_interval: float = 0.050

    def __post_init__(self):
        self.log = self.log or []
        self.reset_election_timer()

    def reset_election_timer(self):
        """Randomized timeout prevents split votes."""
        self.election_deadline = time.time() + random.uniform(
            self.election_timeout_min,
            self.election_timeout_max
        )

    async def run(self, cluster: List['RaftNode']):
        """Main event loop."""
        while True:
            if self.state == NodeState.FOLLOWER:
                await self._run_follower()
            elif self.state == NodeState.CANDIDATE:
                await self._run_candidate(cluster)
            elif self.state == NodeState.LEADER:
                await self._run_leader(cluster)

    async def _run_follower(self):
        """Follower: Wait for heartbeats or timeout."""
        if time.time() >= self.election_deadline:
            print(f"[{self.node_id}] Election timeout - becoming candidate")
            self.state = NodeState.CANDIDATE
        await asyncio.sleep(0.010)

    async def _run_candidate(self, cluster: List['RaftNode']):
        """Candidate: Request votes from all nodes."""
        self.current_term += 1
        self.voted_for = self.node_id
        votes_received = 1  # Vote for self

        print(f"[{self.node_id}] Starting election for term {self.current_term}")

        # Request votes from all other nodes
        for node in cluster:
            if node.node_id != self.node_id:
                vote_granted = await self._request_vote(node)
                if vote_granted:
                    votes_received += 1

        # Check if we won
        majority = len(cluster) // 2 + 1
        if votes_received >= majority:
            print(f"[{self.node_id}] Won election with {votes_received} votes")
            self.state = NodeState.LEADER
        else:
            print(f"[{self.node_id}] Lost election, reverting to follower")
            self.state = NodeState.FOLLOWER
            self.reset_election_timer()

    async def _request_vote(self, target: 'RaftNode') -> bool:
        """
        RequestVote RPC
        Returns True if vote granted
        """
        # If target has higher term, we're stale
        if target.current_term > self.current_term:
            self.current_term = target.current_term
            self.state = NodeState.FOLLOWER
            return False

        # Grant vote if:
        # 1. Target hasn't voted this term, OR voted for us
        # 2. Our log is at least as up-to-date
        if target.current_term < self.current_term:
            target.current_term = self.current_term
            target.voted_for = None

        if target.voted_for is None or target.voted_for == self.node_id:
            # Log completeness check
            if self._is_log_up_to_date(target):
                target.voted_for = self.node_id
                target.reset_election_timer()
                return True

        return False

    def _is_log_up_to_date(self, other: 'RaftNode') -> bool:
        """Check if our log is at least as complete as theirs."""
        our_last_term = self.log[-1]['term'] if self.log else 0
        our_last_index = len(self.log)
        their_last_term = other.log[-1]['term'] if other.log else 0
        their_last_index = len(other.log)

        if our_last_term != their_last_term:
            return our_last_term > their_last_term
        return our_last_index >= their_last_index

    async def _run_leader(self, cluster: List['RaftNode']):
        """Leader: Send heartbeats to maintain authority."""
        for node in cluster:
            if node.node_id != self.node_id:
                await self._send_heartbeat(node)

        await asyncio.sleep(self.heartbeat_interval)

    async def _send_heartbeat(self, target: 'RaftNode'):
        """AppendEntries RPC with empty entries = heartbeat."""
        if target.current_term > self.current_term:
            # Step down - there's a newer leader
            self.state = NodeState.FOLLOWER
            self.current_term = target.current_term
            return

        # Reset follower's election timer
        target.reset_election_timer()
        target.state = NodeState.FOLLOWER


# Usage Example
async def simulate_raft():
    nodes = [RaftNode(f"node-{i}") for i in range(5)]

    # Simulate network partition - node 0 and 1 can't reach others
    # This would cause a new election among nodes 2, 3, 4
    pass
                    </code>
                </div>

                <div class="card mt-2">
                    <strong>Used in:</strong> etcd, Consul, CockroachDB, TiDB
                </div>
            </div>
        </div>

        <h2 class="mt-4">Failure Scenarios in Distributed Systems</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Network Partitions</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <div class="mermaid">
flowchart TB
    subgraph "Partition A"
        N1[Node 1<br>Leader]
        N2[Node 2]
    end

    subgraph "Partition B"
        N3[Node 3]
        N4[Node 4]
        N5[Node 5<br>New Leader]
    end

    N1 -.->|"X Blocked X"| N3
    N2 -.->|"X Blocked X"| N4

    style N1 fill:#fee2e2
    style N5 fill:#d1fae5
                    </div>
                </div>

                <h4>What Happens During a Partition</h4>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">System Type</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Behavior</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">CP System</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Minority partition becomes unavailable; majority continues</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Zookeeper, etcd, Consul</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">AP System</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Both partitions accept writes; conflicts resolved later</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Cassandra, DynamoDB</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Split-Brain Prevention</h4>
                <div class="code-block">
                    <code>
# Go - Quorum-based writes to prevent split-brain

type QuorumWriter struct {
    nodes      []string
    quorumSize int  // Usually: (n/2) + 1
}

func (qw *QuorumWriter) Write(key string, value []byte) error {
    successCount := 0
    errors := make([]error, 0)

    // Fan out writes to all nodes
    for _, node := range qw.nodes {
        err := qw.writeToNode(node, key, value)
        if err != nil {
            errors = append(errors, err)
        } else {
            successCount++
        }
    }

    // Require quorum for success
    if successCount >= qw.quorumSize {
        return nil  // Success - majority agreed
    }

    return fmt.Errorf("quorum not reached: %d/%d succeeded, errors: %v",
        successCount, qw.quorumSize, errors)
}

// During partition:
// - 5-node cluster splits 2-3
// - Quorum = 3
// - Partition with 3 nodes can write
// - Partition with 2 nodes CANNOT write (prevents split-brain)
                    </code>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Cascading Failures</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>One failure triggers a chain reaction across the system.</p>

                <div class="diagram-container">
                    <div class="mermaid">
sequenceDiagram
    participant LB as Load Balancer
    participant S1 as Server 1
    participant S2 as Server 2
    participant S3 as Server 3
    participant DB as Database

    Note over S1: Server 1 fails
    LB->>S2: Redirect traffic
    LB->>S3: Redirect traffic
    Note over S2,S3: Load increases 50%
    S2->>DB: More queries
    S3->>DB: More queries
    Note over DB: Connection pool exhausted
    DB--xS2: Connection refused
    DB--xS3: Connection refused
    Note over S2,S3: Servers start failing
    Note over LB,DB: Complete outage
                    </div>
                </div>

                <h4>Prevention Strategies</h4>
                <div class="code-block">
                    <code>
# Python - Circuit Breaker Pattern

import time
from enum import Enum
from dataclasses import dataclass
from typing import Callable, Any

class CircuitState(Enum):
    CLOSED = "closed"      # Normal operation
    OPEN = "open"          # Failing - reject requests
    HALF_OPEN = "half_open"  # Testing recovery

@dataclass
class CircuitBreaker:
    failure_threshold: int = 5
    recovery_timeout: float = 30.0
    half_open_max_calls: int = 3

    def __post_init__(self):
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.last_failure_time = 0
        self.half_open_calls = 0

    def call(self, func: Callable, *args, **kwargs) -> Any:
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.recovery_timeout:
                self.state = CircuitState.HALF_OPEN
                self.half_open_calls = 0
            else:
                raise CircuitBreakerOpen("Circuit breaker is open")

        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise

    def _on_success(self):
        if self.state == CircuitState.HALF_OPEN:
            self.half_open_calls += 1
            if self.half_open_calls >= self.half_open_max_calls:
                # Recovered!
                self.state = CircuitState.CLOSED
                self.failure_count = 0
        elif self.state == CircuitState.CLOSED:
            self.failure_count = 0

    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()

        if self.state == CircuitState.HALF_OPEN:
            # Recovery failed
            self.state = CircuitState.OPEN
        elif self.failure_count >= self.failure_threshold:
            # Too many failures
            self.state = CircuitState.OPEN
            print(f"Circuit breaker OPEN after {self.failure_count} failures")


# Usage
db_circuit = CircuitBreaker(failure_threshold=5, recovery_timeout=30)

def query_database(sql):
    return db_circuit.call(actual_db_query, sql)
                    </code>
                </div>

                <h4>Additional Mitigation Techniques</h4>
                <ul>
                    <li><strong>Bulkheads:</strong> Isolate components so failure in one doesn't affect others</li>
                    <li><strong>Rate limiting:</strong> Prevent any single source from overwhelming the system</li>
                    <li><strong>Graceful degradation:</strong> Return cached/stale data instead of errors</li>
                    <li><strong>Load shedding:</strong> Reject low-priority requests during overload</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Recovery Strategies</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>Exponential Backoff with Jitter</h4>
                <div class="code-block">
                    <code>
# Python - Production-grade retry with backoff

import random
import time
from functools import wraps
from typing import Callable, Tuple, Type

def retry_with_backoff(
    max_retries: int = 5,
    base_delay: float = 1.0,
    max_delay: float = 60.0,
    exponential_base: float = 2.0,
    jitter: bool = True,
    retryable_exceptions: Tuple[Type[Exception], ...] = (Exception,)
):
    """
    Decorator for retrying with exponential backoff.

    Args:
        max_retries: Maximum number of retry attempts
        base_delay: Initial delay in seconds
        max_delay: Maximum delay cap
        exponential_base: Multiplier for each retry
        jitter: Add randomness to prevent thundering herd
        retryable_exceptions: Tuple of exceptions to retry on
    """
    def decorator(func: Callable):
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None

            for attempt in range(max_retries + 1):
                try:
                    return func(*args, **kwargs)
                except retryable_exceptions as e:
                    last_exception = e

                    if attempt == max_retries:
                        break

                    # Calculate delay with exponential backoff
                    delay = min(
                        base_delay * (exponential_base ** attempt),
                        max_delay
                    )

                    # Add jitter (0.5x to 1.5x)
                    if jitter:
                        delay *= (0.5 + random.random())

                    print(f"Attempt {attempt + 1} failed: {e}. "
                          f"Retrying in {delay:.2f}s...")
                    time.sleep(delay)

            raise last_exception

        return wrapper
    return decorator


# Usage
@retry_with_backoff(
    max_retries=5,
    base_delay=1.0,
    retryable_exceptions=(ConnectionError, TimeoutError)
)
def call_external_service(data):
    response = requests.post("https://api.service.com", json=data)
    response.raise_for_status()
    return response.json()
                    </code>
                </div>

                <h4>Graceful Degradation Pattern</h4>
                <div class="code-block">
                    <code>
# Python - Fallback chain for resilient services

class ResilientService:
    def __init__(self, primary_db, cache, static_fallback):
        self.primary_db = primary_db
        self.cache = cache
        self.static_fallback = static_fallback

    async def get_user_profile(self, user_id: str) -> dict:
        # Try primary source
        try:
            profile = await self.primary_db.get_user(user_id)
            # Update cache for next time
            await self.cache.set(f"user:{user_id}", profile, ttl=300)
            return profile
        except DatabaseError:
            pass  # Fall through to cache

        # Try cache (might be stale)
        try:
            cached = await self.cache.get(f"user:{user_id}")
            if cached:
                return {**cached, "_stale": True}
        except CacheError:
            pass  # Fall through to static

        # Return static/default response
        return {
            "user_id": user_id,
            "name": "Unknown User",
            "_degraded": True
        }
                    </code>
                </div>
            </div>
        </div>

        <h2 class="mt-4">Consistent Hashing</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Distributed Data Placement</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <div class="mermaid">
graph TD
    subgraph "Hash Ring"
        N1((Node A))
        N2((Node B))
        N3((Node C))
    end
                    </div>
                </div>

                <h4>How It Works</h4>
                <ol>
                    <li>Hash nodes and keys onto a ring (0 to 2^n)</li>
                    <li>Key belongs to first node clockwise</li>
                    <li>Virtual nodes: Each physical node has multiple positions</li>
                </ol>

                <h4>Benefits</h4>
                <ul>
                    <li>Minimal remapping when nodes added/removed</li>
                    <li>Even distribution with virtual nodes</li>
                    <li>No central directory needed</li>
                </ul>

                <div class="card mt-2">
                    <strong>Used in:</strong> Cassandra, DynamoDB, Memcached, Chord
                </div>
            </div>
        </div>

        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

            <div class="flex flex-between mt-4">
                <a href="module-02.html" class="btn btn-secondary">&larr; Previous Module</a>
                <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
            </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        // Sidebar toggle for mobile
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const sidebarOverlay = document.getElementById('sidebarOverlay');

        sidebarToggle.addEventListener('click', function() {
            sidebar.classList.toggle('open');
            sidebarOverlay.classList.toggle('open');
        });

        sidebarOverlay.addEventListener('click', function() {
            sidebar.classList.remove('open');
            sidebarOverlay.classList.remove('open');
        });

        // Update sidebar links based on completion status
        document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
            const moduleNum = parseInt(link.dataset.module);
            if (StaffEngPrep.ProgressTracker.isModuleComplete('systemDesign', moduleNum)) {
                link.classList.add('completed');
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            const quizQuestions = [
                {
                    question: "What does CAP theorem state?",
                    options: [
                        "You can have all three: Consistency, Availability, Partition tolerance",
                        "You can only have two of: Consistency, Availability, Partition tolerance",
                        "Consistency always beats Availability",
                        "Partitions never happen in modern systems"
                    ],
                    correct: 1,
                    explanation: "CAP theorem states that in the presence of network partitions, you must choose between consistency and availability."
                },
                {
                    question: "What is the main benefit of consistent hashing?",
                    options: ["Faster lookups", "Minimal remapping on node changes", "Better security", "Simpler implementation"],
                    correct: 1,
                    explanation: "Consistent hashing minimizes the amount of data that needs to be remapped when nodes are added or removed."
                }
            ];
            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });
        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('systemDesign', 3);
            alert('Module 3 marked as complete!');
            window.location.href = 'module-04.html';
        }
    </script>
</body>
</html>
