<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 2: Arrays & Two Pointers - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Fundamentals</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Foundations
                    </a>
                    <a href="module-02.html" class="sidebar-link active" data-module="2">
                        <span class="sidebar-link-number">2</span>Arrays & Two Pointers
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Patterns</div>
                    <a href="module-03.html" class="sidebar-link" data-module="3">
                        <span class="sidebar-link-number">3</span>Trees & Binary Search
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Graphs
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Dynamic Programming
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Advanced</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">6</span>Backtracking
                    </a>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">7</span>Heaps & Sorting
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">8</span>Non-LeetCode Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">9</span>Interview Simulation
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Main Content -->
        <main class="main-content">
        <h1>Module 2: Arrays, Strings & Two Pointers</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Master two-pointer techniques for array problems</li>
                <li>Understand and apply sliding window pattern</li>
                <li>Use prefix sum for efficient range queries</li>
                <li>Handle string manipulation efficiently</li>
            </ul>
        </div>

        <!-- Two Pointers Section -->
        <h2 class="mt-4">Two Pointer Technique</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Pattern Overview</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Two pointers technique uses two indices to traverse data, often reducing O(n²) to O(n).</p>

                <div class="diagram-container">
                    <div class="mermaid">
flowchart LR
    subgraph "Opposite Ends"
        A["[1, 2, 3, 4, 5]"]
        L1((L)) -.-> A
        R1((R)) -.-> A
    end

    subgraph "Same Direction"
        B["[1, 2, 3, 4, 5]"]
        S((Slow)) -.-> B
        F((Fast)) -.-> B
    end
                    </div>
                </div>

                <h4>When to Use</h4>
                <ul>
                    <li><strong>Opposite ends:</strong> Sorted array pairs, palindromes, container problems</li>
                    <li><strong>Same direction:</strong> Fast/slow for cycles, removing duplicates</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Two Sum (Sorted Array)</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def two_sum_sorted(arr, target):
    """Find two numbers that sum to target in sorted array.
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(arr) - 1

    while left < right:
        current_sum = arr[left] + arr[right]

        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1  # Need larger sum
        else:
            right -= 1  # Need smaller sum

    return []  # No solution found</code></pre>
                </div>

                <h4>Key Insight</h4>
                <p>Since array is sorted, moving left pointer increases sum, moving right decreases it.</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Container With Most Water</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def max_area(heights):
    """Find max water container between two lines.
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(heights) - 1
    max_water = 0

    while left < right:
        # Area = width * min(height)
        width = right - left
        height = min(heights[left], heights[right])
        max_water = max(max_water, width * height)

        # Move the shorter line (it limits the area)
        if heights[left] < heights[right]:
            left += 1
        else:
            right -= 1

    return max_water</code></pre>
                </div>
            </div>
        </div>

        <!-- Sliding Window Section -->
        <h2 class="mt-4">Sliding Window Pattern</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Pattern Overview</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Sliding window maintains a "window" of elements that expands/contracts based on conditions.</p>

                <div class="diagram-container">
                    <div class="mermaid">
flowchart LR
    subgraph "Fixed Window"
        A1["[a, b, c] d, e, f"]
        A2["a, [b, c, d] e, f"]
        A3["a, b, [c, d, e] f"]
    end

    subgraph "Variable Window"
        B1["[a, b] c, d, e"]
        B2["[a, b, c, d] e"]
        B3["a, [b, c] d, e"]
    end
                    </div>
                </div>

                <h4>Template</h4>
                <div class="code-block">
                    <pre><code class="language-python">def sliding_window(arr):
    left = 0
    result = initial_value
    window_state = {}  # Track window contents

    for right in range(len(arr)):
        # Expand: add arr[right] to window
        update_window(window_state, arr[right])

        # Contract: shrink while invalid
        while not valid(window_state):
            remove_from_window(window_state, arr[left])
            left += 1

        # Update result
        result = update_result(result, window_state)

    return result</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Longest Substring Without Repeating Characters</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def length_of_longest_substring(s):
    """Find longest substring without repeating characters.
    Time: O(n), Space: O(min(n, alphabet_size))
    """
    char_index = {}  # Last index of each character
    left = 0
    max_length = 0

    for right, char in enumerate(s):
        # If char in window, move left past its last occurrence
        if char in char_index and char_index[char] >= left:
            left = char_index[char] + 1

        char_index[char] = right
        max_length = max(max_length, right - left + 1)

    return max_length

# Example: "abcabcbb" -> 3 ("abc")</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Minimum Window Substring</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">from collections import Counter

def min_window(s, t):
    """Find minimum window containing all characters of t.
    Time: O(n), Space: O(m) where m = len(t)
    """
    if not t or not s:
        return ""

    target_count = Counter(t)
    required = len(target_count)

    left = 0
    formed = 0
    window_counts = {}
    result = (float('inf'), 0, 0)  # (length, left, right)

    for right, char in enumerate(s):
        # Add character to window
        window_counts[char] = window_counts.get(char, 0) + 1

        # Check if frequency matches target
        if char in target_count and window_counts[char] == target_count[char]:
            formed += 1

        # Contract window while valid
        while formed == required:
            # Update result if smaller
            if right - left + 1 < result[0]:
                result = (right - left + 1, left, right)

            # Remove left character
            left_char = s[left]
            window_counts[left_char] -= 1
            if left_char in target_count and window_counts[left_char] < target_count[left_char]:
                formed -= 1
            left += 1

    return "" if result[0] == float('inf') else s[result[1]:result[2]+1]</code></pre>
                </div>
            </div>
        </div>

        <!-- Prefix Sum Section -->
        <h2 class="mt-4">Prefix Sum</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Pattern Overview</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Prefix sum precomputes cumulative sums for O(1) range queries.</p>

                <div class="code-block">
                    <pre><code class="language-python"># Build prefix sum array
# prefix[i] = sum of arr[0:i]
def build_prefix(arr):
    prefix = [0] * (len(arr) + 1)
    for i in range(len(arr)):
        prefix[i + 1] = prefix[i] + arr[i]
    return prefix

# Sum of range [left, right] inclusive
def range_sum(prefix, left, right):
    return prefix[right + 1] - prefix[left]

# Example
arr = [1, 2, 3, 4, 5]
prefix = [0, 1, 3, 6, 10, 15]
# Sum of arr[1:3] = prefix[4] - prefix[1] = 10 - 1 = 9</code></pre>
                </div>

                <h4>Use Cases</h4>
                <ul>
                    <li>Range sum queries</li>
                    <li>Subarray sum equals K</li>
                    <li>Product of array except self</li>
                </ul>
            </div>
        </div>

        <!-- Real-World Scale Examples -->
        <h2 class="mt-4">Real-World Scale Examples</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Netflix: Processing Millions of Streaming Events with Sliding Window</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Netflix processes 400 billion events per day from 230 million subscribers. Their real-time analytics use sliding window algorithms extensively:</p>

                <h4>Use Case: Quality of Experience (QoE) Monitoring</h4>
                <ul>
                    <li>Track buffering events per user over 5-minute windows</li>
                    <li>Detect degradation patterns: "3+ buffering events in 60 seconds"</li>
                    <li>Trigger CDN switching or bitrate adaptation</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># Simplified Netflix-style streaming health monitor
from collections import deque
import time

class StreamHealthMonitor:
    """
    Track events in sliding time window.
    Netflix uses this pattern at 100K+ events/second per server.
    """
    def __init__(self, window_seconds=60):
        self.window_seconds = window_seconds
        self.events = deque()  # (timestamp, event_type)

    def record_event(self, event_type):
        """O(1) amortized - add event and clean old ones."""
        now = time.time()
        self.events.append((now, event_type))

        # Slide window - remove expired events
        while self.events and self.events[0][0] < now - self.window_seconds:
            self.events.popleft()

    def get_count(self, event_type):
        """O(n) where n = events in window, but window is bounded."""
        return sum(1 for _, et in self.events if et == event_type)

    def should_switch_cdn(self):
        """Trigger CDN switch if too many buffer events."""
        return self.get_count('buffer') >= 3

# At Netflix scale: sharded by user_id, aggregated with Apache Kafka Streams</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Spotify: Two-Pointer Merge for Playlist Generation</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Spotify generates personalized playlists for 515 million users. Their "Discover Weekly" algorithm merges sorted preference lists using two-pointer techniques:</p>

                <div class="code-block">
                    <pre><code class="language-python"># Spotify-style playlist merging
def merge_preference_lists(user_likes, collaborative_recs, content_recs):
    """
    Merge multiple sorted recommendation lists by score.
    Two-pointer approach: O(n + m + k) vs O((n+m+k) log (n+m+k)) for sort-all.

    At Spotify scale (500M+ users, 100M+ tracks), this matters.
    """
    # Each list is pre-sorted by relevance score (descending)
    result = []
    pointers = [0, 0, 0]
    lists = [user_likes, collaborative_recs, content_recs]
    weights = [0.5, 0.3, 0.2]  # Prioritize user history

    while len(result) < 30:  # Discover Weekly has 30 songs
        best_score = -1
        best_list = -1

        for i, lst in enumerate(lists):
            if pointers[i] < len(lst):
                weighted_score = lst[pointers[i]]['score'] * weights[i]
                if weighted_score > best_score:
                    best_score = weighted_score
                    best_list = i

        if best_list == -1:
            break

        track = lists[best_list][pointers[best_list]]
        if track not in result:  # Dedup
            result.append(track)
        pointers[best_list] += 1

    return result</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Uber: Prefix Sum for Surge Pricing Calculations</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Uber processes 17 million trips daily. Surge pricing requires real-time demand analysis across geographic zones. Prefix sums enable instant range queries:</p>

                <h4>Problem: "How many ride requests in zone X,Y in the last 5 minutes?"</h4>

                <div class="code-block">
                    <pre><code class="language-python"># Uber-style 2D prefix sum for geographic demand
class DemandGrid:
    """
    2D prefix sum for O(1) rectangular region queries.
    Critical for real-time surge pricing decisions.
    """
    def __init__(self, grid_size=1000):  # 1000x1000 cells covering city
        self.grid_size = grid_size
        self.counts = [[0] * grid_size for _ in range(grid_size)]
        self.prefix = None

    def add_request(self, lat, lon):
        """Map GPS to grid cell and increment."""
        x, y = self._to_grid(lat, lon)
        self.counts[x][y] += 1
        self.prefix = None  # Invalidate cache

    def _build_prefix(self):
        """O(n^2) - rebuild prefix sum matrix."""
        n = self.grid_size
        self.prefix = [[0] * (n + 1) for _ in range(n + 1)]

        for i in range(n):
            for j in range(n):
                self.prefix[i+1][j+1] = (
                    self.counts[i][j] +
                    self.prefix[i][j+1] +
                    self.prefix[i+1][j] -
                    self.prefix[i][j]
                )

    def get_demand(self, x1, y1, x2, y2):
        """O(1) query for rectangular region demand."""
        if self.prefix is None:
            self._build_prefix()

        return (
            self.prefix[x2+1][y2+1] -
            self.prefix[x1][y2+1] -
            self.prefix[x2+1][y1] +
            self.prefix[x1][y1]
        )

    def calculate_surge(self, x1, y1, x2, y2, available_drivers):
        """Surge = demand / supply ratio."""
        demand = self.get_demand(x1, y1, x2, y2)
        if available_drivers == 0:
            return 3.0  # Max surge
        ratio = demand / available_drivers
        return min(3.0, max(1.0, ratio))

# In production: time-bucketed (5-min windows), sharded by city</code></pre>
                </div>

                <p><strong>Why prefix sum?</strong> Without it, each surge calculation would scan all cells in the region - O(region_area). With prefix sum, it's O(1) per query. At 17M trips/day, this saves billions of operations.</p>
            </div>
        </div>

        <!-- Quiz Section -->
        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Interview Follow-up Questions -->
        <h2 class="mt-4">Interview Follow-up Questions</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Common Follow-ups & What Interviewers Look For</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. "How would you modify the sliding window if the window size is dynamic?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Variable-size window template (expand then contract)</li>
                    <li>Clear condition for when to shrink vs expand</li>
                    <li>Example: "Minimum window substring" pattern</li>
                </ul>
                <p><strong>Red flags:</strong> Confusing fixed-size and variable-size patterns.</p>

                <h4>2. "Why does two-pointer work on sorted arrays but not unsorted?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Monotonic property: moving left increases sum, right decreases</li>
                    <li>Without sorting, no guarantee about which pointer to move</li>
                    <li>Trade-off: sort first O(n log n) vs hash table O(n) for Two Sum</li>
                </ul>
                <p><strong>Red flags:</strong> Not understanding the invariant that makes two-pointer correct.</p>

                <h4>3. "How would you handle this if the data doesn't fit in memory?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>External sorting with merge sort (k-way merge)</li>
                    <li>Streaming algorithms for sliding window</li>
                    <li>Distributed prefix sums with MapReduce</li>
                </ul>
                <p><strong>Red flags:</strong> Only knowing in-memory solutions.</p>

                <h4>4. "Can you prove the two-pointer solution is correct?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Loop invariant: "All pairs (i, j) where i < left or j > right have been considered"</li>
                    <li>Termination: left and right converge</li>
                    <li>Why we never miss the optimal pair</li>
                </ul>
                <p><strong>Red flags:</strong> Cannot articulate why skipping pairs is safe.</p>

                <h4>5. "What's the space complexity of prefix sum? Can we do better?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Standard prefix sum: O(n) extra space</li>
                    <li>In-place modification if original array not needed</li>
                    <li>For 2D: O(n*m), can stream row-by-row for O(m)</li>
                </ul>
                <p><strong>Red flags:</strong> Not considering space optimization opportunities.</p>
            </div>
        </div>

        <!-- Practice Problems -->
        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Easy</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank">Two Sum II (LeetCode #167)</a></li>
                <li><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank">Valid Palindrome (LeetCode #125)</a></li>
                <li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank">Remove Duplicates (LeetCode #26)</a></li>
            </ul>

            <h4 class="mt-3">Medium</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/3sum/" target="_blank">3Sum (LeetCode #15)</a></li>
                <li><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank">Container With Most Water (LeetCode #11)</a></li>
                <li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank">Longest Substring Without Repeating (LeetCode #3)</a></li>
            </ul>

            <h4 class="mt-3">Hard</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank">Minimum Window Substring (LeetCode #76)</a></li>
                <li><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank">Trapping Rain Water (LeetCode #42)</a></li>
            </ul>
        </div>

        <!-- Navigation -->
        <div class="flex flex-between mt-4">
            <a href="module-01.html" class="btn btn-secondary">&larr; Module 1</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Sidebar toggle for mobile
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            // Update sidebar links based on completion status
            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('coding', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "When should you use two pointers from opposite ends?",
                    options: ["Unsorted arrays", "Finding cycles", "Sorted array pairs", "Counting elements"],
                    correct: 2,
                    explanation: "Opposite-end two pointers work best on sorted arrays for finding pairs."
                },
                {
                    question: "What's the time complexity of sliding window for longest substring without repeating?",
                    options: ["O(n²)", "O(n log n)", "O(n)", "O(1)"],
                    correct: 2,
                    explanation: "Each character is visited at most twice (once by right, once by left), so O(n)."
                },
                {
                    question: "What does prefix sum allow you to compute in O(1)?",
                    options: ["Maximum element", "Range sum", "Sorted order", "Unique elements"],
                    correct: 1,
                    explanation: "prefix[right+1] - prefix[left] gives sum of range [left, right] in O(1)."
                }
            ];

            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 2);
            alert('Module 2 marked as complete!');
            window.location.href = 'module-03.html';
        }
    </script>
</body>
</html>
