<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 2: Arrays & Two Pointers - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
                <li><a href="../generative-ai/index.html">Gen AI</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Fundamentals</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Foundations
                    </a>
                    <a href="module-02.html" class="sidebar-link active" data-module="2">
                        <span class="sidebar-link-number">2</span>Arrays & Two Pointers
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Patterns</div>
                    <a href="module-03.html" class="sidebar-link" data-module="3">
                        <span class="sidebar-link-number">3</span>Trees & Binary Search
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Graphs
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Dynamic Programming
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Advanced</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">6</span>Backtracking
                    </a>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">7</span>Heaps & Sorting
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">8</span>Non-LeetCode Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">9</span>Interview Simulation
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Main Content -->
        <main class="main-content">
        <h1>Module 2: Arrays, Strings & Two Pointers</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Master two-pointer techniques for array problems</li>
                <li>Understand and apply sliding window pattern</li>
                <li>Use prefix sum for efficient range queries</li>
                <li>Handle string manipulation efficiently</li>
            </ul>
        </div>

        <!-- Two Pointers Section -->
        <h2 class="mt-4">Two Pointer Technique</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Pattern Overview</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Two pointers technique uses two indices to traverse data, often reducing O(n²) to O(n).</p>

                <div class="diagram-container">
                    <!-- Interactive Two Pointer Animation -->
                    <div class="two-pointer-animation" id="twoPointerDemo">
                        <style>
                            .two-pointer-animation {
                                font-family: 'Segoe UI', system-ui, sans-serif;
                                padding: 30px;
                                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                                border-radius: 16px;
                                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                            }
                            .tp-section {
                                margin-bottom: 30px;
                                padding: 20px;
                                background: rgba(255,255,255,0.05);
                                border-radius: 12px;
                                border: 1px solid rgba(255,255,255,0.1);
                                transition: all 0.3s ease;
                            }
                            .tp-section:hover {
                                background: rgba(255,255,255,0.08);
                                border-color: rgba(99, 102, 241, 0.3);
                            }
                            .tp-section-title {
                                font-size: 14px;
                                font-weight: 600;
                                color: #a5b4fc;
                                text-transform: uppercase;
                                letter-spacing: 1.5px;
                                margin-bottom: 20px;
                                display: flex;
                                align-items: center;
                                gap: 10px;
                            }
                            .tp-section-title::before {
                                content: '';
                                width: 4px;
                                height: 20px;
                                background: linear-gradient(180deg, #6366f1, #8b5cf6);
                                border-radius: 2px;
                            }
                            .tp-array-container {
                                display: flex;
                                justify-content: center;
                                gap: 8px;
                                margin: 25px 0;
                                position: relative;
                                padding: 40px 0;
                            }
                            .tp-cell {
                                width: 55px;
                                height: 55px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 20px;
                                font-weight: 600;
                                color: #e2e8f0;
                                background: linear-gradient(145deg, #2d3748, #1a202c);
                                border-radius: 10px;
                                border: 2px solid #4a5568;
                                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                                position: relative;
                            }
                            .tp-cell:hover {
                                transform: translateY(-3px);
                                box-shadow: 0 8px 25px rgba(99, 102, 241, 0.3);
                            }
                            .tp-cell.left-active {
                                background: linear-gradient(145deg, #059669, #047857);
                                border-color: #10b981;
                                box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
                                transform: scale(1.1);
                            }
                            .tp-cell.right-active {
                                background: linear-gradient(145deg, #dc2626, #b91c1c);
                                border-color: #ef4444;
                                box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
                                transform: scale(1.1);
                            }
                            .tp-cell.slow-active {
                                background: linear-gradient(145deg, #7c3aed, #6d28d9);
                                border-color: #8b5cf6;
                                box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
                                transform: scale(1.1);
                            }
                            .tp-cell.fast-active {
                                background: linear-gradient(145deg, #f59e0b, #d97706);
                                border-color: #fbbf24;
                                box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
                                transform: scale(1.1);
                            }
                            .tp-cell.both-active {
                                background: linear-gradient(145deg, #ec4899, #be185d);
                                border-color: #f472b6;
                                box-shadow: 0 0 25px rgba(236, 72, 153, 0.6);
                                transform: scale(1.15);
                            }
                            .tp-pointer {
                                position: absolute;
                                font-size: 11px;
                                font-weight: 700;
                                padding: 4px 10px;
                                border-radius: 6px;
                                white-space: nowrap;
                                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                                z-index: 10;
                            }
                            .tp-pointer.left {
                                top: 0;
                                background: linear-gradient(135deg, #10b981, #059669);
                                color: white;
                                box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
                            }
                            .tp-pointer.right {
                                bottom: 0;
                                background: linear-gradient(135deg, #ef4444, #dc2626);
                                color: white;
                                box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
                            }
                            .tp-pointer.slow {
                                top: 0;
                                background: linear-gradient(135deg, #8b5cf6, #7c3aed);
                                color: white;
                                box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
                            }
                            .tp-pointer.fast {
                                bottom: 0;
                                background: linear-gradient(135deg, #fbbf24, #f59e0b);
                                color: #1a1a2e;
                                box-shadow: 0 4px 15px rgba(251, 191, 36, 0.4);
                            }
                            .tp-pointer::after {
                                content: '';
                                position: absolute;
                                left: 50%;
                                transform: translateX(-50%);
                                border: 6px solid transparent;
                            }
                            .tp-pointer.left::after, .tp-pointer.slow::after {
                                bottom: -10px;
                                border-top-color: inherit;
                            }
                            .tp-pointer.right::after, .tp-pointer.fast::after {
                                top: -10px;
                                border-bottom-color: inherit;
                            }
                            .tp-controls {
                                display: flex;
                                justify-content: center;
                                gap: 12px;
                                margin-top: 20px;
                                flex-wrap: wrap;
                            }
                            .tp-btn {
                                padding: 10px 20px;
                                font-size: 13px;
                                font-weight: 600;
                                border: none;
                                border-radius: 8px;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                text-transform: uppercase;
                                letter-spacing: 0.5px;
                            }
                            .tp-btn-primary {
                                background: linear-gradient(135deg, #6366f1, #8b5cf6);
                                color: white;
                            }
                            .tp-btn-primary:hover {
                                transform: translateY(-2px);
                                box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
                            }
                            .tp-btn-primary:disabled {
                                opacity: 0.5;
                                cursor: not-allowed;
                                transform: none;
                            }
                            .tp-btn-secondary {
                                background: rgba(255,255,255,0.1);
                                color: #e2e8f0;
                                border: 1px solid rgba(255,255,255,0.2);
                            }
                            .tp-btn-secondary:hover {
                                background: rgba(255,255,255,0.15);
                            }
                            .tp-status {
                                text-align: center;
                                margin-top: 15px;
                                padding: 12px;
                                background: rgba(99, 102, 241, 0.1);
                                border-radius: 8px;
                                color: #c7d2fe;
                                font-size: 14px;
                                border: 1px solid rgba(99, 102, 241, 0.2);
                                min-height: 44px;
                            }
                            .tp-legend {
                                display: flex;
                                justify-content: center;
                                gap: 20px;
                                margin-top: 15px;
                                flex-wrap: wrap;
                            }
                            .tp-legend-item {
                                display: flex;
                                align-items: center;
                                gap: 8px;
                                font-size: 12px;
                                color: #94a3b8;
                            }
                            .tp-legend-dot {
                                width: 12px;
                                height: 12px;
                                border-radius: 50%;
                            }
                            .tp-legend-dot.left { background: #10b981; }
                            .tp-legend-dot.right { background: #ef4444; }
                            .tp-legend-dot.slow { background: #8b5cf6; }
                            .tp-legend-dot.fast { background: #fbbf24; }
                            @keyframes pulse {
                                0%, 100% { opacity: 1; }
                                50% { opacity: 0.7; }
                            }
                            .tp-cell.active-pulse {
                                animation: pulse 1s ease-in-out infinite;
                            }
                        </style>

                        <!-- Opposite Ends Section -->
                        <div class="tp-section">
                            <div class="tp-section-title">Opposite Ends Pattern</div>
                            <div class="tp-array-container" id="oppositeEndsArray">
                                <div class="tp-pointer left" id="leftPointer">L (left)</div>
                                <div class="tp-cell" data-index="0">1</div>
                                <div class="tp-cell" data-index="1">2</div>
                                <div class="tp-cell" data-index="2">3</div>
                                <div class="tp-cell" data-index="3">4</div>
                                <div class="tp-cell" data-index="4">5</div>
                                <div class="tp-pointer right" id="rightPointer">R (right)</div>
                            </div>
                            <div class="tp-controls">
                                <button class="tp-btn tp-btn-primary" id="animateOpposite">Animate</button>
                                <button class="tp-btn tp-btn-secondary" id="resetOpposite">Reset</button>
                                <button class="tp-btn tp-btn-secondary" id="stepOpposite">Step</button>
                            </div>
                            <div class="tp-status" id="oppositeStatus">Click "Animate" to see pointers converge toward the center</div>
                            <div class="tp-legend">
                                <div class="tp-legend-item"><div class="tp-legend-dot left"></div> Left Pointer</div>
                                <div class="tp-legend-item"><div class="tp-legend-dot right"></div> Right Pointer</div>
                            </div>
                        </div>

                        <!-- Same Direction Section -->
                        <div class="tp-section">
                            <div class="tp-section-title">Same Direction (Fast/Slow) Pattern</div>
                            <div class="tp-array-container" id="sameDirectionArray">
                                <div class="tp-pointer slow" id="slowPointer">Slow</div>
                                <div class="tp-cell" data-index="0">1</div>
                                <div class="tp-cell" data-index="1">2</div>
                                <div class="tp-cell" data-index="2">3</div>
                                <div class="tp-cell" data-index="3">4</div>
                                <div class="tp-cell" data-index="4">5</div>
                                <div class="tp-pointer fast" id="fastPointer">Fast</div>
                            </div>
                            <div class="tp-controls">
                                <button class="tp-btn tp-btn-primary" id="animateSame">Animate</button>
                                <button class="tp-btn tp-btn-secondary" id="resetSame">Reset</button>
                                <button class="tp-btn tp-btn-secondary" id="stepSame">Step</button>
                            </div>
                            <div class="tp-status" id="sameDirectionStatus">Click "Animate" to see fast pointer move 2x speed of slow</div>
                            <div class="tp-legend">
                                <div class="tp-legend-item"><div class="tp-legend-dot slow"></div> Slow Pointer</div>
                                <div class="tp-legend-item"><div class="tp-legend-dot fast"></div> Fast Pointer</div>
                            </div>
                        </div>
                    </div>

                    <script>
                    (function() {
                        // Two Pointer Animation State
                        const tpState = {
                            opposite: { left: 0, right: 4, animating: false, target: 6 },
                            same: { slow: 0, fast: 0, animating: false }
                        };

                        function getPointerPosition(container, index) {
                            const cells = container.querySelectorAll('.tp-cell');
                            if (cells[index]) {
                                const containerRect = container.getBoundingClientRect();
                                const cellRect = cells[index].getBoundingClientRect();
                                return cellRect.left - containerRect.left + cellRect.width / 2;
                            }
                            return 0;
                        }

                        function updateOppositeEndsUI() {
                            const container = document.getElementById('oppositeEndsArray');
                            const cells = container.querySelectorAll('.tp-cell');
                            const leftPtr = document.getElementById('leftPointer');
                            const rightPtr = document.getElementById('rightPointer');

                            cells.forEach((cell, idx) => {
                                cell.classList.remove('left-active', 'right-active', 'both-active', 'active-pulse');
                                if (idx === tpState.opposite.left && idx === tpState.opposite.right) {
                                    cell.classList.add('both-active', 'active-pulse');
                                } else if (idx === tpState.opposite.left) {
                                    cell.classList.add('left-active', 'active-pulse');
                                } else if (idx === tpState.opposite.right) {
                                    cell.classList.add('right-active', 'active-pulse');
                                }
                            });

                            const leftPos = getPointerPosition(container, tpState.opposite.left);
                            const rightPos = getPointerPosition(container, tpState.opposite.right);
                            leftPtr.style.left = (leftPos - leftPtr.offsetWidth / 2) + 'px';
                            rightPtr.style.left = (rightPos - rightPtr.offsetWidth / 2) + 'px';
                        }

                        function animateOppositeEnds() {
                            if (tpState.opposite.animating) return;
                            tpState.opposite.animating = true;
                            tpState.opposite.left = 0;
                            tpState.opposite.right = 4;
                            document.getElementById('animateOpposite').disabled = true;

                            const animate = () => {
                                if (tpState.opposite.left >= tpState.opposite.right) {
                                    document.getElementById('oppositeStatus').textContent =
                                        'Pointers have met! Target found or search complete.';
                                    tpState.opposite.animating = false;
                                    document.getElementById('animateOpposite').disabled = false;
                                    return;
                                }

                                updateOppositeEndsUI();
                                const leftVal = tpState.opposite.left + 1;
                                const rightVal = tpState.opposite.right + 1;
                                const sum = leftVal + rightVal;
                                document.getElementById('oppositeStatus').textContent =
                                    'Checking: arr[' + tpState.opposite.left + '] + arr[' + tpState.opposite.right + '] = ' + leftVal + ' + ' + rightVal + ' = ' + sum;

                                setTimeout(() => {
                                    if (sum < tpState.opposite.target) {
                                        tpState.opposite.left++;
                                        document.getElementById('oppositeStatus').textContent += ' < ' + tpState.opposite.target + ' - Move LEFT pointer right';
                                    } else if (sum > tpState.opposite.target) {
                                        tpState.opposite.right--;
                                        document.getElementById('oppositeStatus').textContent += ' > ' + tpState.opposite.target + ' - Move RIGHT pointer left';
                                    } else {
                                        document.getElementById('oppositeStatus').textContent += ' = ' + tpState.opposite.target + ' - Found target!';
                                        tpState.opposite.animating = false;
                                        document.getElementById('animateOpposite').disabled = false;
                                        return;
                                    }
                                    setTimeout(animate, 1000);
                                }, 800);
                            };

                            animate();
                        }

                        function stepOppositeEnds() {
                            if (tpState.opposite.left >= tpState.opposite.right) {
                                resetOppositeEnds();
                                return;
                            }
                            const leftVal = tpState.opposite.left + 1;
                            const rightVal = tpState.opposite.right + 1;
                            const sum = leftVal + rightVal;

                            if (sum < tpState.opposite.target) {
                                tpState.opposite.left++;
                            } else {
                                tpState.opposite.right--;
                            }
                            updateOppositeEndsUI();
                            document.getElementById('oppositeStatus').textContent =
                                'L=' + tpState.opposite.left + ', R=' + tpState.opposite.right + ' | Sum=' + sum;
                        }

                        function resetOppositeEnds() {
                            tpState.opposite = { left: 0, right: 4, animating: false, target: 6 };
                            tpState.opposite.animating = false;
                            document.getElementById('animateOpposite').disabled = false;
                            updateOppositeEndsUI();
                            document.getElementById('oppositeStatus').textContent = 'Click "Animate" to see pointers converge toward the center';
                        }

                        function updateSameDirectionUI() {
                            const container = document.getElementById('sameDirectionArray');
                            const cells = container.querySelectorAll('.tp-cell');
                            const slowPtr = document.getElementById('slowPointer');
                            const fastPtr = document.getElementById('fastPointer');

                            cells.forEach((cell, idx) => {
                                cell.classList.remove('slow-active', 'fast-active', 'both-active', 'active-pulse');
                                if (idx === tpState.same.slow && idx === tpState.same.fast) {
                                    cell.classList.add('both-active', 'active-pulse');
                                } else if (idx === tpState.same.slow) {
                                    cell.classList.add('slow-active', 'active-pulse');
                                } else if (idx === tpState.same.fast) {
                                    cell.classList.add('fast-active', 'active-pulse');
                                }
                            });

                            const slowPos = getPointerPosition(container, tpState.same.slow);
                            const fastPos = getPointerPosition(container, tpState.same.fast);
                            slowPtr.style.left = (slowPos - slowPtr.offsetWidth / 2) + 'px';
                            fastPtr.style.left = (fastPos - fastPtr.offsetWidth / 2) + 'px';
                        }

                        function animateSameDirection() {
                            if (tpState.same.animating) return;
                            tpState.same.animating = true;
                            tpState.same.slow = 0;
                            tpState.same.fast = 0;
                            document.getElementById('animateSame').disabled = true;

                            const animate = () => {
                                if (tpState.same.fast >= 4) {
                                    document.getElementById('sameDirectionStatus').textContent =
                                        'Fast pointer reached end. Pattern complete!';
                                    tpState.same.animating = false;
                                    document.getElementById('animateSame').disabled = false;
                                    return;
                                }

                                updateSameDirectionUI();
                                document.getElementById('sameDirectionStatus').textContent =
                                    'Slow at index ' + tpState.same.slow + ', Fast at index ' + tpState.same.fast;

                                setTimeout(() => {
                                    tpState.same.slow = Math.min(tpState.same.slow + 1, 4);
                                    tpState.same.fast = Math.min(tpState.same.fast + 2, 4);
                                    setTimeout(animate, 1000);
                                }, 800);
                            };

                            animate();
                        }

                        function stepSameDirection() {
                            if (tpState.same.fast >= 4) {
                                resetSameDirection();
                                return;
                            }
                            tpState.same.slow = Math.min(tpState.same.slow + 1, 4);
                            tpState.same.fast = Math.min(tpState.same.fast + 2, 4);
                            updateSameDirectionUI();
                            document.getElementById('sameDirectionStatus').textContent =
                                'Slow=' + tpState.same.slow + ', Fast=' + tpState.same.fast;
                        }

                        function resetSameDirection() {
                            tpState.same = { slow: 0, fast: 0, animating: false };
                            document.getElementById('animateSame').disabled = false;
                            updateSameDirectionUI();
                            document.getElementById('sameDirectionStatus').textContent = 'Click "Animate" to see fast pointer move 2x speed of slow';
                        }

                        // Initialize after DOM is ready
                        document.addEventListener('DOMContentLoaded', function() {
                            // Set up event listeners
                            document.getElementById('animateOpposite').addEventListener('click', animateOppositeEnds);
                            document.getElementById('resetOpposite').addEventListener('click', resetOppositeEnds);
                            document.getElementById('stepOpposite').addEventListener('click', stepOppositeEnds);
                            document.getElementById('animateSame').addEventListener('click', animateSameDirection);
                            document.getElementById('resetSame').addEventListener('click', resetSameDirection);
                            document.getElementById('stepSame').addEventListener('click', stepSameDirection);

                            // Initial render with a small delay to ensure layout is complete
                            setTimeout(() => {
                                updateOppositeEndsUI();
                                updateSameDirectionUI();
                            }, 100);
                        });
                    })();
                    </script>
                </div>

                <h4>When to Use</h4>
                <ul>
                    <li><strong>Opposite ends:</strong> Sorted array pairs, palindromes, container problems</li>
                    <li><strong>Same direction:</strong> Fast/slow for cycles, removing duplicates</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Two Sum (Sorted Array)</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def two_sum_sorted(arr, target):
    """Find two numbers that sum to target in sorted array.
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(arr) - 1

    while left < right:
        current_sum = arr[left] + arr[right]

        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1  # Need larger sum
        else:
            right -= 1  # Need smaller sum

    return []  # No solution found</code></pre>
                </div>

                <h4>Key Insight</h4>
                <p>Since array is sorted, moving left pointer increases sum, moving right decreases it.</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Container With Most Water</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def max_area(heights):
    """Find max water container between two lines.
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(heights) - 1
    max_water = 0

    while left < right:
        # Area = width * min(height)
        width = right - left
        height = min(heights[left], heights[right])
        max_water = max(max_water, width * height)

        # Move the shorter line (it limits the area)
        if heights[left] < heights[right]:
            left += 1
        else:
            right -= 1

    return max_water</code></pre>
                </div>
            </div>
        </div>

        <!-- Sliding Window Section -->
        <h2 class="mt-4">Sliding Window Pattern</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Pattern Overview</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Sliding window maintains a "window" of elements that expands/contracts based on conditions.</p>

                <div class="diagram-container">
                    <!-- Interactive Sliding Window Animation -->
                    <div class="sliding-window-animation" id="slidingWindowDemo">
                        <style>
                            .sliding-window-animation {
                                font-family: 'Segoe UI', system-ui, sans-serif;
                                padding: 30px;
                                background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
                                border-radius: 16px;
                                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                            }
                            .sw-section {
                                margin-bottom: 30px;
                                padding: 20px;
                                background: rgba(255,255,255,0.03);
                                border-radius: 12px;
                                border: 1px solid rgba(255,255,255,0.08);
                                transition: all 0.3s ease;
                            }
                            .sw-section:hover {
                                background: rgba(255,255,255,0.05);
                                border-color: rgba(14, 165, 233, 0.3);
                            }
                            .sw-section-title {
                                font-size: 14px;
                                font-weight: 600;
                                color: #7dd3fc;
                                text-transform: uppercase;
                                letter-spacing: 1.5px;
                                margin-bottom: 20px;
                                display: flex;
                                align-items: center;
                                gap: 10px;
                            }
                            .sw-section-title::before {
                                content: '';
                                width: 4px;
                                height: 20px;
                                background: linear-gradient(180deg, #0ea5e9, #06b6d4);
                                border-radius: 2px;
                            }
                            .sw-array-container {
                                display: flex;
                                justify-content: center;
                                gap: 6px;
                                margin: 25px 0;
                                position: relative;
                                padding: 20px 0;
                            }
                            .sw-cell {
                                width: 50px;
                                height: 50px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 18px;
                                font-weight: 600;
                                color: #94a3b8;
                                background: linear-gradient(145deg, #1e293b, #0f172a);
                                border-radius: 8px;
                                border: 2px solid #334155;
                                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                                position: relative;
                                z-index: 1;
                            }
                            .sw-cell:hover {
                                transform: translateY(-2px);
                                border-color: #0ea5e9;
                            }
                            .sw-cell.in-window {
                                color: #f0f9ff;
                                background: linear-gradient(145deg, #0369a1, #0284c7);
                                border-color: #38bdf8;
                                box-shadow: 0 0 20px rgba(14, 165, 233, 0.4);
                                transform: scale(1.05);
                                z-index: 2;
                            }
                            .sw-cell.highlight {
                                background: linear-gradient(145deg, #059669, #10b981);
                                border-color: #34d399;
                                box-shadow: 0 0 25px rgba(16, 185, 129, 0.5);
                            }
                            .sw-window-bracket {
                                position: absolute;
                                height: 70px;
                                border: 3px solid #0ea5e9;
                                border-radius: 12px;
                                top: 50%;
                                transform: translateY(-50%);
                                transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
                                background: rgba(14, 165, 233, 0.1);
                                pointer-events: none;
                                z-index: 0;
                            }
                            .sw-window-label {
                                position: absolute;
                                top: -25px;
                                left: 50%;
                                transform: translateX(-50%);
                                font-size: 11px;
                                font-weight: 700;
                                color: #7dd3fc;
                                background: #0f172a;
                                padding: 2px 8px;
                                border-radius: 4px;
                                white-space: nowrap;
                            }
                            .sw-controls {
                                display: flex;
                                justify-content: center;
                                gap: 12px;
                                margin-top: 20px;
                                flex-wrap: wrap;
                            }
                            .sw-btn {
                                padding: 10px 20px;
                                font-size: 13px;
                                font-weight: 600;
                                border: none;
                                border-radius: 8px;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                text-transform: uppercase;
                                letter-spacing: 0.5px;
                            }
                            .sw-btn-primary {
                                background: linear-gradient(135deg, #0ea5e9, #06b6d4);
                                color: white;
                            }
                            .sw-btn-primary:hover {
                                transform: translateY(-2px);
                                box-shadow: 0 6px 20px rgba(14, 165, 233, 0.4);
                            }
                            .sw-btn-primary:disabled {
                                opacity: 0.5;
                                cursor: not-allowed;
                                transform: none;
                            }
                            .sw-btn-secondary {
                                background: rgba(255,255,255,0.1);
                                color: #e2e8f0;
                                border: 1px solid rgba(255,255,255,0.2);
                            }
                            .sw-btn-secondary:hover {
                                background: rgba(255,255,255,0.15);
                            }
                            .sw-status {
                                text-align: center;
                                margin-top: 15px;
                                padding: 12px;
                                background: rgba(14, 165, 233, 0.1);
                                border-radius: 8px;
                                color: #bae6fd;
                                font-size: 14px;
                                border: 1px solid rgba(14, 165, 233, 0.2);
                                min-height: 44px;
                            }
                            .sw-sum-display {
                                display: flex;
                                justify-content: center;
                                gap: 30px;
                                margin-top: 15px;
                                flex-wrap: wrap;
                            }
                            .sw-sum-item {
                                display: flex;
                                flex-direction: column;
                                align-items: center;
                                gap: 5px;
                            }
                            .sw-sum-label {
                                font-size: 11px;
                                color: #64748b;
                                text-transform: uppercase;
                                letter-spacing: 1px;
                            }
                            .sw-sum-value {
                                font-size: 24px;
                                font-weight: 700;
                                color: #38bdf8;
                            }
                            .sw-sum-value.max {
                                color: #34d399;
                            }
                            @keyframes slideIn {
                                from { opacity: 0; transform: scale(0.8); }
                                to { opacity: 1; transform: scale(1.05); }
                            }
                            .sw-cell.animate-in {
                                animation: slideIn 0.3s ease forwards;
                            }
                        </style>

                        <!-- Fixed Window Section -->
                        <div class="sw-section">
                            <div class="sw-section-title">Fixed Window (Size = 3)</div>
                            <div class="sw-array-container" id="fixedWindowArray">
                                <div class="sw-window-bracket" id="fixedWindowBracket">
                                    <div class="sw-window-label">Window</div>
                                </div>
                                <div class="sw-cell" data-index="0" data-value="2">2</div>
                                <div class="sw-cell" data-index="1" data-value="1">1</div>
                                <div class="sw-cell" data-index="2" data-value="5">5</div>
                                <div class="sw-cell" data-index="3" data-value="1">1</div>
                                <div class="sw-cell" data-index="4" data-value="3">3</div>
                                <div class="sw-cell" data-index="5" data-value="2">2</div>
                            </div>
                            <div class="sw-sum-display">
                                <div class="sw-sum-item">
                                    <div class="sw-sum-label">Window Sum</div>
                                    <div class="sw-sum-value" id="fixedWindowSum">8</div>
                                </div>
                                <div class="sw-sum-item">
                                    <div class="sw-sum-label">Max Sum</div>
                                    <div class="sw-sum-value max" id="fixedMaxSum">8</div>
                                </div>
                            </div>
                            <div class="sw-controls">
                                <button class="sw-btn sw-btn-primary" id="animateFixed">Animate</button>
                                <button class="sw-btn sw-btn-secondary" id="resetFixed">Reset</button>
                                <button class="sw-btn sw-btn-secondary" id="stepFixed">Step</button>
                            </div>
                            <div class="sw-status" id="fixedStatus">Find maximum sum of any 3 consecutive elements</div>
                        </div>

                        <!-- Variable Window Section -->
                        <div class="sw-section">
                            <div class="sw-section-title">Variable Window (Sum >= 7)</div>
                            <div class="sw-array-container" id="variableWindowArray">
                                <div class="sw-window-bracket" id="variableWindowBracket">
                                    <div class="sw-window-label">Window</div>
                                </div>
                                <div class="sw-cell" data-index="0" data-value="2">2</div>
                                <div class="sw-cell" data-index="1" data-value="3">3</div>
                                <div class="sw-cell" data-index="2" data-value="1">1</div>
                                <div class="sw-cell" data-index="3" data-value="2">2</div>
                                <div class="sw-cell" data-index="4" data-value="4">4</div>
                                <div class="sw-cell" data-index="5" data-value="3">3</div>
                            </div>
                            <div class="sw-sum-display">
                                <div class="sw-sum-item">
                                    <div class="sw-sum-label">Window Sum</div>
                                    <div class="sw-sum-value" id="variableWindowSum">2</div>
                                </div>
                                <div class="sw-sum-item">
                                    <div class="sw-sum-label">Min Length</div>
                                    <div class="sw-sum-value max" id="variableMinLen">-</div>
                                </div>
                            </div>
                            <div class="sw-controls">
                                <button class="sw-btn sw-btn-primary" id="animateVariable">Animate</button>
                                <button class="sw-btn sw-btn-secondary" id="resetVariable">Reset</button>
                                <button class="sw-btn sw-btn-secondary" id="stepVariable">Step</button>
                            </div>
                            <div class="sw-status" id="variableStatus">Find minimum window with sum >= 7</div>
                        </div>
                    </div>

                    <script>
                    (function() {
                        // Sliding Window Animation State
                        const swState = {
                            fixed: { left: 0, windowSize: 3, animating: false, maxSum: 0, values: [2, 1, 5, 1, 3, 2] },
                            variable: { left: 0, right: 0, target: 7, animating: false, minLen: Infinity, values: [2, 3, 1, 2, 4, 3] }
                        };

                        function getWindowBounds(container, left, right) {
                            const cells = container.querySelectorAll('.sw-cell');
                            if (cells[left] && cells[right]) {
                                const containerRect = container.getBoundingClientRect();
                                const leftRect = cells[left].getBoundingClientRect();
                                const rightRect = cells[right].getBoundingClientRect();
                                return {
                                    left: leftRect.left - containerRect.left - 5,
                                    width: rightRect.right - leftRect.left + 10
                                };
                            }
                            return { left: 0, width: 0 };
                        }

                        function updateFixedWindowUI() {
                            const container = document.getElementById('fixedWindowArray');
                            const cells = container.querySelectorAll('.sw-cell');
                            const bracket = document.getElementById('fixedWindowBracket');
                            const right = swState.fixed.left + swState.fixed.windowSize - 1;

                            let windowSum = 0;
                            cells.forEach((cell, idx) => {
                                cell.classList.remove('in-window', 'highlight', 'animate-in');
                                if (idx >= swState.fixed.left && idx <= right && idx < cells.length) {
                                    cell.classList.add('in-window');
                                    windowSum += swState.fixed.values[idx];
                                }
                            });

                            const bounds = getWindowBounds(container, swState.fixed.left, Math.min(right, cells.length - 1));
                            bracket.style.left = bounds.left + 'px';
                            bracket.style.width = bounds.width + 'px';

                            document.getElementById('fixedWindowSum').textContent = windowSum;
                            if (windowSum > swState.fixed.maxSum) {
                                swState.fixed.maxSum = windowSum;
                            }
                            document.getElementById('fixedMaxSum').textContent = swState.fixed.maxSum;
                        }

                        function animateFixedWindow() {
                            if (swState.fixed.animating) return;
                            swState.fixed.animating = true;
                            swState.fixed.left = 0;
                            swState.fixed.maxSum = 0;
                            document.getElementById('animateFixed').disabled = true;

                            const animate = () => {
                                const maxLeft = swState.fixed.values.length - swState.fixed.windowSize;
                                if (swState.fixed.left > maxLeft) {
                                    document.getElementById('fixedStatus').textContent =
                                        'Complete! Maximum sum found: ' + swState.fixed.maxSum;
                                    swState.fixed.animating = false;
                                    document.getElementById('animateFixed').disabled = false;
                                    return;
                                }

                                updateFixedWindowUI();
                                const right = swState.fixed.left + swState.fixed.windowSize - 1;
                                let sum = 0;
                                for (let i = swState.fixed.left; i <= right; i++) {
                                    sum += swState.fixed.values[i];
                                }
                                document.getElementById('fixedStatus').textContent =
                                    'Window [' + swState.fixed.left + ',' + right + '] sum = ' + sum +
                                    (sum === swState.fixed.maxSum ? ' (new max!)' : '');

                                setTimeout(() => {
                                    swState.fixed.left++;
                                    setTimeout(animate, 800);
                                }, 600);
                            };

                            animate();
                        }

                        function stepFixedWindow() {
                            const maxLeft = swState.fixed.values.length - swState.fixed.windowSize;
                            if (swState.fixed.left > maxLeft) {
                                resetFixedWindow();
                                return;
                            }
                            updateFixedWindowUI();
                            swState.fixed.left++;
                        }

                        function resetFixedWindow() {
                            swState.fixed.left = 0;
                            swState.fixed.maxSum = 0;
                            swState.fixed.animating = false;
                            document.getElementById('animateFixed').disabled = false;
                            updateFixedWindowUI();
                            document.getElementById('fixedStatus').textContent = 'Find maximum sum of any 3 consecutive elements';
                        }

                        function updateVariableWindowUI() {
                            const container = document.getElementById('variableWindowArray');
                            const cells = container.querySelectorAll('.sw-cell');
                            const bracket = document.getElementById('variableWindowBracket');

                            let windowSum = 0;
                            cells.forEach((cell, idx) => {
                                cell.classList.remove('in-window', 'highlight', 'animate-in');
                                if (idx >= swState.variable.left && idx <= swState.variable.right) {
                                    cell.classList.add('in-window');
                                    windowSum += swState.variable.values[idx];
                                }
                            });

                            const bounds = getWindowBounds(container, swState.variable.left, swState.variable.right);
                            bracket.style.left = bounds.left + 'px';
                            bracket.style.width = bounds.width + 'px';

                            document.getElementById('variableWindowSum').textContent = windowSum;
                            document.getElementById('variableMinLen').textContent =
                                swState.variable.minLen === Infinity ? '-' : swState.variable.minLen;

                            return windowSum;
                        }

                        function animateVariableWindow() {
                            if (swState.variable.animating) return;
                            swState.variable.animating = true;
                            swState.variable.left = 0;
                            swState.variable.right = 0;
                            swState.variable.minLen = Infinity;
                            document.getElementById('animateVariable').disabled = true;

                            let currentSum = swState.variable.values[0];

                            const animate = () => {
                                if (swState.variable.right >= swState.variable.values.length) {
                                    document.getElementById('variableStatus').textContent =
                                        'Complete! Minimum window length: ' +
                                        (swState.variable.minLen === Infinity ? 'none found' : swState.variable.minLen);
                                    swState.variable.animating = false;
                                    document.getElementById('animateVariable').disabled = false;
                                    return;
                                }

                                const windowSum = updateVariableWindowUI();
                                const windowLen = swState.variable.right - swState.variable.left + 1;

                                if (windowSum >= swState.variable.target) {
                                    if (windowLen < swState.variable.minLen) {
                                        swState.variable.minLen = windowLen;
                                    }
                                    document.getElementById('fixedStatus').textContent;
                                    document.getElementById('variableStatus').textContent =
                                        'Sum ' + windowSum + ' >= ' + swState.variable.target + '! Length=' + windowLen + '. Shrinking window...';

                                    setTimeout(() => {
                                        currentSum -= swState.variable.values[swState.variable.left];
                                        swState.variable.left++;
                                        setTimeout(animate, 600);
                                    }, 800);
                                } else {
                                    document.getElementById('variableStatus').textContent =
                                        'Sum ' + windowSum + ' < ' + swState.variable.target + '. Expanding window...';

                                    setTimeout(() => {
                                        swState.variable.right++;
                                        if (swState.variable.right < swState.variable.values.length) {
                                            currentSum += swState.variable.values[swState.variable.right];
                                        }
                                        setTimeout(animate, 600);
                                    }, 800);
                                }
                            };

                            animate();
                        }

                        function stepVariableWindow() {
                            if (swState.variable.right >= swState.variable.values.length) {
                                resetVariableWindow();
                                return;
                            }

                            const windowSum = updateVariableWindowUI();
                            if (windowSum >= swState.variable.target) {
                                const windowLen = swState.variable.right - swState.variable.left + 1;
                                if (windowLen < swState.variable.minLen) {
                                    swState.variable.minLen = windowLen;
                                }
                                swState.variable.left++;
                            } else {
                                swState.variable.right++;
                            }
                            updateVariableWindowUI();
                        }

                        function resetVariableWindow() {
                            swState.variable.left = 0;
                            swState.variable.right = 0;
                            swState.variable.minLen = Infinity;
                            swState.variable.animating = false;
                            document.getElementById('animateVariable').disabled = false;
                            updateVariableWindowUI();
                            document.getElementById('variableStatus').textContent = 'Find minimum window with sum >= 7';
                        }

                        // Initialize after DOM is ready
                        document.addEventListener('DOMContentLoaded', function() {
                            // Set up event listeners for sliding window
                            document.getElementById('animateFixed').addEventListener('click', animateFixedWindow);
                            document.getElementById('resetFixed').addEventListener('click', resetFixedWindow);
                            document.getElementById('stepFixed').addEventListener('click', stepFixedWindow);
                            document.getElementById('animateVariable').addEventListener('click', animateVariableWindow);
                            document.getElementById('resetVariable').addEventListener('click', resetVariableWindow);
                            document.getElementById('stepVariable').addEventListener('click', stepVariableWindow);

                            // Initial render with a small delay to ensure layout is complete
                            setTimeout(() => {
                                updateFixedWindowUI();
                                updateVariableWindowUI();
                            }, 100);
                        });
                    })();
                    </script>
                </div>

                <h4>Template</h4>
                <div class="code-block">
                    <pre><code class="language-python">def sliding_window(arr):
    left = 0
    result = initial_value
    window_state = {}  # Track window contents

    for right in range(len(arr)):
        # Expand: add arr[right] to window
        update_window(window_state, arr[right])

        # Contract: shrink while invalid
        while not valid(window_state):
            remove_from_window(window_state, arr[left])
            left += 1

        # Update result
        result = update_result(result, window_state)

    return result</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Longest Substring Without Repeating Characters</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def length_of_longest_substring(s):
    """Find longest substring without repeating characters.
    Time: O(n), Space: O(min(n, alphabet_size))
    """
    char_index = {}  # Last index of each character
    left = 0
    max_length = 0

    for right, char in enumerate(s):
        # If char in window, move left past its last occurrence
        if char in char_index and char_index[char] >= left:
            left = char_index[char] + 1

        char_index[char] = right
        max_length = max(max_length, right - left + 1)

    return max_length

# Example: "abcabcbb" -> 3 ("abc")</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Minimum Window Substring</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">from collections import Counter

def min_window(s, t):
    """Find minimum window containing all characters of t.
    Time: O(n), Space: O(m) where m = len(t)
    """
    if not t or not s:
        return ""

    target_count = Counter(t)
    required = len(target_count)

    left = 0
    formed = 0
    window_counts = {}
    result = (float('inf'), 0, 0)  # (length, left, right)

    for right, char in enumerate(s):
        # Add character to window
        window_counts[char] = window_counts.get(char, 0) + 1

        # Check if frequency matches target
        if char in target_count and window_counts[char] == target_count[char]:
            formed += 1

        # Contract window while valid
        while formed == required:
            # Update result if smaller
            if right - left + 1 < result[0]:
                result = (right - left + 1, left, right)

            # Remove left character
            left_char = s[left]
            window_counts[left_char] -= 1
            if left_char in target_count and window_counts[left_char] < target_count[left_char]:
                formed -= 1
            left += 1

    return "" if result[0] == float('inf') else s[result[1]:result[2]+1]</code></pre>
                </div>
            </div>
        </div>

        <!-- Prefix Sum Section -->
        <h2 class="mt-4">Prefix Sum</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Pattern Overview</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Prefix sum precomputes cumulative sums for O(1) range queries.</p>

                <div class="code-block">
                    <pre><code class="language-python"># Build prefix sum array
# prefix[i] = sum of arr[0:i]
def build_prefix(arr):
    prefix = [0] * (len(arr) + 1)
    for i in range(len(arr)):
        prefix[i + 1] = prefix[i] + arr[i]
    return prefix

# Sum of range [left, right] inclusive
def range_sum(prefix, left, right):
    return prefix[right + 1] - prefix[left]

# Example
arr = [1, 2, 3, 4, 5]
prefix = [0, 1, 3, 6, 10, 15]
# Sum of arr[1:3] = prefix[4] - prefix[1] = 10 - 1 = 9</code></pre>
                </div>

                <h4>Use Cases</h4>
                <ul>
                    <li>Range sum queries</li>
                    <li>Subarray sum equals K</li>
                    <li>Product of array except self</li>
                </ul>
            </div>
        </div>

        <!-- Real-World Scale Examples -->
        <h2 class="mt-4">Real-World Scale Examples</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Netflix: Processing Millions of Streaming Events with Sliding Window</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Netflix processes 400 billion events per day from 230 million subscribers. Their real-time analytics use sliding window algorithms extensively:</p>

                <h4>Use Case: Quality of Experience (QoE) Monitoring</h4>
                <ul>
                    <li>Track buffering events per user over 5-minute windows</li>
                    <li>Detect degradation patterns: "3+ buffering events in 60 seconds"</li>
                    <li>Trigger CDN switching or bitrate adaptation</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># Simplified Netflix-style streaming health monitor
from collections import deque
import time

class StreamHealthMonitor:
    """
    Track events in sliding time window.
    Netflix uses this pattern at 100K+ events/second per server.
    """
    def __init__(self, window_seconds=60):
        self.window_seconds = window_seconds
        self.events = deque()  # (timestamp, event_type)

    def record_event(self, event_type):
        """O(1) amortized - add event and clean old ones."""
        now = time.time()
        self.events.append((now, event_type))

        # Slide window - remove expired events
        while self.events and self.events[0][0] < now - self.window_seconds:
            self.events.popleft()

    def get_count(self, event_type):
        """O(n) where n = events in window, but window is bounded."""
        return sum(1 for _, et in self.events if et == event_type)

    def should_switch_cdn(self):
        """Trigger CDN switch if too many buffer events."""
        return self.get_count('buffer') >= 3

# At Netflix scale: sharded by user_id, aggregated with Apache Kafka Streams</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Spotify: Two-Pointer Merge for Playlist Generation</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Spotify generates personalized playlists for 515 million users. Their "Discover Weekly" algorithm merges sorted preference lists using two-pointer techniques:</p>

                <div class="code-block">
                    <pre><code class="language-python"># Spotify-style playlist merging
def merge_preference_lists(user_likes, collaborative_recs, content_recs):
    """
    Merge multiple sorted recommendation lists by score.
    Two-pointer approach: O(n + m + k) vs O((n+m+k) log (n+m+k)) for sort-all.

    At Spotify scale (500M+ users, 100M+ tracks), this matters.
    """
    # Each list is pre-sorted by relevance score (descending)
    result = []
    pointers = [0, 0, 0]
    lists = [user_likes, collaborative_recs, content_recs]
    weights = [0.5, 0.3, 0.2]  # Prioritize user history

    while len(result) < 30:  # Discover Weekly has 30 songs
        best_score = -1
        best_list = -1

        for i, lst in enumerate(lists):
            if pointers[i] < len(lst):
                weighted_score = lst[pointers[i]]['score'] * weights[i]
                if weighted_score > best_score:
                    best_score = weighted_score
                    best_list = i

        if best_list == -1:
            break

        track = lists[best_list][pointers[best_list]]
        if track not in result:  # Dedup
            result.append(track)
        pointers[best_list] += 1

    return result</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Uber: Prefix Sum for Surge Pricing Calculations</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Uber processes 17 million trips daily. Surge pricing requires real-time demand analysis across geographic zones. Prefix sums enable instant range queries:</p>

                <h4>Problem: "How many ride requests in zone X,Y in the last 5 minutes?"</h4>

                <div class="code-block">
                    <pre><code class="language-python"># Uber-style 2D prefix sum for geographic demand
class DemandGrid:
    """
    2D prefix sum for O(1) rectangular region queries.
    Critical for real-time surge pricing decisions.
    """
    def __init__(self, grid_size=1000):  # 1000x1000 cells covering city
        self.grid_size = grid_size
        self.counts = [[0] * grid_size for _ in range(grid_size)]
        self.prefix = None

    def add_request(self, lat, lon):
        """Map GPS to grid cell and increment."""
        x, y = self._to_grid(lat, lon)
        self.counts[x][y] += 1
        self.prefix = None  # Invalidate cache

    def _build_prefix(self):
        """O(n^2) - rebuild prefix sum matrix."""
        n = self.grid_size
        self.prefix = [[0] * (n + 1) for _ in range(n + 1)]

        for i in range(n):
            for j in range(n):
                self.prefix[i+1][j+1] = (
                    self.counts[i][j] +
                    self.prefix[i][j+1] +
                    self.prefix[i+1][j] -
                    self.prefix[i][j]
                )

    def get_demand(self, x1, y1, x2, y2):
        """O(1) query for rectangular region demand."""
        if self.prefix is None:
            self._build_prefix()

        return (
            self.prefix[x2+1][y2+1] -
            self.prefix[x1][y2+1] -
            self.prefix[x2+1][y1] +
            self.prefix[x1][y1]
        )

    def calculate_surge(self, x1, y1, x2, y2, available_drivers):
        """Surge = demand / supply ratio."""
        demand = self.get_demand(x1, y1, x2, y2)
        if available_drivers == 0:
            return 3.0  # Max surge
        ratio = demand / available_drivers
        return min(3.0, max(1.0, ratio))

# In production: time-bucketed (5-min windows), sharded by city</code></pre>
                </div>

                <p><strong>Why prefix sum?</strong> Without it, each surge calculation would scan all cells in the region - O(region_area). With prefix sum, it's O(1) per query. At 17M trips/day, this saves billions of operations.</p>
            </div>
        </div>

        <!-- Quiz Section -->
        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Interview Follow-up Questions -->
        <h2 class="mt-4">Interview Follow-up Questions</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Common Follow-ups & What Interviewers Look For</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. "How would you modify the sliding window if the window size is dynamic?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Variable-size window template (expand then contract)</li>
                    <li>Clear condition for when to shrink vs expand</li>
                    <li>Example: "Minimum window substring" pattern</li>
                </ul>
                <p><strong>Red flags:</strong> Confusing fixed-size and variable-size patterns.</p>

                <h4>2. "Why does two-pointer work on sorted arrays but not unsorted?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Monotonic property: moving left increases sum, right decreases</li>
                    <li>Without sorting, no guarantee about which pointer to move</li>
                    <li>Trade-off: sort first O(n log n) vs hash table O(n) for Two Sum</li>
                </ul>
                <p><strong>Red flags:</strong> Not understanding the invariant that makes two-pointer correct.</p>

                <h4>3. "How would you handle this if the data doesn't fit in memory?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>External sorting with merge sort (k-way merge)</li>
                    <li>Streaming algorithms for sliding window</li>
                    <li>Distributed prefix sums with MapReduce</li>
                </ul>
                <p><strong>Red flags:</strong> Only knowing in-memory solutions.</p>

                <h4>4. "Can you prove the two-pointer solution is correct?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Loop invariant: "All pairs (i, j) where i < left or j > right have been considered"</li>
                    <li>Termination: left and right converge</li>
                    <li>Why we never miss the optimal pair</li>
                </ul>
                <p><strong>Red flags:</strong> Cannot articulate why skipping pairs is safe.</p>

                <h4>5. "What's the space complexity of prefix sum? Can we do better?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Standard prefix sum: O(n) extra space</li>
                    <li>In-place modification if original array not needed</li>
                    <li>For 2D: O(n*m), can stream row-by-row for O(m)</li>
                </ul>
                <p><strong>Red flags:</strong> Not considering space optimization opportunities.</p>
            </div>
        </div>

        <!-- Practice Problems -->
        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Easy</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank">Two Sum II (LeetCode #167)</a></li>
                <li><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank">Valid Palindrome (LeetCode #125)</a></li>
                <li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank">Remove Duplicates (LeetCode #26)</a></li>
            </ul>

            <h4 class="mt-3">Medium</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/3sum/" target="_blank">3Sum (LeetCode #15)</a></li>
                <li><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank">Container With Most Water (LeetCode #11)</a></li>
                <li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank">Longest Substring Without Repeating (LeetCode #3)</a></li>
            </ul>

            <h4 class="mt-3">Hard</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank">Minimum Window Substring (LeetCode #76)</a></li>
                <li><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank">Trapping Rain Water (LeetCode #42)</a></li>
            </ul>
        </div>

        <!-- Navigation -->
        <div class="flex flex-between mt-4">
            <a href="module-01.html" class="btn btn-secondary">&larr; Module 1</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Sidebar toggle for mobile
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            // Update sidebar links based on completion status
            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('coding', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "When should you use two pointers from opposite ends?",
                    options: ["Unsorted arrays", "Finding cycles", "Sorted array pairs", "Counting elements"],
                    correct: 2,
                    explanation: "Opposite-end two pointers work best on sorted arrays for finding pairs."
                },
                {
                    question: "What's the time complexity of sliding window for longest substring without repeating?",
                    options: ["O(n²)", "O(n log n)", "O(n)", "O(1)"],
                    correct: 2,
                    explanation: "Each character is visited at most twice (once by right, once by left), so O(n)."
                },
                {
                    question: "What does prefix sum allow you to compute in O(1)?",
                    options: ["Maximum element", "Range sum", "Sorted order", "Unique elements"],
                    correct: 1,
                    explanation: "prefix[right+1] - prefix[left] gives sum of range [left, right] in O(1)."
                }
            ];

            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 2);
            alert('Module 2 marked as complete!');
            window.location.href = 'module-03.html';
        }
    </script>
</body>
</html>
