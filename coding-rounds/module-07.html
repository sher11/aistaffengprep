<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 7: Heaps & Sorting - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Fundamentals</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Foundations
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Arrays & Two Pointers
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Patterns</div>
                    <a href="module-03.html" class="sidebar-link" data-module="3">
                        <span class="sidebar-link-number">3</span>Trees & Binary Search
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Graphs
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Dynamic Programming
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Advanced</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">6</span>Backtracking
                    </a>
                    <a href="module-07.html" class="sidebar-link active" data-module="7">
                        <span class="sidebar-link-number">7</span>Heaps & Sorting
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">8</span>Non-LeetCode Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">9</span>Interview Simulation
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Main Content -->
        <main class="main-content">
        <h1>Module 7: Heaps, Priority Queues & Sorting</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Understand heap data structure and operations</li>
                <li>Solve Top-K problems efficiently</li>
                <li>Use heaps for merge operations</li>
                <li>Understand sorting algorithm trade-offs</li>
            </ul>
        </div>

        <h2 class="mt-4">Heap Basics</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Heap Operations</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Operation</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Time</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">peek</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(1)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Get min/max</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">push</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(log n)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Insert element</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">pop</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(log n)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Remove min/max</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">heapify</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(n)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Build heap from array</td></tr>
                    </tbody>
                </table>

                <div class="code-block">
                    <pre><code class="language-python">import heapq

# Python heapq is a MIN heap
nums = [3, 1, 4, 1, 5, 9]
heapq.heapify(nums)  # O(n) - transforms list in-place

heapq.heappush(nums, 2)   # O(log n)
smallest = heapq.heappop(nums)  # O(log n) - removes and returns smallest

# For MAX heap, negate values
max_heap = [-x for x in nums]
heapq.heapify(max_heap)
largest = -heapq.heappop(max_heap)</code></pre>
                </div>
            </div>
        </div>

        <h2 class="mt-4">Top-K Problems</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Kth Largest Element</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">import heapq

def find_kth_largest(nums, k):
    """
    Find kth largest using min heap of size k.
    Time: O(n log k), Space: O(k)
    """
    # Keep k largest elements
    min_heap = []

    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)  # Remove smallest

    return min_heap[0]  # Kth largest is the smallest in heap

# Alternative: O(n) average with quickselect
def find_kth_largest_quickselect(nums, k):
    k = len(nums) - k  # Convert to kth smallest index

    def quickselect(l, r):
        pivot, p = nums[r], l
        for i in range(l, r):
            if nums[i] <= pivot:
                nums[p], nums[i] = nums[i], nums[p]
                p += 1
        nums[p], nums[r] = nums[r], nums[p]

        if p > k: return quickselect(l, p - 1)
        elif p < k: return quickselect(p + 1, r)
        else: return nums[p]

    return quickselect(0, len(nums) - 1)</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Merge K Sorted Lists</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">import heapq

def merge_k_lists(lists):
    """
    Merge k sorted linked lists.
    Time: O(n log k), Space: O(k)
    """
    # Min heap of (value, index, node)
    heap = []

    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst.val, i, lst))

    dummy = ListNode()
    current = dummy

    while heap:
        val, i, node = heapq.heappop(heap)
        current.next = node
        current = current.next

        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))

    return dummy.next</code></pre>
                </div>
            </div>
        </div>

        <h2 class="mt-4">Sorting Algorithms</h2>

        <!-- Interactive Sorting Visualization -->
        <div class="interactive-demo">
            <h4>Sorting Algorithm Comparison</h4>
            <p class="text-muted">Watch different sorting algorithms in action. Notice how they differ in behavior and performance.</p>

            <div class="viz-controls">
                <button id="sort-bubble" class="active">Bubble Sort</button>
                <button id="sort-quick">Quick Sort</button>
                <button id="sort-merge">Merge Sort</button>
                <button id="sort-heap">Heap Sort</button>
            </div>

            <div class="viz-controls mt-2">
                <button id="sort-play">&#9658; Play</button>
                <button id="sort-step">Step</button>
                <button id="sort-reset">Reset</button>
                <button id="sort-new">New Array</button>
            </div>

            <div id="sort-viz" class="mt-2" style="min-height: 200px;"></div>

            <div style="display: flex; gap: 1rem; margin-top: 1rem; flex-wrap: wrap;">
                <div class="card" style="flex: 1; min-width: 150px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);" id="sort-comparisons">0</div>
                    <div style="font-size: 0.85rem; color: var(--text-light);">Comparisons</div>
                </div>
                <div class="card" style="flex: 1; min-width: 150px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--secondary-color);" id="sort-swaps">0</div>
                    <div style="font-size: 0.85rem; color: var(--text-light);">Swaps</div>
                </div>
                <div class="card" style="flex: 1; min-width: 150px; text-align: center;">
                    <div id="sort-complexity" style="font-size: 0.9rem; font-weight: bold;">O(n²)</div>
                    <div style="font-size: 0.85rem; color: var(--text-light);">Time Complexity</div>
                </div>
            </div>

            <div id="sort-explanation" class="callout callout-info mt-2">
                <p>Select an algorithm and click <strong>Play</strong> to watch it sort the array.</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Algorithm Comparison</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Algorithm</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Time (avg)</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Space</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Stable</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Quick Sort</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(n log n)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(log n)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">No</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Merge Sort</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(n log n)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(n)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Yes</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Heap Sort</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(n log n)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(1)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">No</td></tr>
                        <tr><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Counting Sort</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(n + k)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(k)</td><td style="padding: 0.75rem; border: 1px solid var(--border-color);">Yes</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Real-World Scale Examples -->
        <h2 class="mt-4">Real-World Scale Examples</h2>

        <div class="card" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; margin-bottom: 1.5rem;">
            <h3 style="color: white;">Heaps & Sorting Power Critical Infrastructure</h3>
            <p>From ranking 8.5B Google searches daily to Kafka processing 2 trillion messages, these data structures handle the world's data at scale. Understanding them is essential for staff-level engineering.</p>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Kafka: Log Compaction & Message Ordering (2T+ Messages/Day)</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Scale:</strong> Apache Kafka handles 2+ trillion messages per day at LinkedIn alone. Netflix processes 8+ million events per second through Kafka.</p>

                <h4>Why Heaps in Kafka?</h4>
                <p>Kafka uses heaps for:</p>
                <ul>
                    <li><strong>Log compaction:</strong> Keep only latest value per key (min-heap by timestamp)</li>
                    <li><strong>Delayed message delivery:</strong> Priority queue for scheduled messages</li>
                    <li><strong>Consumer rebalancing:</strong> Assign partitions to minimize lag (heap-based load balancing)</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># Kafka-style log compaction using heap
# Keeps only latest value per key to reduce storage

import heapq
from collections import defaultdict

class LogCompactor:
    """
    Kafka log compaction: retain only latest value per key.
    Scale: Kafka compacts billions of records to save 70%+ storage.

    Uses heap to process records in timestamp order,
    keeping only the most recent per key.
    """

    def compact(self, log_segments):
        """
        Input: Multiple log segments, each with [(key, value, timestamp), ...]
        Output: Compacted log with only latest value per key

        Algorithm: Merge segments using heap, track latest per key
        Time: O(N log K) where N = total records, K = segments
        """
        # Track latest value per key
        key_values = {}  # key -> (value, timestamp)

        # Min-heap for k-way merge: (timestamp, segment_idx, record, iterator)
        heap = []
        iterators = []

        # Initialize heap with first record from each segment
        for seg_idx, segment in enumerate(log_segments):
            it = iter(sorted(segment, key=lambda x: x[2]))  # Sort by timestamp
            iterators.append(it)
            try:
                record = next(it)
                heapq.heappush(heap, (record[2], seg_idx, record))
            except StopIteration:
                pass

        # Process all records in timestamp order
        while heap:
            timestamp, seg_idx, record = heapq.heappop(heap)
            key, value, ts = record

            # Update if this is newer (timestamp ordering ensures it is)
            if value is not None:  # None = tombstone (delete marker)
                key_values[key] = (value, ts)
            elif key in key_values:
                del key_values[key]  # Key deleted

            # Get next record from same segment
            try:
                next_record = next(iterators[seg_idx])
                heapq.heappush(heap, (next_record[2], seg_idx, next_record))
            except StopIteration:
                pass

        # Return compacted log
        return [(k, v, ts) for k, (v, ts) in key_values.items()]


class DelayedMessageQueue:
    """
    Kafka delayed delivery: schedule messages for future timestamps.
    Used for: retry after backoff, scheduled notifications, rate limiting.

    Priority queue (min-heap) by delivery timestamp.
    """

    def __init__(self):
        self.heap = []  # (delivery_time, sequence, message)
        self.sequence = 0  # Tie-breaker for same timestamp

    def schedule(self, message, deliver_at):
        """Add message to be delivered at specific time."""
        heapq.heappush(self.heap, (deliver_at, self.sequence, message))
        self.sequence += 1

    def get_ready_messages(self, current_time):
        """Get all messages ready for delivery."""
        ready = []
        while self.heap and self.heap[0][0] <= current_time:
            _, _, message = heapq.heappop(self.heap)
            ready.append(message)
        return ready

    def next_delivery_time(self):
        """When is the next message due?"""
        return self.heap[0][0] if self.heap else None


# Real optimization: Kafka uses time-wheel for O(1) scheduling
# instead of heap for better performance at very high throughput</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>High-Frequency Trading: Real-Time Order Book (Microsecond Latency)</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Scale:</strong> NYSE processes 6+ billion messages per day. HFT systems must maintain sorted order books and find best prices in nanoseconds.</p>

                <h4>Order Book = Two Heaps</h4>
                <p>An order book tracks all buy and sell orders. Matching engine needs instant access to best bid (max-heap) and best ask (min-heap).</p>

                <div class="code-block">
                    <pre><code class="language-python"># HFT Order Book using heaps
# Real systems use custom data structures for nanosecond performance

import heapq
from collections import defaultdict
from dataclasses import dataclass
from typing import List, Optional
import time

@dataclass
class Order:
    order_id: str
    price: float      # Price in cents to avoid float issues
    quantity: int
    timestamp: float  # Nanosecond precision in real systems
    side: str         # 'BUY' or 'SELL'

class OrderBook:
    """
    Matching engine order book using heaps.
    Scale: NASDAQ processes 1M+ orders/second with <10μs latency.

    Buy side: Max-heap (best bid = highest price)
    Sell side: Min-heap (best ask = lowest price)
    """

    def __init__(self, symbol: str):
        self.symbol = symbol
        self.buy_heap = []   # Max-heap: (-price, timestamp, order)
        self.sell_heap = []  # Min-heap: (price, timestamp, order)
        self.orders = {}     # order_id -> order (for cancellation)

    def add_order(self, order: Order) -> List[dict]:
        """
        Add order and attempt to match.
        Returns list of executed trades.

        Time: O(log n) for add, O(m log n) for m matches
        """
        trades = []

        if order.side == 'BUY':
            # Try to match with sell orders
            while (order.quantity > 0 and
                   self.sell_heap and
                   self.sell_heap[0][0] <= order.price):

                sell_price, _, sell_order = self.sell_heap[0]

                # Execute trade at sell price (price-time priority)
                trade_qty = min(order.quantity, sell_order.quantity)
                trades.append({
                    'price': sell_price,
                    'quantity': trade_qty,
                    'buyer': order.order_id,
                    'seller': sell_order.order_id,
                    'timestamp': time.time_ns()
                })

                order.quantity -= trade_qty
                sell_order.quantity -= trade_qty

                if sell_order.quantity == 0:
                    heapq.heappop(self.sell_heap)
                    del self.orders[sell_order.order_id]

            # Add remaining to book
            if order.quantity > 0:
                heapq.heappush(self.buy_heap,
                    (-order.price, order.timestamp, order))
                self.orders[order.order_id] = order

        else:  # SELL
            # Try to match with buy orders
            while (order.quantity > 0 and
                   self.buy_heap and
                   -self.buy_heap[0][0] >= order.price):

                neg_buy_price, _, buy_order = self.buy_heap[0]
                buy_price = -neg_buy_price

                trade_qty = min(order.quantity, buy_order.quantity)
                trades.append({
                    'price': buy_price,  # Execute at buy price
                    'quantity': trade_qty,
                    'buyer': buy_order.order_id,
                    'seller': order.order_id,
                    'timestamp': time.time_ns()
                })

                order.quantity -= trade_qty
                buy_order.quantity -= trade_qty

                if buy_order.quantity == 0:
                    heapq.heappop(self.buy_heap)
                    del self.orders[buy_order.order_id]

            if order.quantity > 0:
                heapq.heappush(self.sell_heap,
                    (order.price, order.timestamp, order))
                self.orders[order.order_id] = order

        return trades

    def get_best_bid(self) -> Optional[float]:
        """Best buy price - O(1)."""
        while self.buy_heap and self.buy_heap[0][2].quantity == 0:
            heapq.heappop(self.buy_heap)
        return -self.buy_heap[0][0] if self.buy_heap else None

    def get_best_ask(self) -> Optional[float]:
        """Best sell price - O(1)."""
        while self.sell_heap and self.sell_heap[0][2].quantity == 0:
            heapq.heappop(self.sell_heap)
        return self.sell_heap[0][0] if self.sell_heap else None

    def get_spread(self) -> Optional[float]:
        """Bid-ask spread - key market metric."""
        bid, ask = self.get_best_bid(), self.get_best_ask()
        return (ask - bid) if bid and ask else None


# Real HFT optimization: Use price-level aggregation + skip lists
# for O(1) best price access instead of heap</code></pre>
                </div>

                <h4>Why This Matters in Interviews</h4>
                <p>Order book design is a common system design question. Key insights:</p>
                <ul>
                    <li>Two heaps give O(1) best bid/ask and O(log n) order add/cancel</li>
                    <li>Price-time priority: same price orders fill in timestamp order</li>
                    <li>Real systems use skip lists or price-level maps for better cache performance</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Uber Surge Pricing: Real-Time Demand Aggregation</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Scale:</strong> Uber processes 17+ million trips daily across 10,000+ cities. Surge pricing updates every few minutes based on supply/demand in each area.</p>

                <h4>The Problem: Aggregate Demand in Grid Cells</h4>
                <p>Uber divides cities into hexagonal cells (H3 grid). Each cell needs real-time demand metrics to calculate surge. This is a streaming Top-K problem.</p>

                <div class="code-block">
                    <pre><code class="language-python"># Uber-style surge pricing using heap for top demand areas
# Simplied version of their H3-based geospatial system

import heapq
from collections import defaultdict
from dataclasses import dataclass
import time

@dataclass
class RideRequest:
    cell_id: str      # H3 hexagon ID
    timestamp: float
    rider_id: str

class SurgePricingEngine:
    """
    Real-time demand aggregation for surge pricing.
    Scale: Uber aggregates millions of events per minute.

    Uses sliding window + heap to find top demand areas.
    """

    def __init__(self, window_seconds=300, top_k=100):
        self.window = window_seconds  # 5-minute window
        self.top_k = top_k
        self.cell_requests = defaultdict(list)  # cell -> [timestamps]
        self.supply = defaultdict(int)  # cell -> available drivers

    def record_request(self, request: RideRequest):
        """Record ride request - O(1)."""
        self.cell_requests[request.cell_id].append(request.timestamp)

    def get_surge_areas(self) -> list:
        """
        Get top-K highest demand areas.
        Uses min-heap to efficiently track top demand cells.

        Time: O(C log K) where C = number of cells
        """
        current_time = time.time()
        cutoff = current_time - self.window

        # Calculate demand for each cell (requests in window)
        demand_scores = []
        for cell_id, timestamps in self.cell_requests.items():
            # Remove old requests (sliding window)
            self.cell_requests[cell_id] = [
                ts for ts in timestamps if ts > cutoff
            ]

            recent_requests = len(self.cell_requests[cell_id])
            drivers = self.supply.get(cell_id, 1)

            # Demand score = requests / supply
            # High score = need surge pricing
            score = recent_requests / max(drivers, 1)
            demand_scores.append((cell_id, score, recent_requests))

        # Use min-heap of size K to find top-K
        # More efficient than full sort: O(n log k) vs O(n log n)
        top_cells = heapq.nlargest(
            self.top_k,
            demand_scores,
            key=lambda x: x[1]
        )

        # Calculate surge multiplier
        result = []
        for cell_id, score, requests in top_cells:
            # Surge multiplier based on demand/supply ratio
            # Real Uber uses ML models with many more factors
            surge = min(1 + (score - 1) * 0.5, 3.0)  # Cap at 3x
            surge = max(surge, 1.0)  # Min 1x

            result.append({
                'cell_id': cell_id,
                'demand_score': score,
                'surge_multiplier': round(surge, 2),
                'requests_in_window': requests
            })

        return result

    def update_supply(self, cell_id: str, drivers: int):
        """Update available drivers in cell."""
        self.supply[cell_id] = drivers


class StreamingTopK:
    """
    More efficient: Maintain streaming top-K with heap.
    Updates in O(log K) instead of recalculating.
    """

    def __init__(self, k: int):
        self.k = k
        self.heap = []  # Min-heap of (score, id)
        self.scores = {}  # id -> current score

    def update(self, item_id: str, score: float):
        """
        Update item's score. Maintains top-K efficiently.
        Time: O(log K) amortized
        """
        old_score = self.scores.get(item_id)
        self.scores[item_id] = score

        if len(self.heap) < self.k:
            heapq.heappush(self.heap, (score, item_id))
        elif score > self.heap[0][0]:
            # New item better than current minimum in top-K
            if old_score is None or old_score <= self.heap[0][0]:
                heapq.heapreplace(self.heap, (score, item_id))

    def get_top_k(self):
        """Return current top-K. O(K log K)."""
        return sorted(self.heap, reverse=True)</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Google Search: Sorting Billions of Results</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Google processes 8.5 billion searches per day. Each query matches millions of documents that must be ranked and sorted. But users only see the top 10 - this is a Top-K problem at massive scale.</p>

                <h4>Why Full Sorting is Impossible</h4>
                <ul>
                    <li><strong>Query "python":</strong> Matches ~1 billion documents</li>
                    <li><strong>Full sort:</strong> O(n log n) = 30 billion comparisons</li>
                    <li><strong>Top-K with heap:</strong> O(n log k) = 10 billion comparisons for top 1000</li>
                    <li><strong>Reality:</strong> Google uses multi-stage filtering + heap merge</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># Google-style distributed top-K search results
import heapq

class DistributedSearchRanker:
    """
    Search results come from 1000s of index shards.
    Each shard returns its local top-K, then we merge.
    """
    def __init__(self, num_shards=1000, local_k=100, global_k=10):
        self.num_shards = num_shards
        self.local_k = local_k
        self.global_k = global_k

    def search_shard(self, shard_id, query):
        """
        Each shard has ~1M documents.
        Returns top local_k results using heap.
        """
        # In reality: TF-IDF / BM25 scoring + PageRank
        results = self.score_documents(shard_id, query)

        # Use min-heap of size k to find top-k
        # O(n log k) where n = documents in shard
        top_k = heapq.nlargest(self.local_k, results, key=lambda x: x['score'])
        return top_k

    def merge_results(self, shard_results):
        """
        Merge top-k from each shard into global top-k.
        This is k-way merge with heap: O(shards * local_k * log(shards))
        """
        # Create iterator for each shard's results
        iterators = [iter(sorted(r, key=lambda x: -x['score']))
                    for r in shard_results]

        # Min heap of (negative_score, shard_index, doc)
        heap = []
        for i, it in enumerate(iterators):
            try:
                doc = next(it)
                heapq.heappush(heap, (-doc['score'], i, doc, it))
            except StopIteration:
                pass

        # Extract global top-k
        global_top_k = []
        while heap and len(global_top_k) < self.global_k:
            neg_score, shard_idx, doc, it = heapq.heappop(heap)
            global_top_k.append(doc)

            try:
                next_doc = next(it)
                heapq.heappush(heap, (-next_doc['score'], shard_idx, next_doc, it))
            except StopIteration:
                pass

        return global_top_k

# Google optimization: "Two-phase ranking"
# Phase 1: Fast scorer returns top 1000 (approximate)
# Phase 2: Expensive ML model re-ranks top 1000 precisely</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Twitter: Real-Time Timeline Ranking with Heaps</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Twitter processes 500 million tweets per day. Your timeline merges tweets from 1000s of accounts you follow, ranked by relevance - a classic k-way merge problem.</p>

                <h4>Fan-out on Read vs Write</h4>
                <div class="code-block">
                    <pre><code class="language-python"># Twitter-style timeline generation
import heapq
from collections import defaultdict

class TimelineService:
    """
    Two approaches to timeline:
    1. Fan-out on write: Pre-compute timelines (fast read, slow write)
    2. Fan-out on read: Compute on demand (slow read, fast write)

    Twitter uses hybrid: celebrities fan-out on read, others on write.
    """
    def __init__(self):
        self.user_tweets = defaultdict(list)  # user -> [tweets]
        self.followers = defaultdict(set)      # user -> {followers}
        self.precomputed_timelines = {}        # For non-celebrity users

    def post_tweet(self, user_id, tweet):
        """O(1) for celebrities, O(followers) for regular users."""
        self.user_tweets[user_id].append(tweet)

        if self.is_celebrity(user_id):
            # Don't fan out - too many followers
            pass
        else:
            # Fan-out on write to followers' precomputed timelines
            for follower in self.followers[user_id]:
                if follower in self.precomputed_timelines:
                    self._add_to_timeline(follower, tweet)

    def get_timeline(self, user_id, limit=20):
        """
        Merge tweets from followed users using heap.
        O(following * tweets_per_user * log(following))
        """
        following = self.get_following(user_id)

        # Create heap of (timestamp, tweet, user_iterator)
        heap = []
        iterators = {}

        for followed_user in following:
            tweets = self.user_tweets[followed_user]
            if tweets:
                # Iterator from newest to oldest
                it = iter(reversed(tweets))
                tweet = next(it)
                iterators[followed_user] = it
                # Use negative timestamp for max-heap behavior
                heapq.heappush(heap, (-tweet['timestamp'], followed_user, tweet))

        # Extract top 'limit' tweets
        timeline = []
        while heap and len(timeline) < limit:
            _, user, tweet = heapq.heappop(heap)
            timeline.append(tweet)

            it = iterators.get(user)
            if it:
                try:
                    next_tweet = next(it)
                    heapq.heappush(heap, (-next_tweet['timestamp'], user, next_tweet))
                except StopIteration:
                    pass

        return timeline

# Reality: ML ranking layer on top for "relevance" vs just recency</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Apache Spark: External Sorting for Big Data</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>When data exceeds memory, external sorting becomes essential. Apache Spark, used by Netflix, Uber, and Airbnb, implements sophisticated external merge sort.</p>

                <h4>External Sort Algorithm</h4>
                <div class="code-block">
                    <pre><code class="language-python"># External merge sort (basis of Spark's shuffle)
import heapq
import tempfile
import os

class ExternalSorter:
    """
    Sort data larger than memory.
    Used in: Spark shuffle, database ORDER BY, MapReduce.
    """
    def __init__(self, memory_limit_mb=100):
        self.memory_limit = memory_limit_mb * 1024 * 1024
        self.temp_files = []

    def sort(self, input_file, output_file, key_func=lambda x: x):
        """
        Phase 1: Create sorted runs that fit in memory
        Phase 2: K-way merge sorted runs

        I/O complexity: O(N/M * log(N/M)) disk reads
        where N = data size, M = memory size
        """
        # Phase 1: Create sorted runs
        self._create_sorted_runs(input_file, key_func)

        # Phase 2: K-way merge
        self._merge_runs(output_file, key_func)

        # Cleanup temp files
        for f in self.temp_files:
            os.unlink(f)

    def _create_sorted_runs(self, input_file, key_func):
        """Load chunks, sort in memory, write to temp files."""
        chunk = []
        chunk_size = 0

        with open(input_file, 'r') as f:
            for line in f:
                chunk.append(line)
                chunk_size += len(line)

                if chunk_size >= self.memory_limit:
                    self._write_sorted_run(chunk, key_func)
                    chunk = []
                    chunk_size = 0

            if chunk:
                self._write_sorted_run(chunk, key_func)

    def _write_sorted_run(self, chunk, key_func):
        """Sort chunk and write to temp file."""
        chunk.sort(key=key_func)

        temp_fd, temp_path = tempfile.mkstemp()
        with os.fdopen(temp_fd, 'w') as f:
            for line in chunk:
                f.write(line)

        self.temp_files.append(temp_path)

    def _merge_runs(self, output_file, key_func):
        """K-way merge using min-heap."""
        # Open all temp files
        file_handles = [open(f, 'r') for f in self.temp_files]

        # Initialize heap with first element from each file
        heap = []
        for i, fh in enumerate(file_handles):
            line = fh.readline()
            if line:
                heapq.heappush(heap, (key_func(line), i, line))

        # Merge
        with open(output_file, 'w') as out:
            while heap:
                _, file_idx, line = heapq.heappop(heap)
                out.write(line)

                next_line = file_handles[file_idx].readline()
                if next_line:
                    heapq.heappush(heap, (key_func(next_line), file_idx, next_line))

        # Close file handles
        for fh in file_handles:
            fh.close()

# Spark optimization: Adaptive query execution chooses sort vs hash
# based on data characteristics at runtime</code></pre>
                </div>
            </div>
        </div>

        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Interview Follow-up Questions -->
        <h2 class="mt-4">Interview Follow-up Questions</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Common Follow-ups & What Interviewers Look For</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. "Why use a min-heap for finding top-K largest elements?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Min-heap of size K: smallest element is the "gatekeeper"</li>
                    <li>If new element > min, pop min and push new element</li>
                    <li>O(n log k) vs O(n log n) for full sort</li>
                </ul>
                <p><strong>Red flags:</strong> Using max-heap and keeping all n elements.</p>

                <h4>2. "When would you use QuickSelect instead of a heap for top-K?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>QuickSelect: O(n) average but modifies input array</li>
                    <li>Heap: O(n log k) but maintains streaming capability</li>
                    <li>QuickSelect: O(n^2) worst case without randomization</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing QuickSelect exists or its trade-offs.</p>

                <h4>3. "How would you maintain a running median of a stream?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Two heaps: max-heap for lower half, min-heap for upper half</li>
                    <li>Balance sizes (differ by at most 1)</li>
                    <li>Median = top of larger heap or average of both tops</li>
                </ul>
                <p><strong>Red flags:</strong> Sorting the entire stream for each query.</p>

                <h4>4. "Why is Merge Sort preferred for external sorting?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Sequential disk access (merge reads sequentially from runs)</li>
                    <li>Predictable I/O pattern (no random access like QuickSort)</li>
                    <li>Stable sorting often required for databases</li>
                </ul>
                <p><strong>Red flags:</strong> Not understanding disk I/O constraints.</p>

                <h4>5. "How would you sort 1TB of data with only 1GB of RAM?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>External merge sort: create 1000 sorted runs, k-way merge</li>
                    <li>Optimization: use multiple disk buffers to overlap I/O and CPU</li>
                    <li>Real systems: replacement selection for longer initial runs</li>
                </ul>
                <p><strong>Red flags:</strong> Only knowing in-memory sorting algorithms.</p>
            </div>
        </div>

        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Medium</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank">Kth Largest Element (LeetCode #215)</a></li>
                <li><a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank">Top K Frequent Elements (LeetCode #347)</a></li>
                <li><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank">Merge K Sorted Lists (LeetCode #23)</a></li>
                <li><a href="https://leetcode.com/problems/task-scheduler/" target="_blank">Task Scheduler (LeetCode #621)</a></li>
            </ul>
        </div>

        <div class="flex flex-between mt-4">
            <a href="module-06.html" class="btn btn-secondary">&larr; Module 6</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Sidebar toggle for mobile
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            // Update sidebar links based on completion status
            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('coding', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "What's the time complexity to find Kth largest using a heap of size k?",
                    options: ["O(n)", "O(n log n)", "O(n log k)", "O(k log n)"],
                    correct: 2,
                    explanation: "We process n elements, each heap operation is O(log k)."
                },
                {
                    question: "Python's heapq module implements which type of heap?",
                    options: ["Max heap", "Min heap", "Both", "Neither"],
                    correct: 1,
                    explanation: "Python heapq is a min heap. For max heap, negate values."
                },
                {
                    question: "Why is heapify O(n) instead of O(n log n)?",
                    options: ["It uses a different algorithm", "Most nodes are near the bottom and sift down a short distance", "It's only approximate", "Python optimizes it specially"],
                    correct: 1,
                    explanation: "Heapify uses sift-down from the bottom up. Half the nodes are leaves (0 work), quarter are one level up (1 swap max), etc. The sum converges to O(n)."
                },
                {
                    question: "For maintaining a running median, what two heaps do you use?",
                    options: ["Two min heaps", "Two max heaps", "Max heap for smaller half, min heap for larger half", "Min heap for smaller half, max heap for larger half"],
                    correct: 2,
                    explanation: "Max heap stores smaller half (top = largest of small), min heap stores larger half (top = smallest of large). Median is at the tops."
                }
            ];
            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();

            // Initialize sorting visualization
            initSortingVisualization();
        });

        function initSortingVisualization() {
            let arr = [];
            let steps = [];
            let currentStep = 0;
            let isPlaying = false;
            let playInterval = null;
            let comparisons = 0;
            let swaps = 0;
            let algorithm = 'bubble';

            const vizContainer = document.getElementById('sort-viz');
            const comparisonsDisplay = document.getElementById('sort-comparisons');
            const swapsDisplay = document.getElementById('sort-swaps');
            const complexityDisplay = document.getElementById('sort-complexity');
            const explanation = document.getElementById('sort-explanation');

            function generateArray() {
                arr = [];
                for (let i = 0; i < 12; i++) {
                    arr.push(Math.floor(Math.random() * 80) + 10);
                }
            }

            function render(highlights = {}) {
                const maxVal = Math.max(...arr);
                let html = '<div class="array-viz" style="align-items: flex-end; height: 180px;">';
                arr.forEach((val, i) => {
                    const height = (val / maxVal) * 150;
                    let classes = 'array-cell';
                    let bgColor = 'var(--border-color)';

                    if (highlights.comparing && highlights.comparing.includes(i)) {
                        bgColor = 'var(--warning-color)';
                    }
                    if (highlights.swapping && highlights.swapping.includes(i)) {
                        bgColor = 'var(--danger-color)';
                    }
                    if (highlights.sorted && highlights.sorted.includes(i)) {
                        bgColor = 'var(--secondary-color)';
                    }
                    if (highlights.pivot === i) {
                        bgColor = 'var(--primary-color)';
                    }

                    html += `<div style="display: flex; flex-direction: column; align-items: center; gap: 0.25rem;">
                        <div style="width: 35px; height: ${height}px; background: ${bgColor}; border-radius: 0.25rem 0.25rem 0 0; transition: all 0.15s;"></div>
                        <span style="font-size: 0.75rem;">${val}</span>
                    </div>`;
                });
                html += '</div>';
                vizContainer.innerHTML = html;

                comparisonsDisplay.textContent = comparisons;
                swapsDisplay.textContent = swaps;
            }

            function generateBubbleSortSteps() {
                steps = [];
                let a = [...arr];
                const n = a.length;
                const sorted = [];

                for (let i = 0; i < n - 1; i++) {
                    for (let j = 0; j < n - i - 1; j++) {
                        steps.push({ array: [...a], comparing: [j, j + 1], sorted: [...sorted] });
                        if (a[j] > a[j + 1]) {
                            [a[j], a[j + 1]] = [a[j + 1], a[j]];
                            steps.push({ array: [...a], swapping: [j, j + 1], sorted: [...sorted], swapped: true });
                        }
                    }
                    sorted.unshift(n - 1 - i);
                }
                sorted.unshift(0);
                steps.push({ array: [...a], sorted: [...sorted], done: true });
            }

            function generateQuickSortSteps() {
                steps = [];
                let a = [...arr];
                const sorted = [];

                function partition(low, high) {
                    const pivot = a[high];
                    steps.push({ array: [...a], pivot: high, comparing: [], sorted: [...sorted] });

                    let i = low - 1;
                    for (let j = low; j < high; j++) {
                        steps.push({ array: [...a], pivot: high, comparing: [j], sorted: [...sorted] });
                        if (a[j] < pivot) {
                            i++;
                            [a[i], a[j]] = [a[j], a[i]];
                            steps.push({ array: [...a], pivot: high, swapping: [i, j], sorted: [...sorted], swapped: true });
                        }
                    }
                    [a[i + 1], a[high]] = [a[high], a[i + 1]];
                    steps.push({ array: [...a], swapping: [i + 1, high], sorted: [...sorted], swapped: true });
                    sorted.push(i + 1);
                    return i + 1;
                }

                function quickSort(low, high) {
                    if (low < high) {
                        const pi = partition(low, high);
                        quickSort(low, pi - 1);
                        quickSort(pi + 1, high);
                    } else if (low === high) {
                        sorted.push(low);
                    }
                }

                quickSort(0, a.length - 1);
                steps.push({ array: [...a], sorted: Array.from({ length: a.length }, (_, i) => i), done: true });
            }

            function setAlgorithm(algo) {
                algorithm = algo;
                document.querySelectorAll('[id^="sort-"]').forEach(btn => {
                    if (btn.id.startsWith('sort-bubble') || btn.id.startsWith('sort-quick') ||
                        btn.id.startsWith('sort-merge') || btn.id.startsWith('sort-heap')) {
                        btn.classList.remove('active');
                    }
                });
                document.getElementById('sort-' + algo).classList.add('active');

                const complexities = {
                    bubble: { time: 'O(n²)', space: 'O(1)', desc: 'Simple but slow. Good for small or nearly-sorted arrays.' },
                    quick: { time: 'O(n log n) avg', space: 'O(log n)', desc: 'Fast in practice. Pivot selection matters.' },
                    merge: { time: 'O(n log n)', space: 'O(n)', desc: 'Stable, predictable. Uses extra space.' },
                    heap: { time: 'O(n log n)', space: 'O(1)', desc: 'In-place. Great for Top-K problems.' }
                };

                complexityDisplay.innerHTML = complexities[algo].time;
                explanation.innerHTML = `<p><strong>${algo.charAt(0).toUpperCase() + algo.slice(1)} Sort:</strong> ${complexities[algo].desc}</p>`;

                reset();
            }

            function reset() {
                pause();
                comparisons = 0;
                swaps = 0;
                currentStep = 0;

                if (algorithm === 'bubble') {
                    generateBubbleSortSteps();
                } else if (algorithm === 'quick') {
                    generateQuickSortSteps();
                } else {
                    // For merge and heap, use bubble as placeholder
                    generateBubbleSortSteps();
                }

                render();
            }

            function step() {
                if (currentStep >= steps.length) {
                    pause();
                    return false;
                }

                const s = steps[currentStep];
                arr = s.array;

                if (s.comparing) comparisons++;
                if (s.swapped) swaps++;

                render({
                    comparing: s.comparing,
                    swapping: s.swapping,
                    sorted: s.sorted,
                    pivot: s.pivot
                });

                currentStep++;
                return currentStep < steps.length;
            }

            function play() {
                if (isPlaying) return;
                isPlaying = true;
                playInterval = setInterval(() => {
                    if (!step()) pause();
                }, 150);
            }

            function pause() {
                isPlaying = false;
                if (playInterval) {
                    clearInterval(playInterval);
                    playInterval = null;
                }
            }

            // Event listeners
            document.getElementById('sort-bubble').addEventListener('click', () => setAlgorithm('bubble'));
            document.getElementById('sort-quick').addEventListener('click', () => setAlgorithm('quick'));
            document.getElementById('sort-merge').addEventListener('click', () => setAlgorithm('merge'));
            document.getElementById('sort-heap').addEventListener('click', () => setAlgorithm('heap'));
            document.getElementById('sort-play').addEventListener('click', play);
            document.getElementById('sort-step').addEventListener('click', () => { pause(); step(); });
            document.getElementById('sort-reset').addEventListener('click', reset);
            document.getElementById('sort-new').addEventListener('click', () => { generateArray(); reset(); });

            // Initialize
            generateArray();
            reset();
        }

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 7);
            alert('Module 7 marked as complete!');
            window.location.href = 'module-08.html';
        }
    </script>
</body>
</html>
