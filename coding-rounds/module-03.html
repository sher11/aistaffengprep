<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 3: Trees & Binary Search - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
                <li><a href="../generative-ai/index.html">Gen AI</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Fundamentals</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Foundations
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Arrays & Two Pointers
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Patterns</div>
                    <a href="module-03.html" class="sidebar-link active" data-module="3">
                        <span class="sidebar-link-number">3</span>Trees & Binary Search
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Graphs
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Dynamic Programming
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Advanced</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">6</span>Backtracking
                    </a>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">7</span>Heaps & Sorting
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">8</span>Non-LeetCode Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">9</span>Interview Simulation
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Main Content -->
        <main class="main-content">
        <h1>Module 3: Trees & Binary Search</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Implement all tree traversal methods (pre, in, post, level-order)</li>
                <li>Master binary search variations and boundary finding</li>
                <li>Understand BST properties and operations</li>
                <li>Solve common tree problems recursively and iteratively</li>
            </ul>
        </div>

        <!-- Tree Structure -->
        <h2 class="mt-4">Binary Tree Fundamentals</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Tree Traversals</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <!-- Interactive Tree Traversal Animation -->
                    <style>
                        .tree-animation-container {
                            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
                            border-radius: 16px;
                            padding: 30px;
                            position: relative;
                            overflow: hidden;
                            box-shadow: 0 20px 60px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1);
                        }
                        .tree-animation-container::before {
                            content: '';
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: radial-gradient(circle at 20% 80%, rgba(94, 234, 212, 0.1) 0%, transparent 50%),
                                        radial-gradient(circle at 80% 20%, rgba(168, 85, 247, 0.1) 0%, transparent 50%);
                            pointer-events: none;
                        }
                        .tree-svg-container {
                            position: relative;
                            z-index: 1;
                        }
                        .tree-node {
                            cursor: pointer;
                            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        }
                        .tree-node:hover .node-circle {
                            filter: drop-shadow(0 0 20px rgba(94, 234, 212, 0.8));
                            transform: scale(1.15);
                        }
                        .tree-node:hover .node-text {
                            fill: #fff;
                        }
                        .node-circle {
                            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                            transform-origin: center;
                        }
                        .node-circle.visiting {
                            fill: url(#visitingGradient) !important;
                            filter: drop-shadow(0 0 25px rgba(251, 191, 36, 0.9));
                            animation: pulse-glow 0.6s ease-in-out;
                        }
                        .node-circle.visited {
                            fill: url(#visitedGradient) !important;
                            filter: drop-shadow(0 0 15px rgba(34, 197, 94, 0.7));
                        }
                        @keyframes pulse-glow {
                            0%, 100% { transform: scale(1); }
                            50% { transform: scale(1.2); }
                        }
                        .tree-edge {
                            stroke: rgba(148, 163, 184, 0.4);
                            stroke-width: 3;
                            fill: none;
                            transition: all 0.4s ease;
                        }
                        .tree-edge.active {
                            stroke: url(#edgeGradient);
                            stroke-width: 4;
                            filter: drop-shadow(0 0 8px rgba(94, 234, 212, 0.6));
                        }
                        .tree-controls {
                            display: flex;
                            justify-content: center;
                            gap: 12px;
                            margin-top: 25px;
                            flex-wrap: wrap;
                            position: relative;
                            z-index: 1;
                        }
                        .tree-btn {
                            padding: 12px 24px;
                            border: none;
                            border-radius: 12px;
                            font-weight: 600;
                            font-size: 14px;
                            cursor: pointer;
                            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                            position: relative;
                            overflow: hidden;
                        }
                        .tree-btn::before {
                            content: '';
                            position: absolute;
                            top: 0;
                            left: -100%;
                            width: 100%;
                            height: 100%;
                            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
                            transition: left 0.5s;
                        }
                        .tree-btn:hover::before {
                            left: 100%;
                        }
                        .tree-btn-preorder {
                            background: linear-gradient(135deg, #8b5cf6, #a855f7);
                            color: white;
                            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
                        }
                        .tree-btn-preorder:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.5);
                        }
                        .tree-btn-inorder {
                            background: linear-gradient(135deg, #06b6d4, #0891b2);
                            color: white;
                            box-shadow: 0 4px 15px rgba(6, 182, 212, 0.4);
                        }
                        .tree-btn-inorder:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(6, 182, 212, 0.5);
                        }
                        .tree-btn-postorder {
                            background: linear-gradient(135deg, #f59e0b, #d97706);
                            color: white;
                            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
                        }
                        .tree-btn-postorder:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.5);
                        }
                        .tree-btn-levelorder {
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
                        }
                        .tree-btn-levelorder:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.5);
                        }
                        .tree-btn-reset {
                            background: linear-gradient(135deg, #64748b, #475569);
                            color: white;
                            box-shadow: 0 4px 15px rgba(100, 116, 139, 0.4);
                        }
                        .tree-btn-reset:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(100, 116, 139, 0.5);
                        }
                        .tree-btn:disabled {
                            opacity: 0.5;
                            cursor: not-allowed;
                            transform: none !important;
                        }
                        .traversal-output {
                            margin-top: 20px;
                            padding: 20px;
                            background: rgba(0, 0, 0, 0.3);
                            border-radius: 12px;
                            font-family: 'Fira Code', 'Monaco', monospace;
                            font-size: 18px;
                            text-align: center;
                            color: #e2e8f0;
                            min-height: 30px;
                            border: 1px solid rgba(148, 163, 184, 0.2);
                            position: relative;
                            z-index: 1;
                        }
                        .traversal-output .step-label {
                            display: block;
                            font-size: 12px;
                            color: #94a3b8;
                            margin-bottom: 8px;
                            text-transform: uppercase;
                            letter-spacing: 1px;
                        }
                        .traversal-output .values {
                            display: flex;
                            justify-content: center;
                            gap: 8px;
                            flex-wrap: wrap;
                        }
                        .traversal-output .value-item {
                            background: linear-gradient(135deg, #3b82f6, #2563eb);
                            padding: 8px 16px;
                            border-radius: 8px;
                            animation: pop-in 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
                        }
                        @keyframes pop-in {
                            0% { transform: scale(0); opacity: 0; }
                            100% { transform: scale(1); opacity: 1; }
                        }
                        .speed-control {
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            gap: 15px;
                            margin-top: 15px;
                            color: #94a3b8;
                            font-size: 14px;
                            position: relative;
                            z-index: 1;
                        }
                        .speed-control input[type="range"] {
                            width: 120px;
                            accent-color: #8b5cf6;
                        }
                    </style>
                    <div class="tree-animation-container" id="treeAnimationContainer">
                        <svg width="100%" height="280" viewBox="0 0 500 280" class="tree-svg-container">
                            <defs>
                                <linearGradient id="nodeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#3b82f6"/>
                                    <stop offset="100%" style="stop-color:#1d4ed8"/>
                                </linearGradient>
                                <linearGradient id="visitingGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#fbbf24"/>
                                    <stop offset="100%" style="stop-color:#f59e0b"/>
                                </linearGradient>
                                <linearGradient id="visitedGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#22c55e"/>
                                    <stop offset="100%" style="stop-color:#16a34a"/>
                                </linearGradient>
                                <linearGradient id="edgeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#5eead4"/>
                                    <stop offset="100%" style="stop-color:#2dd4bf"/>
                                </linearGradient>
                                <filter id="glow">
                                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                                    <feMerge>
                                        <feMergeNode in="coloredBlur"/>
                                        <feMergeNode in="SourceGraphic"/>
                                    </feMerge>
                                </filter>
                            </defs>
                            <!-- Edges -->
                            <path class="tree-edge" id="edge-1-2" d="M250,50 Q175,90 125,110"/>
                            <path class="tree-edge" id="edge-1-3" d="M250,50 Q325,90 375,110"/>
                            <path class="tree-edge" id="edge-2-4" d="M125,130 Q90,165 75,190"/>
                            <path class="tree-edge" id="edge-2-5" d="M125,130 Q160,165 175,190"/>
                            <path class="tree-edge" id="edge-3-6" d="M375,130 Q340,165 325,190"/>
                            <path class="tree-edge" id="edge-3-7" d="M375,130 Q410,165 425,190"/>
                            <!-- Nodes -->
                            <g class="tree-node" id="node-1" data-value="1">
                                <circle class="node-circle" cx="250" cy="40" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="250" y="46" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">1</text>
                            </g>
                            <g class="tree-node" id="node-2" data-value="2">
                                <circle class="node-circle" cx="125" cy="120" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="125" y="126" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">2</text>
                            </g>
                            <g class="tree-node" id="node-3" data-value="3">
                                <circle class="node-circle" cx="375" cy="120" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="375" y="126" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">3</text>
                            </g>
                            <g class="tree-node" id="node-4" data-value="4">
                                <circle class="node-circle" cx="75" cy="210" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="75" y="216" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">4</text>
                            </g>
                            <g class="tree-node" id="node-5" data-value="5">
                                <circle class="node-circle" cx="175" cy="210" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="175" y="216" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">5</text>
                            </g>
                            <g class="tree-node" id="node-6" data-value="6">
                                <circle class="node-circle" cx="325" cy="210" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="325" y="216" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">6</text>
                            </g>
                            <g class="tree-node" id="node-7" data-value="7">
                                <circle class="node-circle" cx="425" cy="210" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="425" y="216" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">7</text>
                            </g>
                        </svg>
                        <div class="tree-controls">
                            <button class="tree-btn tree-btn-preorder" onclick="runTraversal('preorder')">Preorder</button>
                            <button class="tree-btn tree-btn-inorder" onclick="runTraversal('inorder')">Inorder</button>
                            <button class="tree-btn tree-btn-postorder" onclick="runTraversal('postorder')">Postorder</button>
                            <button class="tree-btn tree-btn-levelorder" onclick="runTraversal('levelorder')">Level Order</button>
                            <button class="tree-btn tree-btn-reset" onclick="resetTree()">Reset</button>
                        </div>
                        <div class="speed-control">
                            <label>Speed:</label>
                            <input type="range" id="traversalSpeed" min="200" max="1500" value="700" step="100">
                            <span id="speedLabel">Medium</span>
                        </div>
                        <div class="traversal-output" id="traversalOutput">
                            <span class="step-label">Click a traversal button to begin</span>
                            <div class="values" id="outputValues"></div>
                        </div>
                    </div>
                    <script>
                        (function() {
                            const tree = {
                                1: { left: 2, right: 3 },
                                2: { left: 4, right: 5 },
                                3: { left: 6, right: 7 },
                                4: { left: null, right: null },
                                5: { left: null, right: null },
                                6: { left: null, right: null },
                                7: { left: null, right: null }
                            };

                            let isAnimating = false;
                            let animationSpeed = 700;

                            const speedSlider = document.getElementById('traversalSpeed');
                            const speedLabel = document.getElementById('speedLabel');

                            speedSlider.addEventListener('input', function() {
                                animationSpeed = parseInt(this.value);
                                const labels = { 200: 'Very Fast', 400: 'Fast', 700: 'Medium', 1000: 'Slow', 1500: 'Very Slow' };
                                speedLabel.textContent = labels[animationSpeed] || 'Medium';
                            });

                            function getTraversalOrder(type, nodeId = 1) {
                                if (!nodeId) return [];
                                const node = tree[nodeId];
                                switch(type) {
                                    case 'preorder':
                                        return [nodeId, ...getTraversalOrder(type, node.left), ...getTraversalOrder(type, node.right)];
                                    case 'inorder':
                                        return [...getTraversalOrder(type, node.left), nodeId, ...getTraversalOrder(type, node.right)];
                                    case 'postorder':
                                        return [...getTraversalOrder(type, node.left), ...getTraversalOrder(type, node.right), nodeId];
                                    case 'levelorder':
                                        return [1, 2, 3, 4, 5, 6, 7];
                                    default:
                                        return [];
                                }
                            }

                            function getEdgeId(from, to) {
                                return `edge-${from}-${to}`;
                            }

                            window.runTraversal = async function(type) {
                                if (isAnimating) return;
                                isAnimating = true;

                                document.querySelectorAll('.tree-btn').forEach(btn => btn.disabled = true);
                                resetTree();

                                const order = getTraversalOrder(type);
                                const outputEl = document.getElementById('traversalOutput');
                                const valuesEl = document.getElementById('outputValues');

                                const typeLabels = {
                                    preorder: 'Preorder: Root -> Left -> Right',
                                    inorder: 'Inorder: Left -> Root -> Right',
                                    postorder: 'Postorder: Left -> Right -> Root',
                                    levelorder: 'Level Order: BFS by level'
                                };

                                outputEl.querySelector('.step-label').textContent = typeLabels[type];
                                valuesEl.innerHTML = '';

                                for (let i = 0; i < order.length; i++) {
                                    const nodeId = order[i];
                                    const nodeEl = document.getElementById(`node-${nodeId}`);
                                    const circle = nodeEl.querySelector('.node-circle');

                                    // Mark as visiting
                                    circle.classList.add('visiting');

                                    // Highlight edge from parent
                                    if (nodeId !== 1) {
                                        const parent = nodeId <= 3 ? 1 : (nodeId <= 5 ? 2 : 3);
                                        const edgeEl = document.getElementById(getEdgeId(parent, nodeId));
                                        if (edgeEl) edgeEl.classList.add('active');
                                    }

                                    await new Promise(r => setTimeout(r, animationSpeed));

                                    // Mark as visited
                                    circle.classList.remove('visiting');
                                    circle.classList.add('visited');

                                    // Add to output
                                    const valueSpan = document.createElement('span');
                                    valueSpan.className = 'value-item';
                                    valueSpan.textContent = nodeId;
                                    valuesEl.appendChild(valueSpan);

                                    await new Promise(r => setTimeout(r, animationSpeed / 2));
                                }

                                isAnimating = false;
                                document.querySelectorAll('.tree-btn').forEach(btn => btn.disabled = false);
                            };

                            window.resetTree = function() {
                                document.querySelectorAll('.node-circle').forEach(circle => {
                                    circle.classList.remove('visiting', 'visited');
                                });
                                document.querySelectorAll('.tree-edge').forEach(edge => {
                                    edge.classList.remove('active');
                                });
                                const outputEl = document.getElementById('traversalOutput');
                                outputEl.querySelector('.step-label').textContent = 'Click a traversal button to begin';
                                document.getElementById('outputValues').innerHTML = '';
                            };
                        })();
                    </script>
                </div>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Traversal</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Order</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Result</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Preorder</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Root → Left → Right</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">1, 2, 4, 5, 3, 6, 7</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Inorder</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Left → Root → Right</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">4, 2, 5, 1, 6, 3, 7</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Postorder</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Left → Right → Root</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">4, 5, 2, 6, 7, 3, 1</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Level Order</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">BFS by level</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">1, 2, 3, 4, 5, 6, 7</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
                    <pre><code class="language-python"># Recursive Traversals
def preorder(root):
    if not root: return []
    return [root.val] + preorder(root.left) + preorder(root.right)

def inorder(root):
    if not root: return []
    return inorder(root.left) + [root.val] + inorder(root.right)

def postorder(root):
    if not root: return []
    return postorder(root.left) + postorder(root.right) + [root.val]

# Iterative Inorder (most common)
def inorder_iterative(root):
    result, stack = [], []
    current = root

    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        current = stack.pop()
        result.append(current.val)
        current = current.right

    return result

# Level Order (BFS)
from collections import deque

def level_order(root):
    if not root: return []
    result, queue = [], deque([root])

    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        result.append(level)

    return result</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Advanced Traversals: Morris & Iterative (Staff-Level)</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Why this matters at Staff level:</strong> Interviewers expect you to know O(1) space traversal methods and understand when recursion stack space matters in production systems.</p>

                <h4>Morris Traversal - O(1) Space Inorder</h4>
                <p>Morris traversal uses threading (temporary pointer modification) to achieve O(1) space without recursion or explicit stack. Critical for memory-constrained systems.</p>

                <div class="code-block">
                    <pre><code class="language-python">def morris_inorder(root):
    """
    Inorder traversal with O(1) space using Morris threading.

    Key insight: We temporarily create "threads" from rightmost node
    of left subtree back to current node. This lets us return to
    the current node after processing left subtree.

    Time: O(n), Space: O(1)
    """
    result = []
    current = root

    while current:
        if not current.left:
            # No left subtree - process current, go right
            result.append(current.val)
            current = current.right
        else:
            # Find inorder predecessor (rightmost in left subtree)
            predecessor = current.left
            while predecessor.right and predecessor.right != current:
                predecessor = predecessor.right

            if not predecessor.right:
                # Create thread back to current
                predecessor.right = current
                current = current.left
            else:
                # Thread exists - we've returned from left subtree
                # Remove thread, process current, go right
                predecessor.right = None
                result.append(current.val)
                current = current.right

    return result

def morris_preorder(root):
    """
    Preorder traversal with O(1) space.
    Similar to inorder, but process node before going left.
    """
    result = []
    current = root

    while current:
        if not current.left:
            result.append(current.val)
            current = current.right
        else:
            predecessor = current.left
            while predecessor.right and predecessor.right != current:
                predecessor = predecessor.right

            if not predecessor.right:
                # Process node BEFORE going left (preorder)
                result.append(current.val)
                predecessor.right = current
                current = current.left
            else:
                predecessor.right = None
                current = current.right

    return result</code></pre>
                </div>

                <h4>Iterative Preorder & Postorder</h4>
                <div class="code-block">
                    <pre><code class="language-python">def iterative_preorder(root):
    """
    Iterative preorder using explicit stack.
    Time: O(n), Space: O(h) where h = height
    """
    if not root:
        return []

    result = []
    stack = [root]

    while stack:
        node = stack.pop()
        result.append(node.val)
        # Push right first so left is processed first
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

    return result

def iterative_postorder(root):
    """
    Iterative postorder using two stacks OR reverse modified preorder.

    Method 1: Modified preorder then reverse
    - Preorder: Root -> Left -> Right
    - Modified: Root -> Right -> Left
    - Reversed: Left -> Right -> Root (postorder!)
    """
    if not root:
        return []

    result = []
    stack = [root]

    while stack:
        node = stack.pop()
        result.append(node.val)
        # Push left first (opposite of preorder)
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)

    return result[::-1]  # Reverse to get postorder

def iterative_postorder_single_stack(root):
    """
    True iterative postorder with single stack.
    More complex but demonstrates deeper understanding.
    """
    if not root:
        return []

    result = []
    stack = []
    current = root
    last_visited = None

    while stack or current:
        if current:
            stack.append(current)
            current = current.left
        else:
            peek_node = stack[-1]
            # If right child exists and not yet visited
            if peek_node.right and last_visited != peek_node.right:
                current = peek_node.right
            else:
                result.append(peek_node.val)
                last_visited = stack.pop()

    return result</code></pre>
                </div>

                <h4>When to Use Each Approach</h4>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Method</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Space</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Recursive</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(h) stack</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Simple, readable, interviews</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Iterative (stack)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(h) heap</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Avoid stack overflow, deep trees</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Morris</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(1)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Memory-critical systems, embedded</td>
                        </tr>
                    </tbody>
                </table>

                <p><strong>Staff-level insight:</strong> In production, Python's default recursion limit is ~1000. For trees deeper than this, you MUST use iterative approaches. Java's stack is typically 512KB-1MB, which allows ~10K-20K recursive calls.</p>
            </div>
        </div>

        <!-- Binary Search Section -->
        <h2 class="mt-4">Binary Search</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Standard Binary Search</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <!-- Interactive Binary Search Animation -->
                    <style>
                        .bs-animation-container {
                            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
                            border-radius: 16px;
                            padding: 30px;
                            position: relative;
                            overflow: hidden;
                            box-shadow: 0 20px 60px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
                        }
                        .bs-animation-container::before {
                            content: '';
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: radial-gradient(circle at 30% 70%, rgba(59, 130, 246, 0.15) 0%, transparent 50%),
                                        radial-gradient(circle at 70% 30%, rgba(16, 185, 129, 0.1) 0%, transparent 50%);
                            pointer-events: none;
                        }
                        .bs-array-container {
                            display: flex;
                            justify-content: center;
                            gap: 8px;
                            margin: 20px 0;
                            position: relative;
                            z-index: 1;
                        }
                        .bs-cell {
                            width: 55px;
                            height: 55px;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            justify-content: center;
                            border-radius: 12px;
                            font-weight: bold;
                            font-size: 18px;
                            color: #e2e8f0;
                            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                            position: relative;
                            background: linear-gradient(135deg, #475569, #334155);
                            border: 2px solid rgba(148, 163, 184, 0.3);
                            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                        }
                        .bs-cell .index {
                            font-size: 10px;
                            color: #94a3b8;
                            position: absolute;
                            top: -18px;
                        }
                        .bs-cell.in-range {
                            background: linear-gradient(135deg, #3b82f6, #2563eb);
                            border-color: #60a5fa;
                            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.4);
                        }
                        .bs-cell.mid {
                            background: linear-gradient(135deg, #f59e0b, #d97706);
                            border-color: #fbbf24;
                            transform: scale(1.15);
                            box-shadow: 0 8px 30px rgba(245, 158, 11, 0.5);
                            animation: pulse-mid 0.6s ease-in-out;
                        }
                        @keyframes pulse-mid {
                            0%, 100% { transform: scale(1.15); }
                            50% { transform: scale(1.25); }
                        }
                        .bs-cell.found {
                            background: linear-gradient(135deg, #22c55e, #16a34a);
                            border-color: #4ade80;
                            transform: scale(1.2);
                            box-shadow: 0 8px 35px rgba(34, 197, 94, 0.6);
                            animation: found-bounce 0.5s ease-out;
                        }
                        @keyframes found-bounce {
                            0% { transform: scale(1.15); }
                            50% { transform: scale(1.3); }
                            100% { transform: scale(1.2); }
                        }
                        .bs-cell.eliminated {
                            background: linear-gradient(135deg, #64748b, #475569);
                            opacity: 0.4;
                            transform: scale(0.9);
                            border-color: rgba(148, 163, 184, 0.2);
                        }
                        .bs-pointers {
                            display: flex;
                            justify-content: center;
                            gap: 8px;
                            margin-top: 10px;
                            position: relative;
                            z-index: 1;
                            height: 35px;
                        }
                        .bs-pointer-slot {
                            width: 55px;
                            display: flex;
                            justify-content: center;
                            font-size: 12px;
                            font-weight: 600;
                        }
                        .bs-pointer {
                            padding: 4px 10px;
                            border-radius: 6px;
                            animation: pointer-appear 0.3s ease-out;
                        }
                        @keyframes pointer-appear {
                            0% { transform: translateY(-10px); opacity: 0; }
                            100% { transform: translateY(0); opacity: 1; }
                        }
                        .bs-pointer.left { background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; }
                        .bs-pointer.right { background: linear-gradient(135deg, #ec4899, #db2777); color: white; }
                        .bs-pointer.mid-ptr { background: linear-gradient(135deg, #f59e0b, #d97706); color: white; }
                        .bs-controls {
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            gap: 15px;
                            margin-top: 25px;
                            position: relative;
                            z-index: 1;
                        }
                        .bs-target-input {
                            display: flex;
                            align-items: center;
                            gap: 12px;
                        }
                        .bs-target-input label {
                            color: #94a3b8;
                            font-size: 14px;
                        }
                        .bs-target-input input {
                            width: 80px;
                            padding: 10px 15px;
                            border: 2px solid rgba(148, 163, 184, 0.3);
                            border-radius: 10px;
                            background: rgba(0,0,0,0.3);
                            color: #e2e8f0;
                            font-size: 16px;
                            font-weight: 600;
                            text-align: center;
                            transition: all 0.3s ease;
                        }
                        .bs-target-input input:focus {
                            outline: none;
                            border-color: #3b82f6;
                            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
                        }
                        .bs-buttons {
                            display: flex;
                            gap: 12px;
                            flex-wrap: wrap;
                            justify-content: center;
                        }
                        .bs-btn {
                            padding: 12px 28px;
                            border: none;
                            border-radius: 12px;
                            font-weight: 600;
                            font-size: 14px;
                            cursor: pointer;
                            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                            position: relative;
                            overflow: hidden;
                        }
                        .bs-btn::before {
                            content: '';
                            position: absolute;
                            top: 0;
                            left: -100%;
                            width: 100%;
                            height: 100%;
                            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
                            transition: left 0.5s;
                        }
                        .bs-btn:hover::before {
                            left: 100%;
                        }
                        .bs-btn-search {
                            background: linear-gradient(135deg, #3b82f6, #2563eb);
                            color: white;
                            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
                        }
                        .bs-btn-search:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.5);
                        }
                        .bs-btn-step {
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
                        }
                        .bs-btn-step:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.5);
                        }
                        .bs-btn-reset {
                            background: linear-gradient(135deg, #64748b, #475569);
                            color: white;
                            box-shadow: 0 4px 15px rgba(100, 116, 139, 0.4);
                        }
                        .bs-btn-reset:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(100, 116, 139, 0.5);
                        }
                        .bs-btn:disabled {
                            opacity: 0.5;
                            cursor: not-allowed;
                            transform: none !important;
                        }
                        .bs-status {
                            margin-top: 20px;
                            padding: 15px 25px;
                            background: rgba(0,0,0,0.3);
                            border-radius: 12px;
                            text-align: center;
                            color: #e2e8f0;
                            font-size: 15px;
                            border: 1px solid rgba(148, 163, 184, 0.2);
                            position: relative;
                            z-index: 1;
                            min-height: 50px;
                        }
                        .bs-status .step-count {
                            font-size: 12px;
                            color: #94a3b8;
                            margin-bottom: 5px;
                        }
                        .bs-status .message {
                            font-weight: 500;
                        }
                        .bs-status .comparison {
                            font-family: 'Fira Code', monospace;
                            margin-top: 8px;
                            padding: 8px 15px;
                            background: rgba(59, 130, 246, 0.2);
                            border-radius: 8px;
                            display: inline-block;
                        }
                        .bs-legend {
                            display: flex;
                            justify-content: center;
                            gap: 20px;
                            margin-top: 15px;
                            flex-wrap: wrap;
                            position: relative;
                            z-index: 1;
                        }
                        .bs-legend-item {
                            display: flex;
                            align-items: center;
                            gap: 8px;
                            font-size: 12px;
                            color: #94a3b8;
                        }
                        .bs-legend-color {
                            width: 16px;
                            height: 16px;
                            border-radius: 4px;
                        }
                        .bs-legend-color.in-range-color { background: linear-gradient(135deg, #3b82f6, #2563eb); }
                        .bs-legend-color.mid-color { background: linear-gradient(135deg, #f59e0b, #d97706); }
                        .bs-legend-color.found-color { background: linear-gradient(135deg, #22c55e, #16a34a); }
                        .bs-legend-color.eliminated-color { background: linear-gradient(135deg, #64748b, #475569); opacity: 0.5; }
                    </style>
                    <div class="bs-animation-container" id="bsAnimationContainer">
                        <div class="bs-array-container" id="bsArray"></div>
                        <div class="bs-pointers" id="bsPointers"></div>
                        <div class="bs-controls">
                            <div class="bs-target-input">
                                <label>Target value:</label>
                                <input type="number" id="bsTarget" value="9" min="1" max="15">
                            </div>
                            <div class="bs-buttons">
                                <button class="bs-btn bs-btn-search" onclick="startBinarySearch()">Auto Search</button>
                                <button class="bs-btn bs-btn-step" onclick="stepBinarySearch()" id="bsStepBtn" disabled>Step</button>
                                <button class="bs-btn bs-btn-reset" onclick="resetBinarySearch()">Reset</button>
                            </div>
                        </div>
                        <div class="bs-status" id="bsStatus">
                            <div class="step-count" id="bsStepCount"></div>
                            <div class="message">Enter a target value and click "Auto Search" or "Step" to begin</div>
                        </div>
                        <div class="bs-legend">
                            <div class="bs-legend-item"><div class="bs-legend-color in-range-color"></div>In Search Range</div>
                            <div class="bs-legend-item"><div class="bs-legend-color mid-color"></div>Current Mid</div>
                            <div class="bs-legend-item"><div class="bs-legend-color found-color"></div>Found</div>
                            <div class="bs-legend-item"><div class="bs-legend-color eliminated-color"></div>Eliminated</div>
                        </div>
                    </div>
                    <script>
                        (function() {
                            const bsArray = [1, 3, 5, 7, 9, 11, 13];
                            let left = 0, right = bsArray.length - 1, mid = -1;
                            let target = 9;
                            let isSearching = false;
                            let stepCount = 0;
                            let found = false;
                            let searchComplete = false;

                            function renderArray() {
                                const container = document.getElementById('bsArray');
                                container.innerHTML = bsArray.map((val, idx) => {
                                    let classes = 'bs-cell';
                                    if (found && idx === mid) {
                                        classes += ' found';
                                    } else if (idx === mid && !searchComplete) {
                                        classes += ' mid';
                                    } else if (idx >= left && idx <= right && !searchComplete) {
                                        classes += ' in-range';
                                    } else if (searchComplete || idx < left || idx > right) {
                                        classes += ' eliminated';
                                    }
                                    return `<div class="${classes}"><span class="index">[${idx}]</span>${val}</div>`;
                                }).join('');
                            }

                            function renderPointers() {
                                const container = document.getElementById('bsPointers');
                                container.innerHTML = bsArray.map((_, idx) => {
                                    let content = '';
                                    if (idx === left && !searchComplete) content += '<span class="bs-pointer left">L</span>';
                                    if (idx === mid && !searchComplete && !found) content += '<span class="bs-pointer mid-ptr">M</span>';
                                    if (idx === right && !searchComplete) content += '<span class="bs-pointer right">R</span>';
                                    return `<div class="bs-pointer-slot">${content}</div>`;
                                }).join('');
                            }

                            function updateStatus(message, comparison = '') {
                                const statusEl = document.getElementById('bsStatus');
                                const stepCountEl = document.getElementById('bsStepCount');
                                stepCountEl.textContent = stepCount > 0 ? `Step ${stepCount}` : '';
                                statusEl.querySelector('.message').textContent = message;
                                if (comparison) {
                                    statusEl.innerHTML = `<div class="step-count">${stepCount > 0 ? 'Step ' + stepCount : ''}</div><div class="message">${message}</div><div class="comparison">${comparison}</div>`;
                                }
                            }

                            function initSearch() {
                                target = parseInt(document.getElementById('bsTarget').value) || 9;
                                left = 0;
                                right = bsArray.length - 1;
                                mid = -1;
                                stepCount = 0;
                                found = false;
                                searchComplete = false;
                                document.getElementById('bsStepBtn').disabled = false;
                                renderArray();
                                renderPointers();
                            }

                            function doStep() {
                                if (left > right) {
                                    searchComplete = true;
                                    updateStatus(`Target ${target} not found in the array!`);
                                    document.getElementById('bsStepBtn').disabled = true;
                                    renderArray();
                                    renderPointers();
                                    return false;
                                }

                                stepCount++;
                                mid = Math.floor(left + (right - left) / 2);

                                if (bsArray[mid] === target) {
                                    found = true;
                                    searchComplete = true;
                                    updateStatus(`Found ${target} at index ${mid}!`, `arr[${mid}] = ${bsArray[mid]} === ${target}`);
                                    document.getElementById('bsStepBtn').disabled = true;
                                    renderArray();
                                    renderPointers();
                                    return false;
                                } else if (bsArray[mid] < target) {
                                    updateStatus(`${bsArray[mid]} < ${target}, search right half`, `arr[${mid}] = ${bsArray[mid]} < ${target}`);
                                    renderArray();
                                    renderPointers();
                                    left = mid + 1;
                                } else {
                                    updateStatus(`${bsArray[mid]} > ${target}, search left half`, `arr[${mid}] = ${bsArray[mid]} > ${target}`);
                                    renderArray();
                                    renderPointers();
                                    right = mid - 1;
                                }
                                return true;
                            }

                            window.startBinarySearch = async function() {
                                if (isSearching) return;
                                isSearching = true;
                                document.querySelectorAll('.bs-btn').forEach(btn => btn.disabled = true);

                                initSearch();
                                updateStatus('Starting binary search...');
                                await new Promise(r => setTimeout(r, 600));

                                while (doStep()) {
                                    await new Promise(r => setTimeout(r, 1000));
                                }

                                isSearching = false;
                                document.querySelector('.bs-btn-search').disabled = false;
                                document.querySelector('.bs-btn-reset').disabled = false;
                            };

                            window.stepBinarySearch = function() {
                                if (isSearching) return;
                                if (stepCount === 0) {
                                    initSearch();
                                }
                                doStep();
                            };

                            window.resetBinarySearch = function() {
                                isSearching = false;
                                left = 0;
                                right = bsArray.length - 1;
                                mid = -1;
                                stepCount = 0;
                                found = false;
                                searchComplete = false;
                                document.querySelectorAll('.bs-btn').forEach(btn => btn.disabled = false);
                                document.getElementById('bsStepBtn').disabled = true;
                                renderArray();
                                renderPointers();
                                updateStatus('Enter a target value and click "Auto Search" or "Step" to begin');
                            };

                            // Initialize on load
                            renderArray();
                            renderPointers();
                        })();
                    </script>
                </div>

                <div class="code-block">
                    <pre><code class="language-python">def binary_search(arr, target):
    """Standard binary search for exact match.
    Time: O(log n), Space: O(1)
    """
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Avoid overflow

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1  # Not found</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Finding Boundaries</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python"># Find leftmost (first) position of target
def find_left_boundary(arr, target):
    left, right = 0, len(arr)

    while left < right:
        mid = left + (right - left) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid

    return left  # First index where arr[i] >= target

# Find rightmost (last) position of target
def find_right_boundary(arr, target):
    left, right = 0, len(arr)

    while left < right:
        mid = left + (right - left) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid

    return left - 1  # Last index where arr[i] <= target

# Find first and last position of element
def search_range(arr, target):
    left = find_left_boundary(arr, target)

    if left >= len(arr) or arr[left] != target:
        return [-1, -1]

    right = find_right_boundary(arr, target)
    return [left, right]</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Binary Search on Answer</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>When the answer itself has a monotonic property, binary search on the answer space.</p>

                <div class="code-block">
                    <pre><code class="language-python"># Example: Koko Eating Bananas
# Find minimum eating speed to finish within h hours

def min_eating_speed(piles, h):
    def can_finish(speed):
        hours = sum((pile + speed - 1) // speed for pile in piles)
        return hours <= h

    left, right = 1, max(piles)

    while left < right:
        mid = left + (right - left) // 2
        if can_finish(mid):
            right = mid  # Try slower speed
        else:
            left = mid + 1  # Need faster speed

    return left</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Binary Search in Rotated Sorted Array (Staff-Level)</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>A critical staff-level problem: searching in an array that was sorted, then rotated at some pivot point. This tests your ability to maintain binary search invariants in non-standard scenarios.</p>

                <h4>The Key Insight</h4>
                <p>In a rotated sorted array like <code>[4,5,6,7,0,1,2]</code>, at least one half is always sorted. We determine which half is sorted, then check if our target falls within that sorted range.</p>

                <div class="code-block">
                    <pre><code class="language-python">def search_rotated(nums, target):
    """
    Search in rotated sorted array with distinct values.
    Time: O(log n), Space: O(1)

    Key insight: At least one half is always sorted.
    Example: [4,5,6,7,0,1,2] rotated at index 4
    - If mid is at 7: left half [4,5,6,7] is sorted
    - If mid is at 0: right half [0,1,2] is sorted
    """
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = left + (right - left) // 2

        if nums[mid] == target:
            return mid

        # Determine which half is sorted
        if nums[left] <= nums[mid]:  # Left half is sorted
            if nums[left] <= target < nums[mid]:
                right = mid - 1  # Target in sorted left half
            else:
                left = mid + 1   # Target in unsorted right half
        else:  # Right half is sorted
            if nums[mid] < target <= nums[right]:
                left = mid + 1   # Target in sorted right half
            else:
                right = mid - 1  # Target in unsorted left half

    return -1

def search_rotated_with_duplicates(nums, target):
    """
    Search in rotated sorted array WITH DUPLICATES.
    Worst case: O(n) when all elements are same except one.
    Example: [1,1,1,1,1,1,1,1,1,1,1,1,0,1,1]

    Staff-level insight: Duplicates break our ability to determine
    which half is sorted when nums[left] == nums[mid] == nums[right].
    """
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = left + (right - left) // 2

        if nums[mid] == target:
            return True

        # Handle duplicates: can't determine sorted half
        if nums[left] == nums[mid] == nums[right]:
            left += 1
            right -= 1
        elif nums[left] <= nums[mid]:  # Left half is sorted
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:  # Right half is sorted
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1

    return False

def find_rotation_point(nums):
    """
    Find the index of minimum element (rotation point).
    This is where the array was rotated.

    Example: [4,5,6,7,0,1,2] -> returns 4 (index of 0)
    """
    left, right = 0, len(nums) - 1

    while left < right:
        mid = left + (right - left) // 2

        if nums[mid] > nums[right]:
            # Minimum is in right half
            left = mid + 1
        else:
            # Minimum is in left half (including mid)
            right = mid

    return left  # Index of minimum element</code></pre>
                </div>

                <h4>Edge Cases to Handle</h4>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Edge Case</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Example</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Why It Matters</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Not rotated</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);"><code>[1,2,3,4,5]</code></td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Array rotated by n positions (full rotation)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Single element</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);"><code>[3]</code></td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Must handle left == right</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Two elements</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);"><code>[2,1]</code></td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Boundary condition testing</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">All duplicates</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);"><code>[1,1,1,1]</code></td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Cannot determine sorted half</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Target at boundary</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">target = 4 in <code>[4,5,6,0,1,2]</code></td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Test &lt;= vs &lt; boundary conditions</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Staff Interview Discussion Points</h4>
                <ul>
                    <li><strong>Follow-up:</strong> "What if we need to find the k-th smallest element?" Answer: Find rotation point, then calculate adjusted index.</li>
                    <li><strong>Follow-up:</strong> "Can we do better than O(n) with duplicates?" Answer: No, adversarial input can force linear scan.</li>
                    <li><strong>System design connection:</strong> Rotated arrays appear in time-series databases with circular buffers.</li>
                </ul>
            </div>
        </div>

        <!-- BST Section -->
        <h2 class="mt-4">Binary Search Trees</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>BST Properties & Validation</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p><strong>BST Property:</strong> For every node, all values in left subtree &lt; node value &lt; all values in right subtree.</p>

                <div class="code-block">
                    <pre><code class="language-python">def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):
    """Validate BST using range checking.
    Time: O(n), Space: O(h) for recursion stack
    """
    if not root:
        return True

    if not (min_val < root.val < max_val):
        return False

    return (is_valid_bst(root.left, min_val, root.val) and
            is_valid_bst(root.right, root.val, max_val))

# Alternative: Inorder traversal should be sorted
def is_valid_bst_inorder(root):
    prev = [float('-inf')]

    def inorder(node):
        if not node:
            return True
        if not inorder(node.left):
            return False
        if node.val <= prev[0]:
            return False
        prev[0] = node.val
        return inorder(node.right)

    return inorder(root)</code></pre>
                </div>
            </div>
        </div>

        <!-- Common Problems -->
        <h2 class="mt-4">Common Tree Problems</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Maximum Depth & Diameter</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def max_depth(root):
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))

def diameter(root):
    """Diameter = longest path between any two nodes."""
    result = [0]

    def depth(node):
        if not node:
            return 0
        left = depth(node.left)
        right = depth(node.right)
        result[0] = max(result[0], left + right)  # Path through node
        return 1 + max(left, right)

    depth(root)
    return result[0]</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Lowest Common Ancestor</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def lowest_common_ancestor(root, p, q):
    """Find LCA of nodes p and q."""
    if not root or root == p or root == q:
        return root

    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)

    if left and right:
        return root  # p and q are on different sides
    return left or right  # Both on same side</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Tree Edge Cases & Advanced Problems (Staff-Level)</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>Critical Edge Cases for Tree Problems</h4>
                <p>Staff engineers are expected to identify and handle these edge cases without prompting:</p>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Edge Case</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Impact</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Solution</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Empty tree (root is None)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">NullPointerException</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Check <code>if not root</code> first</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Single node tree</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Boundary conditions</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Test depth=0 vs depth=1 semantics</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Skewed tree (linked list)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(n) height, stack overflow</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Iterative solution or tail recursion</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Duplicate values in BST</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Ambiguous ordering</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Define convention: left &lt;= root or left &lt; root</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Integer overflow in path sum</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Wrong answer</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Use long/BigInteger for large values</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Negative node values</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Max path sum logic breaks</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Initialize with float('-inf'), not 0</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Advanced Tree Problems for Staff Level</h4>

                <div class="code-block">
                    <pre><code class="language-python"># 1. Construct Tree from Preorder + Inorder
# Key insight: First element of preorder is always root
# Find that in inorder to split left/right subtrees

def build_tree(preorder, inorder):
    """
    Time: O(n), Space: O(n) for hashmap
    Without hashmap: O(n^2) due to index searching
    """
    if not preorder or not inorder:
        return None

    # Hashmap for O(1) index lookup
    inorder_map = {val: idx for idx, val in enumerate(inorder)}

    def build(pre_start, pre_end, in_start, in_end):
        if pre_start > pre_end:
            return None

        root_val = preorder[pre_start]
        root = TreeNode(root_val)

        # Find root in inorder
        in_root_idx = inorder_map[root_val]
        left_size = in_root_idx - in_start

        root.left = build(pre_start + 1, pre_start + left_size,
                          in_start, in_root_idx - 1)
        root.right = build(pre_start + left_size + 1, pre_end,
                           in_root_idx + 1, in_end)

        return root

    return build(0, len(preorder) - 1, 0, len(inorder) - 1)

# 2. Binary Tree Maximum Path Sum
# Path can start and end at any node
# Key insight: At each node, decide whether to extend path or start new

def max_path_sum(root):
    """
    Time: O(n), Space: O(h)
    Handle negative values correctly!
    """
    max_sum = [float('-inf')]  # Use list for closure

    def max_gain(node):
        if not node:
            return 0

        # Max gain from left/right subtrees
        # max(0, ...) to ignore negative paths
        left_gain = max(0, max_gain(node.left))
        right_gain = max(0, max_gain(node.right))

        # Price of path through this node
        path_price = node.val + left_gain + right_gain

        # Update global max
        max_sum[0] = max(max_sum[0], path_price)

        # Return max gain if we continue this path upward
        # Can only go through one child
        return node.val + max(left_gain, right_gain)

    max_gain(root)
    return max_sum[0]

# 3. Flatten Binary Tree to Linked List (In-place)
# Important: Must be done in preorder

def flatten(root):
    """
    Morris-style O(1) space flattening.
    Key: For each node with left child, find rightmost of left subtree,
    connect it to current right, then move left subtree to right.
    """
    current = root

    while current:
        if current.left:
            # Find rightmost node of left subtree
            rightmost = current.left
            while rightmost.right:
                rightmost = rightmost.right

            # Rewire connections
            rightmost.right = current.right
            current.right = current.left
            current.left = None

        current = current.right

# 4. Serialize and Deserialize Binary Tree
# Staff-level: Discuss trade-offs of different approaches

def serialize(root):
    """Preorder with null markers. Time: O(n), Space: O(n)"""
    def helper(node):
        if not node:
            return ['null']
        return [str(node.val)] + helper(node.left) + helper(node.right)

    return ','.join(helper(root))

def deserialize(data):
    """Reconstruct from serialized string"""
    values = iter(data.split(','))

    def helper():
        val = next(values)
        if val == 'null':
            return None
        node = TreeNode(int(val))
        node.left = helper()
        node.right = helper()
        return node

    return helper()</code></pre>
                </div>

                <h4>Staff Interview Follow-ups</h4>
                <ul>
                    <li><strong>Serialization format:</strong> "Why preorder? What about level-order?" Level-order is better for sparse trees, preorder for dense trees.</li>
                    <li><strong>Path sum variants:</strong> "What if path must go through root?" "What if path must start at root?" Each variant has different recursive structure.</li>
                    <li><strong>Construction uniqueness:</strong> "Can you construct tree from preorder + postorder?" Only if all nodes have 0 or 2 children.</li>
                </ul>
            </div>
        </div>

        <!-- Real-World Scale Examples -->
        <h2 class="mt-4">Real-World Scale Examples</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Google/Bing: B-Trees for Search Index Storage</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Google indexes over 130 trillion web pages. Bing processes 12 billion queries per month. Both use B-tree variants (LSM trees, B+ trees) as the foundation of their search indexes.</p>

                <h4>Why B-Trees Over Binary Trees?</h4>
                <ul>
                    <li><strong>Disk I/O optimization:</strong> B-trees have high branching factor (100-1000 children), minimizing disk reads</li>
                    <li><strong>4 levels for 1 billion keys:</strong> With branching factor 1000, 4 disk reads find any key</li>
                    <li><strong>Sequential access:</strong> B+ trees store all values in leaves, enabling range scans</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># B-Tree vs BST: Disk reads for 1 billion keys
import math

def disk_reads_bst(n):
    """Binary tree: ~30 levels for 1B keys."""
    return math.ceil(math.log2(n))

def disk_reads_btree(n, branching_factor=1000):
    """B-tree: ~4 levels for 1B keys."""
    return math.ceil(math.log(n) / math.log(branching_factor))

n = 1_000_000_000  # 1 billion keys
print(f"BST: {disk_reads_bst(n)} disk reads")       # ~30
print(f"B-tree: {disk_reads_btree(n)} disk reads")  # ~4

# At 10ms per disk read:
# BST: 300ms per lookup
# B-tree: 40ms per lookup
# 7.5x faster at scale!</code></pre>
                </div>

                <h4>Google's SSTable + LSM Tree</h4>
                <p>Google's Bigtable (and LevelDB, RocksDB) uses Log-Structured Merge trees - essentially sorted arrays with binary search merged periodically. This optimizes for write-heavy workloads while maintaining O(log n) reads.</p>

                <h4>Staff-Level Deep Dive: B+ Tree vs LSM Tree Trade-offs</h4>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Aspect</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">B+ Tree (MySQL, PostgreSQL)</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">LSM Tree (Cassandra, RocksDB)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Write Pattern</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Random I/O (update in place)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Sequential I/O (append only)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Write Amplification</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Low (1x)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">High (10-30x due to compaction)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Read Amplification</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Low (single tree)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Higher (check multiple levels)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Space Amplification</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Medium (~1.5x)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Variable (1-2x)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Best For</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Read-heavy, OLTP</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Write-heavy, time-series</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
                    <pre><code class="language-python"># LSM Tree Read: Binary search at multiple levels
def lsm_read(key, levels):
    """
    LSM trees maintain sorted runs at different levels.
    Binary search is used at each level.

    Read amplification = number of levels to check
    Bloom filters reduce this significantly.
    """
    # Check memtable (in-memory) first
    if key in memtable:
        return memtable[key]

    # Check each level (L0, L1, L2, ...)
    for level in levels:
        for sstable in level.sstables:
            # Bloom filter: probabilistic "not in set" check
            if not sstable.bloom_filter.might_contain(key):
                continue  # Definitely not in this SSTable

            # Binary search within SSTable
            result = binary_search(sstable, key)
            if result:
                return result

    return None  # Key not found</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>MongoDB: Tree-Based Indexing for Document Queries</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>MongoDB serves over 35,000 customers including Toyota, Cisco, and Adobe. Its WiredTiger storage engine uses B+ trees for all indexes.</p>

                <h4>Compound Index Example</h4>
                <div class="code-block">
                    <pre><code class="language-python"># MongoDB index on (user_id, timestamp)
# Internally: B+ tree where each node is sorted by user_id, then timestamp

# This query uses the index efficiently:
db.events.find({user_id: 123}).sort({timestamp: -1}).limit(10)
# O(log n) to find user_id, then sequential scan of that user's events

# This query CANNOT use the index well:
db.events.find({timestamp: {"$gt": last_week}})
# Index is sorted by user_id first! Must scan all users.

# Key insight: compound index order matters for query patterns</code></pre>
                </div>

                <h4>Binary Search in Query Planning</h4>
                <p>MongoDB's query planner uses binary search to:</p>
                <ul>
                    <li>Find the starting point in an index range scan</li>
                    <li>Estimate result set sizes for query optimization</li>
                    <li>Skip deleted documents efficiently</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Git: Merkle Trees for Version Control</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Git manages the Linux kernel (77 million lines of code, 1 million+ commits). Its efficiency comes from Merkle trees - a tree where each node is a cryptographic hash of its children.</p>

                <h4>How Git Uses Trees</h4>
                <ul>
                    <li><strong>Commit tree:</strong> Each commit points to a tree of file snapshots</li>
                    <li><strong>Diff detection:</strong> Compare tree hashes recursively - O(changed files), not O(all files)</li>
                    <li><strong>Integrity:</strong> Any tampering changes root hash</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># Git's tree comparison is essentially this:
def trees_differ(tree1, tree2):
    """
    O(number of differences) comparison.
    If hashes match, entire subtrees are identical.
    """
    if tree1.hash == tree2.hash:
        return []  # Entire subtree unchanged - prune!

    differences = []

    # Only recurse into children if hashes differ
    for name in set(tree1.children) | set(tree2.children):
        child1 = tree1.children.get(name)
        child2 = tree2.children.get(name)

        if child1 is None:
            differences.append(f"Added: {name}")
        elif child2 is None:
            differences.append(f"Deleted: {name}")
        elif child1.hash != child2.hash:
            differences.extend(trees_differ(child1, child2))

    return differences

# Linux kernel: 77M lines, but most commits change < 100 files
# Tree comparison: O(100) not O(77M)</code></pre>
                </div>
            </div>
        </div>

        <!-- Quiz Section -->
        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Interview Follow-up Questions -->
        <h2 class="mt-4">Interview Follow-up Questions</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Common Follow-ups & What Interviewers Look For</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. "How would you handle a BST that becomes unbalanced?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Self-balancing trees: AVL (strict), Red-Black (relaxed)</li>
                    <li>Trade-offs: AVL faster lookup, Red-Black faster insert/delete</li>
                    <li>Real-world: Java TreeMap uses Red-Black, databases use B-trees</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing that unbalanced BST degrades to O(n).</p>

                <h4>2. "Why use 'left + (right - left) // 2' instead of '(left + right) // 2'?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Integer overflow in languages with fixed-size integers (Java, C++)</li>
                    <li>Python handles big integers, but good practice for portability</li>
                    <li>Alternative: unsigned right shift in Java: (left + right) >>> 1</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing about overflow, or dismissing it as "Python doesn't have that problem."</p>

                <h4>3. "When would you use DFS vs BFS for tree traversal?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>DFS (recursion/stack): Path finding, backtracking, memory-efficient for deep trees</li>
                    <li>BFS (queue): Shortest path, level-order, finding closest nodes</li>
                    <li>Space: DFS O(height), BFS O(width) - matters for wide vs deep trees</li>
                </ul>
                <p><strong>Red flags:</strong> Always defaulting to one without considering the problem structure.</p>

                <h4>4. "Binary search returned -1. How do you find where to insert the element?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Return 'left' pointer - it's the insertion point</li>
                    <li>bisect_left vs bisect_right for duplicates</li>
                    <li>Understanding the invariant: all elements left of 'left' are smaller</li>
                </ul>
                <p><strong>Red flags:</strong> Not understanding that binary search naturally finds insertion point.</p>

                <h4>5. "How would you serialize/deserialize a binary tree?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Preorder traversal with null markers: "1,2,null,null,3,4,null,null,5"</li>
                    <li>Level-order with null markers</li>
                    <li>Discussion of space efficiency and parsing complexity</li>
                </ul>
                <p><strong>Red flags:</strong> Not handling null nodes, or using inefficient representations.</p>
            </div>
        </div>

        <!-- Practice Problems -->
        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Easy (Warm-up)</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/binary-search/" target="_blank">Binary Search (LeetCode #704)</a></li>
                <li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank">Maximum Depth (LeetCode #104)</a></li>
                <li><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank">Invert Binary Tree (LeetCode #226)</a></li>
                <li><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank">Symmetric Tree (LeetCode #101)</a></li>
            </ul>

            <h4 class="mt-3">Medium (Interview Standard)</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank">Validate BST (LeetCode #98)</a></li>
                <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank">Level Order Traversal (LeetCode #102)</a></li>
                <li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank">Lowest Common Ancestor (LeetCode #236)</a></li>
                <li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank">Search in Rotated Sorted Array (LeetCode #33)</a></li>
                <li><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank">Construct Tree from Preorder and Inorder (LeetCode #105)</a></li>
                <li><a href="https://leetcode.com/problems/koko-eating-bananas/" target="_blank">Koko Eating Bananas (LeetCode #875)</a> - Binary Search on Answer</li>
                <li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank">Find Minimum in Rotated Array (LeetCode #153)</a></li>
            </ul>

            <h4 class="mt-3">Hard (Staff-Level Expected)</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank">Binary Tree Maximum Path Sum (LeetCode #124)</a></li>
                <li><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank">Serialize and Deserialize Binary Tree (LeetCode #297)</a></li>
                <li><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank">Median of Two Sorted Arrays (LeetCode #4)</a> - Binary Search Mastery</li>
                <li><a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank">Recover Binary Search Tree (LeetCode #99)</a> - Morris Traversal Application</li>
                <li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank">Search in Rotated Array II (LeetCode #81)</a> - With Duplicates</li>
                <li><a href="https://leetcode.com/problems/binary-tree-cameras/" target="_blank">Binary Tree Cameras (LeetCode #968)</a> - Tree DP</li>
            </ul>

            <h4 class="mt-3">Staff Interview Focus Areas</h4>
            <p style="margin-top: 1rem; color: var(--text-secondary);">For Staff-level interviews, focus on:</p>
            <ul style="color: var(--text-secondary);">
                <li>Being able to implement Morris traversal from scratch</li>
                <li>Handling all edge cases without prompting</li>
                <li>Discussing time-space trade-offs and real-world implications</li>
                <li>Connecting tree/search concepts to database indexing</li>
                <li>Optimizing binary search variations for production use</li>
            </ul>
        </div>

        <!-- Navigation -->
        <div class="flex flex-between mt-4">
            <a href="module-02.html" class="btn btn-secondary">&larr; Module 2</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Sidebar toggle for mobile
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            // Update sidebar links based on completion status
            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('coding', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "What traversal gives sorted order for a BST?",
                    options: ["Preorder", "Inorder", "Postorder", "Level Order"],
                    correct: 1,
                    explanation: "Inorder (Left → Root → Right) visits BST nodes in sorted order."
                },
                {
                    question: "What's the time complexity of binary search?",
                    options: ["O(n)", "O(n log n)", "O(log n)", "O(1)"],
                    correct: 2,
                    explanation: "Binary search halves the search space each iteration, giving O(log n)."
                },
                {
                    question: "In binary search, why use 'left + (right - left) // 2' instead of '(left + right) // 2'?",
                    options: ["It's faster", "Avoids integer overflow", "More readable", "Required by Python"],
                    correct: 1,
                    explanation: "In languages with fixed-size integers, (left + right) can overflow. The alternative avoids this."
                }
            ];

            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 3);
            alert('Module 3 marked as complete!');
            window.location.href = 'module-04.html';
        }
    </script>
</body>
</html>
