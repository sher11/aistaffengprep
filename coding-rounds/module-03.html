<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 3: Trees & Binary Search - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
                <li><a href="../generative-ai/index.html">Gen AI</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Fundamentals</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Foundations
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Arrays & Two Pointers
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Patterns</div>
                    <a href="module-03.html" class="sidebar-link active" data-module="3">
                        <span class="sidebar-link-number">3</span>Trees & Binary Search
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Graphs
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Dynamic Programming
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Advanced</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">6</span>Backtracking
                    </a>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">7</span>Heaps & Sorting
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">8</span>Non-LeetCode Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">9</span>Interview Simulation
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Main Content -->
        <main class="main-content">
        <h1>Module 3: Trees & Binary Search</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Implement all tree traversal methods (pre, in, post, level-order)</li>
                <li>Master binary search variations and boundary finding</li>
                <li>Understand BST properties and operations</li>
                <li>Solve common tree problems recursively and iteratively</li>
            </ul>
        </div>

        <!-- Tree Structure -->
        <h2 class="mt-4">Binary Tree Fundamentals</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Tree Traversals</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <!-- Interactive Tree Traversal Animation -->
                    <style>
                        .tree-animation-container {
                            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
                            border-radius: 16px;
                            padding: 30px;
                            position: relative;
                            overflow: hidden;
                            box-shadow: 0 20px 60px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1);
                        }
                        .tree-animation-container::before {
                            content: '';
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: radial-gradient(circle at 20% 80%, rgba(94, 234, 212, 0.1) 0%, transparent 50%),
                                        radial-gradient(circle at 80% 20%, rgba(168, 85, 247, 0.1) 0%, transparent 50%);
                            pointer-events: none;
                        }
                        .tree-svg-container {
                            position: relative;
                            z-index: 1;
                        }
                        .tree-node {
                            cursor: pointer;
                            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        }
                        .tree-node:hover .node-circle {
                            filter: drop-shadow(0 0 20px rgba(94, 234, 212, 0.8));
                            transform: scale(1.15);
                        }
                        .tree-node:hover .node-text {
                            fill: #fff;
                        }
                        .node-circle {
                            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                            transform-origin: center;
                        }
                        .node-circle.visiting {
                            fill: url(#visitingGradient) !important;
                            filter: drop-shadow(0 0 25px rgba(251, 191, 36, 0.9));
                            animation: pulse-glow 0.6s ease-in-out;
                        }
                        .node-circle.visited {
                            fill: url(#visitedGradient) !important;
                            filter: drop-shadow(0 0 15px rgba(34, 197, 94, 0.7));
                        }
                        @keyframes pulse-glow {
                            0%, 100% { transform: scale(1); }
                            50% { transform: scale(1.2); }
                        }
                        .tree-edge {
                            stroke: rgba(148, 163, 184, 0.4);
                            stroke-width: 3;
                            fill: none;
                            transition: all 0.4s ease;
                        }
                        .tree-edge.active {
                            stroke: url(#edgeGradient);
                            stroke-width: 4;
                            filter: drop-shadow(0 0 8px rgba(94, 234, 212, 0.6));
                        }
                        .tree-controls {
                            display: flex;
                            justify-content: center;
                            gap: 12px;
                            margin-top: 25px;
                            flex-wrap: wrap;
                            position: relative;
                            z-index: 1;
                        }
                        .tree-btn {
                            padding: 12px 24px;
                            border: none;
                            border-radius: 12px;
                            font-weight: 600;
                            font-size: 14px;
                            cursor: pointer;
                            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                            position: relative;
                            overflow: hidden;
                        }
                        .tree-btn::before {
                            content: '';
                            position: absolute;
                            top: 0;
                            left: -100%;
                            width: 100%;
                            height: 100%;
                            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
                            transition: left 0.5s;
                        }
                        .tree-btn:hover::before {
                            left: 100%;
                        }
                        .tree-btn-preorder {
                            background: linear-gradient(135deg, #8b5cf6, #a855f7);
                            color: white;
                            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
                        }
                        .tree-btn-preorder:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.5);
                        }
                        .tree-btn-inorder {
                            background: linear-gradient(135deg, #06b6d4, #0891b2);
                            color: white;
                            box-shadow: 0 4px 15px rgba(6, 182, 212, 0.4);
                        }
                        .tree-btn-inorder:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(6, 182, 212, 0.5);
                        }
                        .tree-btn-postorder {
                            background: linear-gradient(135deg, #f59e0b, #d97706);
                            color: white;
                            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
                        }
                        .tree-btn-postorder:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.5);
                        }
                        .tree-btn-levelorder {
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
                        }
                        .tree-btn-levelorder:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.5);
                        }
                        .tree-btn-reset {
                            background: linear-gradient(135deg, #64748b, #475569);
                            color: white;
                            box-shadow: 0 4px 15px rgba(100, 116, 139, 0.4);
                        }
                        .tree-btn-reset:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 8px 25px rgba(100, 116, 139, 0.5);
                        }
                        .tree-btn:disabled {
                            opacity: 0.5;
                            cursor: not-allowed;
                            transform: none !important;
                        }
                        .traversal-output {
                            margin-top: 20px;
                            padding: 20px;
                            background: rgba(0, 0, 0, 0.3);
                            border-radius: 12px;
                            font-family: 'Fira Code', 'Monaco', monospace;
                            font-size: 18px;
                            text-align: center;
                            color: #e2e8f0;
                            min-height: 30px;
                            border: 1px solid rgba(148, 163, 184, 0.2);
                            position: relative;
                            z-index: 1;
                        }
                        .traversal-output .step-label {
                            display: block;
                            font-size: 12px;
                            color: #94a3b8;
                            margin-bottom: 8px;
                            text-transform: uppercase;
                            letter-spacing: 1px;
                        }
                        .traversal-output .values {
                            display: flex;
                            justify-content: center;
                            gap: 8px;
                            flex-wrap: wrap;
                        }
                        .traversal-output .value-item {
                            background: linear-gradient(135deg, #3b82f6, #2563eb);
                            padding: 8px 16px;
                            border-radius: 8px;
                            animation: pop-in 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
                        }
                        @keyframes pop-in {
                            0% { transform: scale(0); opacity: 0; }
                            100% { transform: scale(1); opacity: 1; }
                        }
                        .speed-control {
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            gap: 15px;
                            margin-top: 15px;
                            color: #94a3b8;
                            font-size: 14px;
                            position: relative;
                            z-index: 1;
                        }
                        .speed-control input[type="range"] {
                            width: 120px;
                            accent-color: #8b5cf6;
                        }
                    </style>
                    <div class="tree-animation-container" id="treeAnimationContainer">
                        <svg width="100%" height="280" viewBox="0 0 500 280" class="tree-svg-container">
                            <defs>
                                <linearGradient id="nodeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#3b82f6"/>
                                    <stop offset="100%" style="stop-color:#1d4ed8"/>
                                </linearGradient>
                                <linearGradient id="visitingGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#fbbf24"/>
                                    <stop offset="100%" style="stop-color:#f59e0b"/>
                                </linearGradient>
                                <linearGradient id="visitedGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#22c55e"/>
                                    <stop offset="100%" style="stop-color:#16a34a"/>
                                </linearGradient>
                                <linearGradient id="edgeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#5eead4"/>
                                    <stop offset="100%" style="stop-color:#2dd4bf"/>
                                </linearGradient>
                                <filter id="glow">
                                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                                    <feMerge>
                                        <feMergeNode in="coloredBlur"/>
                                        <feMergeNode in="SourceGraphic"/>
                                    </feMerge>
                                </filter>
                            </defs>
                            <!-- Edges -->
                            <path class="tree-edge" id="edge-1-2" d="M250,50 Q175,90 125,110"/>
                            <path class="tree-edge" id="edge-1-3" d="M250,50 Q325,90 375,110"/>
                            <path class="tree-edge" id="edge-2-4" d="M125,130 Q90,165 75,190"/>
                            <path class="tree-edge" id="edge-2-5" d="M125,130 Q160,165 175,190"/>
                            <path class="tree-edge" id="edge-3-6" d="M375,130 Q340,165 325,190"/>
                            <path class="tree-edge" id="edge-3-7" d="M375,130 Q410,165 425,190"/>
                            <!-- Nodes -->
                            <g class="tree-node" id="node-1" data-value="1">
                                <circle class="node-circle" cx="250" cy="40" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="250" y="46" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">1</text>
                            </g>
                            <g class="tree-node" id="node-2" data-value="2">
                                <circle class="node-circle" cx="125" cy="120" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="125" y="126" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">2</text>
                            </g>
                            <g class="tree-node" id="node-3" data-value="3">
                                <circle class="node-circle" cx="375" cy="120" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="375" y="126" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">3</text>
                            </g>
                            <g class="tree-node" id="node-4" data-value="4">
                                <circle class="node-circle" cx="75" cy="210" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="75" y="216" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">4</text>
                            </g>
                            <g class="tree-node" id="node-5" data-value="5">
                                <circle class="node-circle" cx="175" cy="210" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="175" y="216" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">5</text>
                            </g>
                            <g class="tree-node" id="node-6" data-value="6">
                                <circle class="node-circle" cx="325" cy="210" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="325" y="216" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">6</text>
                            </g>
                            <g class="tree-node" id="node-7" data-value="7">
                                <circle class="node-circle" cx="425" cy="210" r="28" fill="url(#nodeGradient)" filter="url(#glow)"/>
                                <text class="node-text" x="425" y="216" text-anchor="middle" fill="#e2e8f0" font-size="18" font-weight="bold">7</text>
                            </g>
                        </svg>
                        <div class="tree-controls">
                            <button class="tree-btn tree-btn-preorder" onclick="runTraversal('preorder')">Preorder</button>
                            <button class="tree-btn tree-btn-inorder" onclick="runTraversal('inorder')">Inorder</button>
                            <button class="tree-btn tree-btn-postorder" onclick="runTraversal('postorder')">Postorder</button>
                            <button class="tree-btn tree-btn-levelorder" onclick="runTraversal('levelorder')">Level Order</button>
                            <button class="tree-btn tree-btn-reset" onclick="resetTree()">Reset</button>
                        </div>
                        <div class="speed-control">
                            <label>Speed:</label>
                            <input type="range" id="traversalSpeed" min="200" max="1500" value="700" step="100">
                            <span id="speedLabel">Medium</span>
                        </div>
                        <div class="traversal-output" id="traversalOutput">
                            <span class="step-label">Click a traversal button to begin</span>
                            <div class="values" id="outputValues"></div>
                        </div>
                    </div>
                    <script>
                        (function() {
                            const tree = {
                                1: { left: 2, right: 3 },
                                2: { left: 4, right: 5 },
                                3: { left: 6, right: 7 },
                                4: { left: null, right: null },
                                5: { left: null, right: null },
                                6: { left: null, right: null },
                                7: { left: null, right: null }
                            };

                            let isAnimating = false;
                            let animationSpeed = 700;

                            const speedSlider = document.getElementById('traversalSpeed');
                            const speedLabel = document.getElementById('speedLabel');

                            speedSlider.addEventListener('input', function() {
                                animationSpeed = parseInt(this.value);
                                const labels = { 200: 'Very Fast', 400: 'Fast', 700: 'Medium', 1000: 'Slow', 1500: 'Very Slow' };
                                speedLabel.textContent = labels[animationSpeed] || 'Medium';
                            });

                            function getTraversalOrder(type, nodeId = 1) {
                                if (!nodeId) return [];
                                const node = tree[nodeId];
                                switch(type) {
                                    case 'preorder':
                                        return [nodeId, ...getTraversalOrder(type, node.left), ...getTraversalOrder(type, node.right)];
                                    case 'inorder':
                                        return [...getTraversalOrder(type, node.left), nodeId, ...getTraversalOrder(type, node.right)];
                                    case 'postorder':
                                        return [...getTraversalOrder(type, node.left), ...getTraversalOrder(type, node.right), nodeId];
                                    case 'levelorder':
                                        return [1, 2, 3, 4, 5, 6, 7];
                                    default:
                                        return [];
                                }
                            }

                            function getEdgeId(from, to) {
                                return `edge-${from}-${to}`;
                            }

                            window.runTraversal = async function(type) {
                                if (isAnimating) return;
                                isAnimating = true;

                                document.querySelectorAll('.tree-btn').forEach(btn => btn.disabled = true);
                                resetTree();

                                const order = getTraversalOrder(type);
                                const outputEl = document.getElementById('traversalOutput');
                                const valuesEl = document.getElementById('outputValues');

                                const typeLabels = {
                                    preorder: 'Preorder: Root -> Left -> Right',
                                    inorder: 'Inorder: Left -> Root -> Right',
                                    postorder: 'Postorder: Left -> Right -> Root',
                                    levelorder: 'Level Order: BFS by level'
                                };

                                outputEl.querySelector('.step-label').textContent = typeLabels[type];
                                valuesEl.innerHTML = '';

                                for (let i = 0; i < order.length; i++) {
                                    const nodeId = order[i];
                                    const nodeEl = document.getElementById(`node-${nodeId}`);
                                    const circle = nodeEl.querySelector('.node-circle');

                                    // Mark as visiting
                                    circle.classList.add('visiting');

                                    // Highlight edge from parent
                                    if (nodeId !== 1) {
                                        const parent = nodeId <= 3 ? 1 : (nodeId <= 5 ? 2 : 3);
                                        const edgeEl = document.getElementById(getEdgeId(parent, nodeId));
                                        if (edgeEl) edgeEl.classList.add('active');
                                    }

                                    await new Promise(r => setTimeout(r, animationSpeed));

                                    // Mark as visited
                                    circle.classList.remove('visiting');
                                    circle.classList.add('visited');

                                    // Add to output
                                    const valueSpan = document.createElement('span');
                                    valueSpan.className = 'value-item';
                                    valueSpan.textContent = nodeId;
                                    valuesEl.appendChild(valueSpan);

                                    await new Promise(r => setTimeout(r, animationSpeed / 2));
                                }

                                isAnimating = false;
                                document.querySelectorAll('.tree-btn').forEach(btn => btn.disabled = false);
                            };

                            window.resetTree = function() {
                                document.querySelectorAll('.node-circle').forEach(circle => {
                                    circle.classList.remove('visiting', 'visited');
                                });
                                document.querySelectorAll('.tree-edge').forEach(edge => {
                                    edge.classList.remove('active');
                                });
                                const outputEl = document.getElementById('traversalOutput');
                                outputEl.querySelector('.step-label').textContent = 'Click a traversal button to begin';
                                document.getElementById('outputValues').innerHTML = '';
                            };
                        })();
                    </script>
                </div>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Traversal</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Order</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Result</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Preorder</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Root → Left → Right</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">1, 2, 4, 5, 3, 6, 7</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Inorder</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Left → Root → Right</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">4, 2, 5, 1, 6, 3, 7</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Postorder</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Left → Right → Root</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">4, 5, 2, 6, 7, 3, 1</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Level Order</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">BFS by level</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">1, 2, 3, 4, 5, 6, 7</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
                    <pre><code class="language-python"># Recursive Traversals
def preorder(root):
    if not root: return []
    return [root.val] + preorder(root.left) + preorder(root.right)

def inorder(root):
    if not root: return []
    return inorder(root.left) + [root.val] + inorder(root.right)

def postorder(root):
    if not root: return []
    return postorder(root.left) + postorder(root.right) + [root.val]

# Iterative Inorder (most common)
def inorder_iterative(root):
    result, stack = [], []
    current = root

    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        current = stack.pop()
        result.append(current.val)
        current = current.right

    return result

# Level Order (BFS)
from collections import deque

def level_order(root):
    if not root: return []
    result, queue = [], deque([root])

    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        result.append(level)

    return result</code></pre>
                </div>
            </div>
        </div>

        <!-- Binary Search Section -->
        <h2 class="mt-4">Binary Search</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Standard Binary Search</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <div class="mermaid">
flowchart LR
    A["[1, 3, 5, 7, 9, 11, 13]"] --> B{arr[mid] vs target}
    B -->|"< target"| C["Search right half"]
    B -->|"= target"| D["Found!"]
    B -->|"> target"| E["Search left half"]
                    </div>
                </div>

                <div class="code-block">
                    <pre><code class="language-python">def binary_search(arr, target):
    """Standard binary search for exact match.
    Time: O(log n), Space: O(1)
    """
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Avoid overflow

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1  # Not found</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Finding Boundaries</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python"># Find leftmost (first) position of target
def find_left_boundary(arr, target):
    left, right = 0, len(arr)

    while left < right:
        mid = left + (right - left) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid

    return left  # First index where arr[i] >= target

# Find rightmost (last) position of target
def find_right_boundary(arr, target):
    left, right = 0, len(arr)

    while left < right:
        mid = left + (right - left) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid

    return left - 1  # Last index where arr[i] <= target

# Find first and last position of element
def search_range(arr, target):
    left = find_left_boundary(arr, target)

    if left >= len(arr) or arr[left] != target:
        return [-1, -1]

    right = find_right_boundary(arr, target)
    return [left, right]</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Binary Search on Answer</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>When the answer itself has a monotonic property, binary search on the answer space.</p>

                <div class="code-block">
                    <pre><code class="language-python"># Example: Koko Eating Bananas
# Find minimum eating speed to finish within h hours

def min_eating_speed(piles, h):
    def can_finish(speed):
        hours = sum((pile + speed - 1) // speed for pile in piles)
        return hours <= h

    left, right = 1, max(piles)

    while left < right:
        mid = left + (right - left) // 2
        if can_finish(mid):
            right = mid  # Try slower speed
        else:
            left = mid + 1  # Need faster speed

    return left</code></pre>
                </div>
            </div>
        </div>

        <!-- BST Section -->
        <h2 class="mt-4">Binary Search Trees</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>BST Properties & Validation</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p><strong>BST Property:</strong> For every node, all values in left subtree &lt; node value &lt; all values in right subtree.</p>

                <div class="code-block">
                    <pre><code class="language-python">def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):
    """Validate BST using range checking.
    Time: O(n), Space: O(h) for recursion stack
    """
    if not root:
        return True

    if not (min_val < root.val < max_val):
        return False

    return (is_valid_bst(root.left, min_val, root.val) and
            is_valid_bst(root.right, root.val, max_val))

# Alternative: Inorder traversal should be sorted
def is_valid_bst_inorder(root):
    prev = [float('-inf')]

    def inorder(node):
        if not node:
            return True
        if not inorder(node.left):
            return False
        if node.val <= prev[0]:
            return False
        prev[0] = node.val
        return inorder(node.right)

    return inorder(root)</code></pre>
                </div>
            </div>
        </div>

        <!-- Common Problems -->
        <h2 class="mt-4">Common Tree Problems</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Maximum Depth & Diameter</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def max_depth(root):
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))

def diameter(root):
    """Diameter = longest path between any two nodes."""
    result = [0]

    def depth(node):
        if not node:
            return 0
        left = depth(node.left)
        right = depth(node.right)
        result[0] = max(result[0], left + right)  # Path through node
        return 1 + max(left, right)

    depth(root)
    return result[0]</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Lowest Common Ancestor</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def lowest_common_ancestor(root, p, q):
    """Find LCA of nodes p and q."""
    if not root or root == p or root == q:
        return root

    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)

    if left and right:
        return root  # p and q are on different sides
    return left or right  # Both on same side</code></pre>
                </div>
            </div>
        </div>

        <!-- Real-World Scale Examples -->
        <h2 class="mt-4">Real-World Scale Examples</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Google/Bing: B-Trees for Search Index Storage</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Google indexes over 130 trillion web pages. Bing processes 12 billion queries per month. Both use B-tree variants (LSM trees, B+ trees) as the foundation of their search indexes.</p>

                <h4>Why B-Trees Over Binary Trees?</h4>
                <ul>
                    <li><strong>Disk I/O optimization:</strong> B-trees have high branching factor (100-1000 children), minimizing disk reads</li>
                    <li><strong>4 levels for 1 billion keys:</strong> With branching factor 1000, 4 disk reads find any key</li>
                    <li><strong>Sequential access:</strong> B+ trees store all values in leaves, enabling range scans</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># B-Tree vs BST: Disk reads for 1 billion keys
import math

def disk_reads_bst(n):
    """Binary tree: ~30 levels for 1B keys."""
    return math.ceil(math.log2(n))

def disk_reads_btree(n, branching_factor=1000):
    """B-tree: ~4 levels for 1B keys."""
    return math.ceil(math.log(n) / math.log(branching_factor))

n = 1_000_000_000  # 1 billion keys
print(f"BST: {disk_reads_bst(n)} disk reads")       # ~30
print(f"B-tree: {disk_reads_btree(n)} disk reads")  # ~4

# At 10ms per disk read:
# BST: 300ms per lookup
# B-tree: 40ms per lookup
# 7.5x faster at scale!</code></pre>
                </div>

                <h4>Google's SSTable + LSM Tree</h4>
                <p>Google's Bigtable (and LevelDB, RocksDB) uses Log-Structured Merge trees - essentially sorted arrays with binary search merged periodically. This optimizes for write-heavy workloads while maintaining O(log n) reads.</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>MongoDB: Tree-Based Indexing for Document Queries</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>MongoDB serves over 35,000 customers including Toyota, Cisco, and Adobe. Its WiredTiger storage engine uses B+ trees for all indexes.</p>

                <h4>Compound Index Example</h4>
                <div class="code-block">
                    <pre><code class="language-python"># MongoDB index on (user_id, timestamp)
# Internally: B+ tree where each node is sorted by user_id, then timestamp

# This query uses the index efficiently:
db.events.find({user_id: 123}).sort({timestamp: -1}).limit(10)
# O(log n) to find user_id, then sequential scan of that user's events

# This query CANNOT use the index well:
db.events.find({timestamp: {"$gt": last_week}})
# Index is sorted by user_id first! Must scan all users.

# Key insight: compound index order matters for query patterns</code></pre>
                </div>

                <h4>Binary Search in Query Planning</h4>
                <p>MongoDB's query planner uses binary search to:</p>
                <ul>
                    <li>Find the starting point in an index range scan</li>
                    <li>Estimate result set sizes for query optimization</li>
                    <li>Skip deleted documents efficiently</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Git: Merkle Trees for Version Control</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Git manages the Linux kernel (77 million lines of code, 1 million+ commits). Its efficiency comes from Merkle trees - a tree where each node is a cryptographic hash of its children.</p>

                <h4>How Git Uses Trees</h4>
                <ul>
                    <li><strong>Commit tree:</strong> Each commit points to a tree of file snapshots</li>
                    <li><strong>Diff detection:</strong> Compare tree hashes recursively - O(changed files), not O(all files)</li>
                    <li><strong>Integrity:</strong> Any tampering changes root hash</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># Git's tree comparison is essentially this:
def trees_differ(tree1, tree2):
    """
    O(number of differences) comparison.
    If hashes match, entire subtrees are identical.
    """
    if tree1.hash == tree2.hash:
        return []  # Entire subtree unchanged - prune!

    differences = []

    # Only recurse into children if hashes differ
    for name in set(tree1.children) | set(tree2.children):
        child1 = tree1.children.get(name)
        child2 = tree2.children.get(name)

        if child1 is None:
            differences.append(f"Added: {name}")
        elif child2 is None:
            differences.append(f"Deleted: {name}")
        elif child1.hash != child2.hash:
            differences.extend(trees_differ(child1, child2))

    return differences

# Linux kernel: 77M lines, but most commits change < 100 files
# Tree comparison: O(100) not O(77M)</code></pre>
                </div>
            </div>
        </div>

        <!-- Quiz Section -->
        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Interview Follow-up Questions -->
        <h2 class="mt-4">Interview Follow-up Questions</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Common Follow-ups & What Interviewers Look For</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. "How would you handle a BST that becomes unbalanced?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Self-balancing trees: AVL (strict), Red-Black (relaxed)</li>
                    <li>Trade-offs: AVL faster lookup, Red-Black faster insert/delete</li>
                    <li>Real-world: Java TreeMap uses Red-Black, databases use B-trees</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing that unbalanced BST degrades to O(n).</p>

                <h4>2. "Why use 'left + (right - left) // 2' instead of '(left + right) // 2'?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Integer overflow in languages with fixed-size integers (Java, C++)</li>
                    <li>Python handles big integers, but good practice for portability</li>
                    <li>Alternative: unsigned right shift in Java: (left + right) >>> 1</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing about overflow, or dismissing it as "Python doesn't have that problem."</p>

                <h4>3. "When would you use DFS vs BFS for tree traversal?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>DFS (recursion/stack): Path finding, backtracking, memory-efficient for deep trees</li>
                    <li>BFS (queue): Shortest path, level-order, finding closest nodes</li>
                    <li>Space: DFS O(height), BFS O(width) - matters for wide vs deep trees</li>
                </ul>
                <p><strong>Red flags:</strong> Always defaulting to one without considering the problem structure.</p>

                <h4>4. "Binary search returned -1. How do you find where to insert the element?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Return 'left' pointer - it's the insertion point</li>
                    <li>bisect_left vs bisect_right for duplicates</li>
                    <li>Understanding the invariant: all elements left of 'left' are smaller</li>
                </ul>
                <p><strong>Red flags:</strong> Not understanding that binary search naturally finds insertion point.</p>

                <h4>5. "How would you serialize/deserialize a binary tree?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Preorder traversal with null markers: "1,2,null,null,3,4,null,null,5"</li>
                    <li>Level-order with null markers</li>
                    <li>Discussion of space efficiency and parsing complexity</li>
                </ul>
                <p><strong>Red flags:</strong> Not handling null nodes, or using inefficient representations.</p>
            </div>
        </div>

        <!-- Practice Problems -->
        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Easy</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/binary-search/" target="_blank">Binary Search (LeetCode #704)</a></li>
                <li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank">Maximum Depth (LeetCode #104)</a></li>
                <li><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank">Invert Binary Tree (LeetCode #226)</a></li>
            </ul>

            <h4 class="mt-3">Medium</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank">Validate BST (LeetCode #98)</a></li>
                <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank">Level Order Traversal (LeetCode #102)</a></li>
                <li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank">Lowest Common Ancestor (LeetCode #236)</a></li>
            </ul>
        </div>

        <!-- Navigation -->
        <div class="flex flex-between mt-4">
            <a href="module-02.html" class="btn btn-secondary">&larr; Module 2</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Sidebar toggle for mobile
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            // Update sidebar links based on completion status
            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('coding', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "What traversal gives sorted order for a BST?",
                    options: ["Preorder", "Inorder", "Postorder", "Level Order"],
                    correct: 1,
                    explanation: "Inorder (Left → Root → Right) visits BST nodes in sorted order."
                },
                {
                    question: "What's the time complexity of binary search?",
                    options: ["O(n)", "O(n log n)", "O(log n)", "O(1)"],
                    correct: 2,
                    explanation: "Binary search halves the search space each iteration, giving O(log n)."
                },
                {
                    question: "In binary search, why use 'left + (right - left) // 2' instead of '(left + right) // 2'?",
                    options: ["It's faster", "Avoids integer overflow", "More readable", "Required by Python"],
                    correct: 1,
                    explanation: "In languages with fixed-size integers, (left + right) can overflow. The alternative avoids this."
                }
            ];

            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 3);
            alert('Module 3 marked as complete!');
            window.location.href = 'module-04.html';
        }
    </script>
</body>
</html>
