<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 3: Trees & Binary Search - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Fundamentals</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Foundations
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Arrays & Two Pointers
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Patterns</div>
                    <a href="module-03.html" class="sidebar-link active" data-module="3">
                        <span class="sidebar-link-number">3</span>Trees & Binary Search
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Graphs
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Dynamic Programming
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Advanced</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">6</span>Backtracking
                    </a>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">7</span>Heaps & Sorting
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">8</span>Non-LeetCode Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">9</span>Interview Simulation
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Main Content -->
        <main class="main-content">
        <h1>Module 3: Trees & Binary Search</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Implement all tree traversal methods (pre, in, post, level-order)</li>
                <li>Master binary search variations and boundary finding</li>
                <li>Understand BST properties and operations</li>
                <li>Solve common tree problems recursively and iteratively</li>
            </ul>
        </div>

        <!-- Tree Structure -->
        <h2 class="mt-4">Binary Tree Fundamentals</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Tree Traversals</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <div class="mermaid">
graph TD
    A((1)) --> B((2))
    A --> C((3))
    B --> D((4))
    B --> E((5))
    C --> F((6))
    C --> G((7))
                    </div>
                </div>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Traversal</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Order</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Result</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Preorder</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Root → Left → Right</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">1, 2, 4, 5, 3, 6, 7</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Inorder</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Left → Root → Right</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">4, 2, 5, 1, 6, 3, 7</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Postorder</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Left → Right → Root</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">4, 5, 2, 6, 7, 3, 1</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Level Order</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">BFS by level</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">1, 2, 3, 4, 5, 6, 7</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
                    <pre><code># Recursive Traversals
def preorder(root):
    if not root: return []
    return [root.val] + preorder(root.left) + preorder(root.right)

def inorder(root):
    if not root: return []
    return inorder(root.left) + [root.val] + inorder(root.right)

def postorder(root):
    if not root: return []
    return postorder(root.left) + postorder(root.right) + [root.val]

# Iterative Inorder (most common)
def inorder_iterative(root):
    result, stack = [], []
    current = root

    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        current = stack.pop()
        result.append(current.val)
        current = current.right

    return result

# Level Order (BFS)
from collections import deque

def level_order(root):
    if not root: return []
    result, queue = [], deque([root])

    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        result.append(level)

    return result</code></pre>
                </div>
            </div>
        </div>

        <!-- Binary Search Section -->
        <h2 class="mt-4">Binary Search</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Standard Binary Search</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <div class="mermaid">
flowchart LR
    A["[1, 3, 5, 7, 9, 11, 13]"] --> B{arr[mid] vs target}
    B -->|"< target"| C["Search right half"]
    B -->|"= target"| D["Found!"]
    B -->|"> target"| E["Search left half"]
                    </div>
                </div>

                <div class="code-block">
                    <pre><code>def binary_search(arr, target):
    """Standard binary search for exact match.
    Time: O(log n), Space: O(1)
    """
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Avoid overflow

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1  # Not found</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Finding Boundaries</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code># Find leftmost (first) position of target
def find_left_boundary(arr, target):
    left, right = 0, len(arr)

    while left < right:
        mid = left + (right - left) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid

    return left  # First index where arr[i] >= target

# Find rightmost (last) position of target
def find_right_boundary(arr, target):
    left, right = 0, len(arr)

    while left < right:
        mid = left + (right - left) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid

    return left - 1  # Last index where arr[i] <= target

# Find first and last position of element
def search_range(arr, target):
    left = find_left_boundary(arr, target)

    if left >= len(arr) or arr[left] != target:
        return [-1, -1]

    right = find_right_boundary(arr, target)
    return [left, right]</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Binary Search on Answer</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>When the answer itself has a monotonic property, binary search on the answer space.</p>

                <div class="code-block">
                    <pre><code># Example: Koko Eating Bananas
# Find minimum eating speed to finish within h hours

def min_eating_speed(piles, h):
    def can_finish(speed):
        hours = sum((pile + speed - 1) // speed for pile in piles)
        return hours <= h

    left, right = 1, max(piles)

    while left < right:
        mid = left + (right - left) // 2
        if can_finish(mid):
            right = mid  # Try slower speed
        else:
            left = mid + 1  # Need faster speed

    return left</code></pre>
                </div>
            </div>
        </div>

        <!-- BST Section -->
        <h2 class="mt-4">Binary Search Trees</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>BST Properties & Validation</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p><strong>BST Property:</strong> For every node, all values in left subtree &lt; node value &lt; all values in right subtree.</p>

                <div class="code-block">
                    <pre><code>def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):
    """Validate BST using range checking.
    Time: O(n), Space: O(h) for recursion stack
    """
    if not root:
        return True

    if not (min_val < root.val < max_val):
        return False

    return (is_valid_bst(root.left, min_val, root.val) and
            is_valid_bst(root.right, root.val, max_val))

# Alternative: Inorder traversal should be sorted
def is_valid_bst_inorder(root):
    prev = [float('-inf')]

    def inorder(node):
        if not node:
            return True
        if not inorder(node.left):
            return False
        if node.val <= prev[0]:
            return False
        prev[0] = node.val
        return inorder(node.right)

    return inorder(root)</code></pre>
                </div>
            </div>
        </div>

        <!-- Common Problems -->
        <h2 class="mt-4">Common Tree Problems</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Maximum Depth & Diameter</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>def max_depth(root):
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))

def diameter(root):
    """Diameter = longest path between any two nodes."""
    result = [0]

    def depth(node):
        if not node:
            return 0
        left = depth(node.left)
        right = depth(node.right)
        result[0] = max(result[0], left + right)  # Path through node
        return 1 + max(left, right)

    depth(root)
    return result[0]</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Lowest Common Ancestor</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>def lowest_common_ancestor(root, p, q):
    """Find LCA of nodes p and q."""
    if not root or root == p or root == q:
        return root

    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)

    if left and right:
        return root  # p and q are on different sides
    return left or right  # Both on same side</code></pre>
                </div>
            </div>
        </div>

        <!-- Real-World Scale Examples -->
        <h2 class="mt-4">Real-World Scale Examples</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Google/Bing: B-Trees for Search Index Storage</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Google indexes over 130 trillion web pages. Bing processes 12 billion queries per month. Both use B-tree variants (LSM trees, B+ trees) as the foundation of their search indexes.</p>

                <h4>Why B-Trees Over Binary Trees?</h4>
                <ul>
                    <li><strong>Disk I/O optimization:</strong> B-trees have high branching factor (100-1000 children), minimizing disk reads</li>
                    <li><strong>4 levels for 1 billion keys:</strong> With branching factor 1000, 4 disk reads find any key</li>
                    <li><strong>Sequential access:</strong> B+ trees store all values in leaves, enabling range scans</li>
                </ul>

                <div class="code-block">
                    <pre><code># B-Tree vs BST: Disk reads for 1 billion keys
import math

def disk_reads_bst(n):
    """Binary tree: ~30 levels for 1B keys."""
    return math.ceil(math.log2(n))

def disk_reads_btree(n, branching_factor=1000):
    """B-tree: ~4 levels for 1B keys."""
    return math.ceil(math.log(n) / math.log(branching_factor))

n = 1_000_000_000  # 1 billion keys
print(f"BST: {disk_reads_bst(n)} disk reads")       # ~30
print(f"B-tree: {disk_reads_btree(n)} disk reads")  # ~4

# At 10ms per disk read:
# BST: 300ms per lookup
# B-tree: 40ms per lookup
# 7.5x faster at scale!</code></pre>
                </div>

                <h4>Google's SSTable + LSM Tree</h4>
                <p>Google's Bigtable (and LevelDB, RocksDB) uses Log-Structured Merge trees - essentially sorted arrays with binary search merged periodically. This optimizes for write-heavy workloads while maintaining O(log n) reads.</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>MongoDB: Tree-Based Indexing for Document Queries</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>MongoDB serves over 35,000 customers including Toyota, Cisco, and Adobe. Its WiredTiger storage engine uses B+ trees for all indexes.</p>

                <h4>Compound Index Example</h4>
                <div class="code-block">
                    <pre><code># MongoDB index on (user_id, timestamp)
# Internally: B+ tree where each node is sorted by user_id, then timestamp

# This query uses the index efficiently:
db.events.find({user_id: 123}).sort({timestamp: -1}).limit(10)
# O(log n) to find user_id, then sequential scan of that user's events

# This query CANNOT use the index well:
db.events.find({timestamp: {"$gt": last_week}})
# Index is sorted by user_id first! Must scan all users.

# Key insight: compound index order matters for query patterns</code></pre>
                </div>

                <h4>Binary Search in Query Planning</h4>
                <p>MongoDB's query planner uses binary search to:</p>
                <ul>
                    <li>Find the starting point in an index range scan</li>
                    <li>Estimate result set sizes for query optimization</li>
                    <li>Skip deleted documents efficiently</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Git: Merkle Trees for Version Control</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Git manages the Linux kernel (77 million lines of code, 1 million+ commits). Its efficiency comes from Merkle trees - a tree where each node is a cryptographic hash of its children.</p>

                <h4>How Git Uses Trees</h4>
                <ul>
                    <li><strong>Commit tree:</strong> Each commit points to a tree of file snapshots</li>
                    <li><strong>Diff detection:</strong> Compare tree hashes recursively - O(changed files), not O(all files)</li>
                    <li><strong>Integrity:</strong> Any tampering changes root hash</li>
                </ul>

                <div class="code-block">
                    <pre><code># Git's tree comparison is essentially this:
def trees_differ(tree1, tree2):
    """
    O(number of differences) comparison.
    If hashes match, entire subtrees are identical.
    """
    if tree1.hash == tree2.hash:
        return []  # Entire subtree unchanged - prune!

    differences = []

    # Only recurse into children if hashes differ
    for name in set(tree1.children) | set(tree2.children):
        child1 = tree1.children.get(name)
        child2 = tree2.children.get(name)

        if child1 is None:
            differences.append(f"Added: {name}")
        elif child2 is None:
            differences.append(f"Deleted: {name}")
        elif child1.hash != child2.hash:
            differences.extend(trees_differ(child1, child2))

    return differences

# Linux kernel: 77M lines, but most commits change < 100 files
# Tree comparison: O(100) not O(77M)</code></pre>
                </div>
            </div>
        </div>

        <!-- Quiz Section -->
        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Interview Follow-up Questions -->
        <h2 class="mt-4">Interview Follow-up Questions</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Common Follow-ups & What Interviewers Look For</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. "How would you handle a BST that becomes unbalanced?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Self-balancing trees: AVL (strict), Red-Black (relaxed)</li>
                    <li>Trade-offs: AVL faster lookup, Red-Black faster insert/delete</li>
                    <li>Real-world: Java TreeMap uses Red-Black, databases use B-trees</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing that unbalanced BST degrades to O(n).</p>

                <h4>2. "Why use 'left + (right - left) // 2' instead of '(left + right) // 2'?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Integer overflow in languages with fixed-size integers (Java, C++)</li>
                    <li>Python handles big integers, but good practice for portability</li>
                    <li>Alternative: unsigned right shift in Java: (left + right) >>> 1</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing about overflow, or dismissing it as "Python doesn't have that problem."</p>

                <h4>3. "When would you use DFS vs BFS for tree traversal?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>DFS (recursion/stack): Path finding, backtracking, memory-efficient for deep trees</li>
                    <li>BFS (queue): Shortest path, level-order, finding closest nodes</li>
                    <li>Space: DFS O(height), BFS O(width) - matters for wide vs deep trees</li>
                </ul>
                <p><strong>Red flags:</strong> Always defaulting to one without considering the problem structure.</p>

                <h4>4. "Binary search returned -1. How do you find where to insert the element?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Return 'left' pointer - it's the insertion point</li>
                    <li>bisect_left vs bisect_right for duplicates</li>
                    <li>Understanding the invariant: all elements left of 'left' are smaller</li>
                </ul>
                <p><strong>Red flags:</strong> Not understanding that binary search naturally finds insertion point.</p>

                <h4>5. "How would you serialize/deserialize a binary tree?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Preorder traversal with null markers: "1,2,null,null,3,4,null,null,5"</li>
                    <li>Level-order with null markers</li>
                    <li>Discussion of space efficiency and parsing complexity</li>
                </ul>
                <p><strong>Red flags:</strong> Not handling null nodes, or using inefficient representations.</p>
            </div>
        </div>

        <!-- Practice Problems -->
        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Easy</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/binary-search/" target="_blank">Binary Search (LeetCode #704)</a></li>
                <li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank">Maximum Depth (LeetCode #104)</a></li>
                <li><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank">Invert Binary Tree (LeetCode #226)</a></li>
            </ul>

            <h4 class="mt-3">Medium</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank">Validate BST (LeetCode #98)</a></li>
                <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank">Level Order Traversal (LeetCode #102)</a></li>
                <li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank">Lowest Common Ancestor (LeetCode #236)</a></li>
            </ul>
        </div>

        <!-- Navigation -->
        <div class="flex flex-between mt-4">
            <a href="module-02.html" class="btn btn-secondary">&larr; Module 2</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Sidebar toggle for mobile
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            // Update sidebar links based on completion status
            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('coding', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "What traversal gives sorted order for a BST?",
                    options: ["Preorder", "Inorder", "Postorder", "Level Order"],
                    correct: 1,
                    explanation: "Inorder (Left → Root → Right) visits BST nodes in sorted order."
                },
                {
                    question: "What's the time complexity of binary search?",
                    options: ["O(n)", "O(n log n)", "O(log n)", "O(1)"],
                    correct: 2,
                    explanation: "Binary search halves the search space each iteration, giving O(log n)."
                },
                {
                    question: "In binary search, why use 'left + (right - left) // 2' instead of '(left + right) // 2'?",
                    options: ["It's faster", "Avoids integer overflow", "More readable", "Required by Python"],
                    correct: 1,
                    explanation: "In languages with fixed-size integers, (left + right) can overflow. The alternative avoids this."
                }
            ];

            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 3);
            alert('Module 3 marked as complete!');
            window.location.href = 'module-04.html';
        }
    </script>
</body>
</html>
