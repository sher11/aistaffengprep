<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 4: Graphs - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Fundamentals</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Foundations
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Arrays & Two Pointers
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Patterns</div>
                    <a href="module-03.html" class="sidebar-link" data-module="3">
                        <span class="sidebar-link-number">3</span>Trees & Binary Search
                    </a>
                    <a href="module-04.html" class="sidebar-link active" data-module="4">
                        <span class="sidebar-link-number">4</span>Graphs
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Dynamic Programming
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Advanced</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">6</span>Backtracking
                    </a>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">7</span>Heaps & Sorting
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">8</span>Non-LeetCode Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">9</span>Interview Simulation
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Main Content -->
        <main class="main-content">
        <h1>Module 4: Graphs & Advanced Traversal</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Represent graphs using adjacency list and matrix</li>
                <li>Implement DFS and BFS for graph problems</li>
                <li>Apply topological sort for dependency ordering</li>
                <li>Use Union-Find for connected components</li>
            </ul>
        </div>

        <!-- Graph Representations -->
        <h2 class="mt-4">Graph Representations</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Adjacency List vs Matrix</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <div class="mermaid">
graph LR
    0((0)) --- 1((1))
    0 --- 2((2))
    1 --- 3((3))
    2 --- 3
                    </div>
                </div>

                <div class="code-block">
                    <pre><code># Adjacency List (most common)
graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2]
}

# Adjacency Matrix
matrix = [
    [0, 1, 1, 0],  # Node 0
    [1, 0, 0, 1],  # Node 1
    [1, 0, 0, 1],  # Node 2
    [0, 1, 1, 0]   # Node 3
]

# Building from edges
def build_graph(edges, directed=False):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        if not directed:
            graph[v].append(u)
    return graph</code></pre>
                </div>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Operation</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Adjacency List</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Adjacency Matrix</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Space</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(V + E)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(V²)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Check edge exists</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(degree)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(1)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Get neighbors</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(1)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(V)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- DFS Section -->
        <h2 class="mt-4">Depth-First Search (DFS)</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>DFS Implementation</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code># Recursive DFS
def dfs_recursive(graph, node, visited=None):
    if visited is None:
        visited = set()

    visited.add(node)
    print(node)  # Process node

    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)

# Iterative DFS (with stack)
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]

    while stack:
        node = stack.pop()
        if node in visited:
            continue

        visited.add(node)
        print(node)  # Process node

        for neighbor in graph[node]:
            if neighbor not in visited:
                stack.append(neighbor)

# Number of Islands (classic DFS problem)
def num_islands(grid):
    if not grid:
        return 0

    rows, cols = len(grid), len(grid[0])
    count = 0

    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != '1':
            return
        grid[r][c] = '0'  # Mark visited
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                dfs(r, c)
                count += 1

    return count</code></pre>
                </div>
            </div>
        </div>

        <!-- BFS Section -->
        <h2 class="mt-4">Breadth-First Search (BFS)</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>BFS for Shortest Path</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>from collections import deque

def bfs(graph, start):
    visited = {start}
    queue = deque([start])

    while queue:
        node = queue.popleft()
        print(node)  # Process node

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# Shortest path in unweighted graph
def shortest_path(graph, start, end):
    if start == end:
        return [start]

    visited = {start}
    queue = deque([(start, [start])])

    while queue:
        node, path = queue.popleft()

        for neighbor in graph[node]:
            if neighbor == end:
                return path + [neighbor]
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))

    return []  # No path found</code></pre>
                </div>

                <h4>When to Use</h4>
                <ul>
                    <li><strong>DFS:</strong> Path finding, cycle detection, topological sort, exhaustive search</li>
                    <li><strong>BFS:</strong> Shortest path (unweighted), level-order, nearest neighbor</li>
                </ul>
            </div>
        </div>

        <!-- Topological Sort -->
        <h2 class="mt-4">Topological Sort</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Kahn's Algorithm (BFS-based)</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>from collections import deque

def topological_sort(num_nodes, edges):
    """
    Returns topological ordering or empty list if cycle exists.
    Used for: Course scheduling, build systems, dependency resolution
    """
    # Build graph and count in-degrees
    graph = defaultdict(list)
    in_degree = [0] * num_nodes

    for u, v in edges:  # u -> v (u must come before v)
        graph[u].append(v)
        in_degree[v] += 1

    # Start with nodes that have no prerequisites
    queue = deque([i for i in range(num_nodes) if in_degree[i] == 0])
    result = []

    while queue:
        node = queue.popleft()
        result.append(node)

        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    # If result doesn't contain all nodes, there's a cycle
    return result if len(result) == num_nodes else []

# Course Schedule: Can finish all courses?
def can_finish(num_courses, prerequisites):
    return len(topological_sort(num_courses, prerequisites)) == num_courses</code></pre>
                </div>
            </div>
        </div>

        <!-- Union-Find -->
        <h2 class="mt-4">Union-Find (Disjoint Set)</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Implementation with Optimizations</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>class UnionFind:
    """
    Union-Find with path compression and union by rank.
    Time: O(α(n)) ≈ O(1) per operation
    """
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.components = n

    def find(self, x):
        """Find root with path compression."""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        """Union by rank. Returns True if merged, False if already connected."""
        px, py = self.find(x), self.find(y)

        if px == py:
            return False

        # Attach smaller tree to larger tree
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px

        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1

        self.components -= 1
        return True

    def connected(self, x, y):
        return self.find(x) == self.find(y)

# Number of Connected Components
def count_components(n, edges):
    uf = UnionFind(n)
    for u, v in edges:
        uf.union(u, v)
    return uf.components</code></pre>
                </div>

                <h4>Use Cases</h4>
                <ul>
                    <li>Connected components in undirected graph</li>
                    <li>Cycle detection</li>
                    <li>Kruskal's MST algorithm</li>
                    <li>Network connectivity</li>
                </ul>
            </div>
        </div>

        <!-- Real-World Scale Examples -->
        <h2 class="mt-4">Real-World Scale Examples</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>LinkedIn: Graph Algorithms at 900M+ Users</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>LinkedIn's social graph has 900+ million members and 60+ million companies. Their graph infrastructure processes trillions of edges for features like "People You May Know" and connection path finding.</p>

                <h4>The "2nd Degree Connection" Problem</h4>
                <ul>
                    <li><strong>Scale:</strong> Average user has 500 connections, each has 500 more</li>
                    <li><strong>Challenge:</strong> Finding mutual connections = BFS to depth 2</li>
                    <li><strong>Solution:</strong> Pre-compute and cache 2nd-degree neighborhoods</li>
                </ul>

                <div class="code-block">
                    <pre><code># LinkedIn-style "People You May Know" simplified
from collections import defaultdict

class SocialGraph:
    """
    LinkedIn processes 300M+ API calls/day for connection queries.
    Key insight: pre-compute what you query frequently.
    """
    def __init__(self):
        self.connections = defaultdict(set)  # user -> set of connections
        self.second_degree_cache = {}  # Pre-computed for active users

    def add_connection(self, user_a, user_b):
        self.connections[user_a].add(user_b)
        self.connections[user_b].add(user_a)
        # Invalidate cache for both users
        self.second_degree_cache.pop(user_a, None)
        self.second_degree_cache.pop(user_b, None)

    def get_second_degree(self, user):
        """
        BFS to depth 2. LinkedIn caches this for active users.
        Without caching: O(connections * avg_connections) per request.
        """
        if user in self.second_degree_cache:
            return self.second_degree_cache[user]

        first_degree = self.connections[user]
        second_degree = set()

        for friend in first_degree:
            for friend_of_friend in self.connections[friend]:
                if friend_of_friend != user and friend_of_friend not in first_degree:
                    second_degree.add(friend_of_friend)

        self.second_degree_cache[user] = second_degree
        return second_degree

    def people_you_may_know(self, user, limit=10):
        """
        Rank 2nd-degree connections by mutual connection count.
        LinkedIn uses ML models on top of this base signal.
        """
        second_degree = self.get_second_degree(user)
        first_degree = self.connections[user]

        # Count mutual connections
        scores = {}
        for candidate in second_degree:
            mutual = len(self.connections[candidate] & first_degree)
            scores[candidate] = mutual

        # Return top candidates by mutual connections
        ranked = sorted(scores.items(), key=lambda x: -x[1])
        return [user for user, score in ranked[:limit]]</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Google Maps: Shortest Path at Global Scale</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Google Maps serves over 1 billion users, processing 1 billion kilometers of directions daily. The road network graph has billions of nodes (intersections) and edges (road segments).</p>

                <h4>Why Not Just Dijkstra?</h4>
                <ul>
                    <li><strong>Problem:</strong> Dijkstra explores in all directions until finding destination</li>
                    <li><strong>At scale:</strong> NYC to LA would explore entire US road network</li>
                    <li><strong>Solution:</strong> Hierarchical graphs + precomputation</li>
                </ul>

                <div class="code-block">
                    <pre><code># Simplified Contraction Hierarchies (used by Google Maps, OSRM)
import heapq

class ContractionHierarchies:
    """
    Preprocess graph to enable bidirectional search on "important" nodes only.
    Preprocessing: O(n log n) time, O(n) space
    Query: O(log n) average, vs O(n) for Dijkstra
    """
    def __init__(self, graph):
        self.graph = graph
        self.importance = {}  # Node importance ranking
        self.shortcuts = defaultdict(list)  # Added shortcut edges

    def preprocess(self):
        """
        Contract nodes in order of importance.
        Add shortcuts to preserve shortest paths.
        Google does this offline - takes hours for continent-scale.
        """
        # Simplified: importance = degree (real algorithm more complex)
        nodes = sorted(self.graph.keys(),
                      key=lambda n: len(self.graph[n]))

        for i, node in enumerate(nodes):
            self.importance[node] = i
            self._contract_node(node)

    def _contract_node(self, node):
        """Add shortcuts between neighbors if node is on shortest path."""
        neighbors = list(self.graph[node])
        for u in neighbors:
            for v in neighbors:
                if u != v:
                    # Check if shortest u->v goes through node
                    uv_through_node = (
                        self._edge_weight(u, node) +
                        self._edge_weight(node, v)
                    )
                    direct_uv = self._edge_weight(u, v)

                    if uv_through_node < direct_uv:
                        # Add shortcut
                        self.shortcuts[u].append((v, uv_through_node))

    def query(self, source, target):
        """
        Bidirectional Dijkstra, but only explore "upward" in hierarchy.
        Dramatically reduces search space.
        """
        # Forward search from source (upward in importance)
        forward_dist = {source: 0}
        forward_heap = [(0, source)]

        # Backward search from target (upward in importance)
        backward_dist = {target: 0}
        backward_heap = [(0, target)]

        best_dist = float('inf')

        while forward_heap or backward_heap:
            # Alternate between forward and backward
            # Only explore nodes with higher importance
            # Meet in the middle at high-importance "hub" nodes
            pass  # Full implementation omitted for brevity

        return best_dist

# Result: NYC to LA query in milliseconds, not minutes</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Facebook: Graph Partitioning for Social Feed</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Facebook's social graph has 3 billion users and trillions of edges. Storing this on a single machine is impossible. Graph partitioning determines which users are stored together.</p>

                <h4>The Challenge</h4>
                <ul>
                    <li><strong>Goal:</strong> Minimize cross-machine queries when loading a user's feed</li>
                    <li><strong>Constraint:</strong> Balanced partition sizes for even load distribution</li>
                    <li><strong>This is NP-hard:</strong> Facebook uses approximation algorithms</li>
                </ul>

                <div class="code-block">
                    <pre><code># Simplified graph partitioning (real version uses METIS, Pregel)
class GraphPartitioner:
    """
    Assign users to servers to minimize cross-server edges.
    Facebook re-partitions periodically as friendships change.
    """
    def __init__(self, graph, num_partitions):
        self.graph = graph
        self.num_partitions = num_partitions
        self.assignment = {}  # node -> partition

    def partition_balanced(self):
        """
        Greedy balanced partitioning.
        Assign each node to partition with most existing friends.
        """
        partition_sizes = [0] * self.num_partitions
        max_size = len(self.graph) // self.num_partitions + 1

        for node in self.graph:
            # Count friends in each partition
            friend_counts = [0] * self.num_partitions
            for friend in self.graph[node]:
                if friend in self.assignment:
                    friend_counts[self.assignment[friend]] += 1

            # Assign to partition with most friends (if not full)
            for p in sorted(range(self.num_partitions),
                          key=lambda x: -friend_counts[x]):
                if partition_sizes[p] < max_size:
                    self.assignment[node] = p
                    partition_sizes[p] += 1
                    break

    def edge_cut_ratio(self):
        """Measure partitioning quality: % of edges crossing partitions."""
        cross_edges = 0
        total_edges = 0

        for node in self.graph:
            for neighbor in self.graph[node]:
                total_edges += 1
                if self.assignment[node] != self.assignment[neighbor]:
                    cross_edges += 1

        return cross_edges / total_edges if total_edges else 0

# Facebook achieves ~10% edge cut - 90% of friend data is local!</code></pre>
                </div>
            </div>
        </div>

        <!-- Quiz Section -->
        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Interview Follow-up Questions -->
        <h2 class="mt-4">Interview Follow-up Questions</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Common Follow-ups & What Interviewers Look For</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. "How would you detect a cycle in a directed vs undirected graph?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Undirected: DFS with parent tracking, or Union-Find</li>
                    <li>Directed: DFS with 3 colors (white/gray/black) or topological sort</li>
                    <li>Why the difference: back edge to parent is not a cycle in undirected graphs</li>
                </ul>
                <p><strong>Red flags:</strong> Using the same algorithm for both, not understanding edge classification.</p>

                <h4>2. "When would you use adjacency matrix vs adjacency list?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Matrix: Dense graphs, O(1) edge lookup needed, small graphs</li>
                    <li>List: Sparse graphs (most real-world graphs), memory efficiency</li>
                    <li>Real numbers: Social network with 1M users has 1M nodes but avg 500 edges each</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing space complexity: O(V^2) vs O(V+E).</p>

                <h4>3. "How would you handle negative edge weights?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Dijkstra fails with negative edges</li>
                    <li>Bellman-Ford: O(VE), handles negative weights, detects negative cycles</li>
                    <li>Real use case: arbitrage detection in currency exchange</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing Dijkstra's limitation.</p>

                <h4>4. "How does Union-Find achieve near O(1) operations?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Path compression: flatten tree on find()</li>
                    <li>Union by rank: attach smaller tree under larger</li>
                    <li>Combined: O(alpha(n)) - inverse Ackermann, practically O(1)</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing both optimizations are needed together.</p>

                <h4>5. "How would you find shortest path in a graph with billions of nodes?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Precomputation: Contraction Hierarchies, ALT, Hub Labeling</li>
                    <li>Partitioning: Divide graph into regions, precompute boundary distances</li>
                    <li>Trade-off: preprocessing time vs query time</li>
                </ul>
                <p><strong>Red flags:</strong> Only knowing Dijkstra/BFS without discussing scale.</p>
            </div>
        </div>

        <!-- Practice Problems -->
        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Medium</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/number-of-islands/" target="_blank">Number of Islands (LeetCode #200)</a></li>
                <li><a href="https://leetcode.com/problems/course-schedule/" target="_blank">Course Schedule (LeetCode #207)</a></li>
                <li><a href="https://leetcode.com/problems/clone-graph/" target="_blank">Clone Graph (LeetCode #133)</a></li>
                <li><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/" target="_blank">Connected Components (LeetCode #323)</a></li>
            </ul>

            <h4 class="mt-3">Hard</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/word-ladder/" target="_blank">Word Ladder (LeetCode #127)</a></li>
                <li><a href="https://leetcode.com/problems/alien-dictionary/" target="_blank">Alien Dictionary (LeetCode #269)</a></li>
            </ul>
        </div>

        <!-- Navigation -->
        <div class="flex flex-between mt-4">
            <a href="module-03.html" class="btn btn-secondary">&larr; Module 3</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Sidebar toggle for mobile
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            // Update sidebar links based on completion status
            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('coding', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "Which algorithm finds shortest path in an unweighted graph?",
                    options: ["DFS", "BFS", "Topological Sort", "Union-Find"],
                    correct: 1,
                    explanation: "BFS explores nodes level by level, guaranteeing shortest path in unweighted graphs."
                },
                {
                    question: "What does topological sort require?",
                    options: ["Weighted edges", "Directed Acyclic Graph (DAG)", "Connected graph", "Undirected graph"],
                    correct: 1,
                    explanation: "Topological sort only works on DAGs - cycles make ordering impossible."
                },
                {
                    question: "What's the time complexity of Union-Find operations with optimizations?",
                    options: ["O(n)", "O(log n)", "O(1) amortized", "O(n²)"],
                    correct: 2,
                    explanation: "With path compression and union by rank, operations are nearly O(1) - technically O(α(n))."
                }
            ];

            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 4);
            alert('Module 4 marked as complete!');
            window.location.href = 'module-05.html';
        }
    </script>
</body>
</html>
