<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 4: Graphs - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
                <li><a href="../generative-ai/index.html">Gen AI</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Fundamentals</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Foundations
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Arrays & Two Pointers
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Patterns</div>
                    <a href="module-03.html" class="sidebar-link" data-module="3">
                        <span class="sidebar-link-number">3</span>Trees & Binary Search
                    </a>
                    <a href="module-04.html" class="sidebar-link active" data-module="4">
                        <span class="sidebar-link-number">4</span>Graphs
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Dynamic Programming
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Advanced</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">6</span>Backtracking
                    </a>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">7</span>Heaps & Sorting
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">8</span>Non-LeetCode Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">9</span>Interview Simulation
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Main Content -->
        <main class="main-content">
        <h1>Module 4: Graphs & Advanced Traversal</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Represent graphs using adjacency list and matrix</li>
                <li>Implement DFS and BFS for graph problems</li>
                <li>Apply topological sort for dependency ordering</li>
                <li>Use Union-Find for connected components</li>
            </ul>
        </div>

        <!-- Graph Representations -->
        <h2 class="mt-4">Graph Representations</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Adjacency List vs Matrix</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <!-- Interactive Graph Representation Animation -->
                    <div id="graph-representation-viz" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 24px; min-height: 320px; position: relative; overflow: hidden;">
                        <style>
                            #graph-representation-viz {
                                font-family: 'Segoe UI', system-ui, sans-serif;
                            }
                            .graph-rep-node {
                                position: absolute;
                                width: 56px;
                                height: 56px;
                                border-radius: 50%;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-weight: bold;
                                font-size: 20px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), 0 0 30px rgba(99, 102, 241, 0.2);
                                z-index: 10;
                            }
                            .graph-rep-node:hover {
                                transform: scale(1.15);
                                box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4), 0 0 40px rgba(99, 102, 241, 0.4);
                            }
                            .graph-rep-node.highlighted {
                                animation: pulse-glow 1s ease-in-out infinite;
                            }
                            @keyframes pulse-glow {
                                0%, 100% { box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), 0 0 30px rgba(16, 185, 129, 0.3); }
                                50% { box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4), 0 0 50px rgba(16, 185, 129, 0.6); }
                            }
                            .graph-rep-controls {
                                display: flex;
                                gap: 10px;
                                margin-bottom: 16px;
                                flex-wrap: wrap;
                            }
                            .graph-rep-btn {
                                padding: 8px 16px;
                                border: none;
                                border-radius: 8px;
                                cursor: pointer;
                                font-weight: 600;
                                font-size: 13px;
                                transition: all 0.2s ease;
                            }
                            .graph-rep-btn-primary {
                                background: linear-gradient(135deg, #6366f1, #8b5cf6);
                                color: white;
                            }
                            .graph-rep-btn-primary:hover {
                                transform: translateY(-2px);
                                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
                            }
                            .graph-rep-btn-secondary {
                                background: rgba(255, 255, 255, 0.1);
                                color: white;
                                border: 1px solid rgba(255, 255, 255, 0.2);
                            }
                            .graph-rep-btn-secondary:hover {
                                background: rgba(255, 255, 255, 0.2);
                            }
                            .graph-rep-btn.active {
                                background: linear-gradient(135deg, #10b981, #34d399);
                            }
                            .graph-rep-info {
                                position: absolute;
                                bottom: 16px;
                                left: 16px;
                                right: 16px;
                                background: rgba(0, 0, 0, 0.6);
                                backdrop-filter: blur(10px);
                                border-radius: 8px;
                                padding: 12px 16px;
                                color: white;
                                font-size: 14px;
                                transition: all 0.3s ease;
                            }
                            .graph-rep-canvas {
                                position: relative;
                                height: 180px;
                                margin-top: 8px;
                            }
                            @media (prefers-reduced-motion: reduce) {
                                .graph-rep-node { transition: none; }
                                .graph-rep-node.highlighted { animation: none; }
                            }
                        </style>

                        <div class="graph-rep-controls">
                            <button class="graph-rep-btn graph-rep-btn-primary" onclick="animateGraphBuilding()">&#9658; Animate Building</button>
                            <button class="graph-rep-btn graph-rep-btn-secondary" onclick="highlightNode(0)">Highlight Node 0</button>
                            <button class="graph-rep-btn graph-rep-btn-secondary" onclick="highlightNeighbors(0)">Show Neighbors of 0</button>
                            <button class="graph-rep-btn graph-rep-btn-secondary" onclick="resetGraphHighlights()">Reset</button>
                        </div>

                        <div class="graph-rep-canvas" id="graph-rep-canvas">
                            <!-- Edges will be drawn here -->
                            <svg id="graph-rep-svg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5;">
                                <defs>
                                    <linearGradient id="edge-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                        <stop offset="0%" style="stop-color:#6366f1" />
                                        <stop offset="100%" style="stop-color:#8b5cf6" />
                                    </linearGradient>
                                    <linearGradient id="edge-gradient-active" x1="0%" y1="0%" x2="100%" y2="0%">
                                        <stop offset="0%" style="stop-color:#10b981" />
                                        <stop offset="100%" style="stop-color:#34d399" />
                                    </linearGradient>
                                </defs>
                            </svg>
                            <!-- Nodes -->
                            <div class="graph-rep-node" id="grn-0" style="left: 50px; top: 60px; background: linear-gradient(135deg, #ef4444, #f97316);" onclick="highlightNode(0)">0</div>
                            <div class="graph-rep-node" id="grn-1" style="left: 160px; top: 20px; background: linear-gradient(135deg, #3b82f6, #6366f1);" onclick="highlightNode(1)">1</div>
                            <div class="graph-rep-node" id="grn-2" style="left: 160px; top: 100px; background: linear-gradient(135deg, #10b981, #14b8a6);" onclick="highlightNode(2)">2</div>
                            <div class="graph-rep-node" id="grn-3" style="left: 280px; top: 60px; background: linear-gradient(135deg, #f59e0b, #eab308);" onclick="highlightNode(3)">3</div>
                        </div>

                        <div class="graph-rep-info" id="graph-rep-info">
                            <strong>Interactive Graph:</strong> Click on nodes to highlight them. This undirected graph has 4 nodes and 4 edges. Each edge connects two nodes bidirectionally.
                        </div>
                    </div>

                    <script>
                        (function() {
                            const graphNodes = {
                                0: { x: 78, y: 88 },
                                1: { x: 188, y: 48 },
                                2: { x: 188, y: 128 },
                                3: { x: 308, y: 88 }
                            };
                            const graphEdges = [[0, 1], [0, 2], [1, 3], [2, 3]];
                            const adjacencyList = {
                                0: [1, 2],
                                1: [0, 3],
                                2: [0, 3],
                                3: [1, 2]
                            };

                            function drawEdges() {
                                const svg = document.getElementById('graph-rep-svg');
                                if (!svg) return;
                                svg.innerHTML = svg.innerHTML.split('</defs>')[0] + '</defs>';

                                graphEdges.forEach(([a, b], idx) => {
                                    const x1 = graphNodes[a].x;
                                    const y1 = graphNodes[a].y;
                                    const x2 = graphNodes[b].x;
                                    const y2 = graphNodes[b].y;

                                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                    line.setAttribute('x1', x1);
                                    line.setAttribute('y1', y1);
                                    line.setAttribute('x2', x2);
                                    line.setAttribute('y2', y2);
                                    line.setAttribute('stroke', 'url(#edge-gradient)');
                                    line.setAttribute('stroke-width', '3');
                                    line.setAttribute('stroke-linecap', 'round');
                                    line.setAttribute('id', `gre-${a}-${b}`);
                                    line.style.transition = 'all 0.3s ease';
                                    svg.appendChild(line);
                                });
                            }

                            window.highlightNode = function(nodeId) {
                                resetGraphHighlights();
                                const node = document.getElementById(`grn-${nodeId}`);
                                if (node) {
                                    node.classList.add('highlighted');
                                }
                                document.getElementById('graph-rep-info').innerHTML =
                                    `<strong>Node ${nodeId}:</strong> Connected to nodes [${adjacencyList[nodeId].join(', ')}]. In adjacency list: graph[${nodeId}] = [${adjacencyList[nodeId].join(', ')}]`;
                            };

                            window.highlightNeighbors = function(nodeId) {
                                resetGraphHighlights();
                                const node = document.getElementById(`grn-${nodeId}`);
                                if (node) node.classList.add('highlighted');

                                adjacencyList[nodeId].forEach(neighbor => {
                                    const neighborNode = document.getElementById(`grn-${neighbor}`);
                                    if (neighborNode) neighborNode.classList.add('highlighted');

                                    // Highlight edges
                                    const edge1 = document.getElementById(`gre-${nodeId}-${neighbor}`);
                                    const edge2 = document.getElementById(`gre-${neighbor}-${nodeId}`);
                                    if (edge1) {
                                        edge1.setAttribute('stroke', 'url(#edge-gradient-active)');
                                        edge1.setAttribute('stroke-width', '5');
                                    }
                                    if (edge2) {
                                        edge2.setAttribute('stroke', 'url(#edge-gradient-active)');
                                        edge2.setAttribute('stroke-width', '5');
                                    }
                                });

                                document.getElementById('graph-rep-info').innerHTML =
                                    `<strong>Neighbors of ${nodeId}:</strong> Nodes ${adjacencyList[nodeId].join(' and ')} are directly connected to node ${nodeId}. This takes O(1) to access with adjacency list!`;
                            };

                            window.resetGraphHighlights = function() {
                                document.querySelectorAll('.graph-rep-node').forEach(n => n.classList.remove('highlighted'));
                                document.querySelectorAll('#graph-rep-svg line').forEach(e => {
                                    e.setAttribute('stroke', 'url(#edge-gradient)');
                                    e.setAttribute('stroke-width', '3');
                                });
                                document.getElementById('graph-rep-info').innerHTML =
                                    '<strong>Interactive Graph:</strong> Click on nodes to highlight them. This undirected graph has 4 nodes and 4 edges.';
                            };

                            window.animateGraphBuilding = function() {
                                // Hide all nodes and edges first
                                document.querySelectorAll('.graph-rep-node').forEach(n => {
                                    n.style.opacity = '0';
                                    n.style.transform = 'scale(0)';
                                });
                                document.querySelectorAll('#graph-rep-svg line').forEach(e => {
                                    e.style.opacity = '0';
                                });

                                const info = document.getElementById('graph-rep-info');

                                // Animate nodes appearing
                                [0, 1, 2, 3].forEach((nodeId, idx) => {
                                    setTimeout(() => {
                                        const node = document.getElementById(`grn-${nodeId}`);
                                        if (node) {
                                            node.style.opacity = '1';
                                            node.style.transform = 'scale(1)';
                                        }
                                        info.innerHTML = `<strong>Building Graph:</strong> Adding node ${nodeId}...`;
                                    }, idx * 400);
                                });

                                // Animate edges appearing
                                graphEdges.forEach(([a, b], idx) => {
                                    setTimeout(() => {
                                        const edge = document.getElementById(`gre-${a}-${b}`);
                                        if (edge) edge.style.opacity = '1';
                                        info.innerHTML = `<strong>Building Graph:</strong> Adding edge ${a} -- ${b}...`;
                                    }, 1600 + idx * 400);
                                });

                                // Final message
                                setTimeout(() => {
                                    info.innerHTML = '<strong>Graph Complete!</strong> 4 nodes, 4 edges. This undirected graph uses O(V + E) = O(8) space with adjacency list.';
                                }, 1600 + graphEdges.length * 400 + 200);
                            };

                            // Initialize on load
                            if (document.readyState === 'loading') {
                                document.addEventListener('DOMContentLoaded', drawEdges);
                            } else {
                                drawEdges();
                            }
                        })();
                    </script>
                </div>

                <div class="code-block">
                    <pre><code class="language-python"># Adjacency List (most common)
graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2]
}

# Adjacency Matrix
matrix = [
    [0, 1, 1, 0],  # Node 0
    [1, 0, 0, 1],  # Node 1
    [1, 0, 0, 1],  # Node 2
    [0, 1, 1, 0]   # Node 3
]

# Building from edges
def build_graph(edges, directed=False):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        if not directed:
            graph[v].append(u)
    return graph</code></pre>
                </div>

                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Operation</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Adjacency List</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Adjacency Matrix</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Space</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(V + E)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(V²)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Check edge exists</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(degree)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(1)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Get neighbors</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(1)</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(V)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Interactive BFS vs DFS Visualization -->
        <h2 class="mt-4">Interactive: BFS vs DFS Visualization</h2>

        <div class="interactive-demo">
            <h4>Watch BFS and DFS in Action</h4>
            <p class="text-muted">See the difference between breadth-first and depth-first traversal on the same graph.</p>

            <div class="viz-controls">
                <button id="graph-bfs" class="active">BFS</button>
                <button id="graph-dfs">DFS</button>
                <button id="graph-play">&#9658; Play</button>
                <button id="graph-step">Step</button>
                <button id="graph-reset">Reset</button>
            </div>

            <div style="display: flex; gap: 2rem; flex-wrap: wrap; margin-top: 1rem;">
                <div id="graph-viz" style="flex: 1; min-width: 300px; min-height: 250px; background: var(--card-bg); border-radius: 0.5rem; padding: 1rem;"></div>
                <div style="flex: 1; min-width: 200px;">
                    <div class="card">
                        <h5>Traversal Order</h5>
                        <div id="traversal-order" style="font-family: monospace; min-height: 30px;"></div>
                    </div>
                    <div class="card mt-2">
                        <h5>Queue/Stack</h5>
                        <div id="traversal-queue" style="font-family: monospace; min-height: 30px;"></div>
                    </div>
                </div>
            </div>

            <div id="graph-explanation" class="callout callout-info mt-2">
                <p><strong>BFS</strong> explores neighbors first (level by level), using a <strong>queue</strong>.</p>
                <p><strong>DFS</strong> explores as deep as possible first, using a <strong>stack</strong> (or recursion).</p>
            </div>
        </div>

        <!-- DFS Section -->
        <h2 class="mt-4">Depth-First Search (DFS)</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>DFS Implementation</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python"># Recursive DFS
def dfs_recursive(graph, node, visited=None):
    if visited is None:
        visited = set()

    visited.add(node)
    print(node)  # Process node

    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)

# Iterative DFS (with stack)
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]

    while stack:
        node = stack.pop()
        if node in visited:
            continue

        visited.add(node)
        print(node)  # Process node

        for neighbor in graph[node]:
            if neighbor not in visited:
                stack.append(neighbor)

# Number of Islands (classic DFS problem)
def num_islands(grid):
    if not grid:
        return 0

    rows, cols = len(grid), len(grid[0])
    count = 0

    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != '1':
            return
        grid[r][c] = '0'  # Mark visited
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                dfs(r, c)
                count += 1

    return count</code></pre>
                </div>
            </div>
        </div>

        <!-- BFS Section -->
        <h2 class="mt-4">Breadth-First Search (BFS)</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>BFS for Shortest Path</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">from collections import deque

def bfs(graph, start):
    visited = {start}
    queue = deque([start])

    while queue:
        node = queue.popleft()
        print(node)  # Process node

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# Shortest path in unweighted graph
def shortest_path(graph, start, end):
    if start == end:
        return [start]

    visited = {start}
    queue = deque([(start, [start])])

    while queue:
        node, path = queue.popleft()

        for neighbor in graph[node]:
            if neighbor == end:
                return path + [neighbor]
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))

    return []  # No path found</code></pre>
                </div>

                <h4>When to Use</h4>
                <ul>
                    <li><strong>DFS:</strong> Path finding, cycle detection, topological sort, exhaustive search</li>
                    <li><strong>BFS:</strong> Shortest path (unweighted), level-order, nearest neighbor</li>
                </ul>
            </div>
        </div>

        <!-- Topological Sort -->
        <h2 class="mt-4">Topological Sort</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Kahn's Algorithm (BFS-based)</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">from collections import deque

def topological_sort(num_nodes, edges):
    """
    Returns topological ordering or empty list if cycle exists.
    Used for: Course scheduling, build systems, dependency resolution
    """
    # Build graph and count in-degrees
    graph = defaultdict(list)
    in_degree = [0] * num_nodes

    for u, v in edges:  # u -> v (u must come before v)
        graph[u].append(v)
        in_degree[v] += 1

    # Start with nodes that have no prerequisites
    queue = deque([i for i in range(num_nodes) if in_degree[i] == 0])
    result = []

    while queue:
        node = queue.popleft()
        result.append(node)

        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    # If result doesn't contain all nodes, there's a cycle
    return result if len(result) == num_nodes else []

# Course Schedule: Can finish all courses?
def can_finish(num_courses, prerequisites):
    return len(topological_sort(num_courses, prerequisites)) == num_courses</code></pre>
                </div>
            </div>
        </div>

        <!-- Union-Find -->
        <h2 class="mt-4">Union-Find (Disjoint Set)</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Implementation with Optimizations</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">class UnionFind:
    """
    Union-Find with path compression and union by rank.
    Time: O(α(n)) ≈ O(1) per operation
    """
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.components = n

    def find(self, x):
        """Find root with path compression."""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        """Union by rank. Returns True if merged, False if already connected."""
        px, py = self.find(x), self.find(y)

        if px == py:
            return False

        # Attach smaller tree to larger tree
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px

        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1

        self.components -= 1
        return True

    def connected(self, x, y):
        return self.find(x) == self.find(y)

# Number of Connected Components
def count_components(n, edges):
    uf = UnionFind(n)
    for u, v in edges:
        uf.union(u, v)
    return uf.components</code></pre>
                </div>

                <h4>Use Cases</h4>
                <ul>
                    <li>Connected components in undirected graph</li>
                    <li>Cycle detection</li>
                    <li>Kruskal's MST algorithm</li>
                    <li>Network connectivity</li>
                </ul>
            </div>
        </div>

        <!-- Real-World Scale Examples -->
        <h2 class="mt-4">Real-World Scale Examples</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>LinkedIn: Graph Algorithms at 900M+ Users</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>LinkedIn's social graph has 900+ million members and 60+ million companies. Their graph infrastructure processes trillions of edges for features like "People You May Know" and connection path finding.</p>

                <h4>The "2nd Degree Connection" Problem</h4>
                <ul>
                    <li><strong>Scale:</strong> Average user has 500 connections, each has 500 more</li>
                    <li><strong>Challenge:</strong> Finding mutual connections = BFS to depth 2</li>
                    <li><strong>Solution:</strong> Pre-compute and cache 2nd-degree neighborhoods</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># LinkedIn-style "People You May Know" simplified
from collections import defaultdict

class SocialGraph:
    """
    LinkedIn processes 300M+ API calls/day for connection queries.
    Key insight: pre-compute what you query frequently.
    """
    def __init__(self):
        self.connections = defaultdict(set)  # user -> set of connections
        self.second_degree_cache = {}  # Pre-computed for active users

    def add_connection(self, user_a, user_b):
        self.connections[user_a].add(user_b)
        self.connections[user_b].add(user_a)
        # Invalidate cache for both users
        self.second_degree_cache.pop(user_a, None)
        self.second_degree_cache.pop(user_b, None)

    def get_second_degree(self, user):
        """
        BFS to depth 2. LinkedIn caches this for active users.
        Without caching: O(connections * avg_connections) per request.
        """
        if user in self.second_degree_cache:
            return self.second_degree_cache[user]

        first_degree = self.connections[user]
        second_degree = set()

        for friend in first_degree:
            for friend_of_friend in self.connections[friend]:
                if friend_of_friend != user and friend_of_friend not in first_degree:
                    second_degree.add(friend_of_friend)

        self.second_degree_cache[user] = second_degree
        return second_degree

    def people_you_may_know(self, user, limit=10):
        """
        Rank 2nd-degree connections by mutual connection count.
        LinkedIn uses ML models on top of this base signal.
        """
        second_degree = self.get_second_degree(user)
        first_degree = self.connections[user]

        # Count mutual connections
        scores = {}
        for candidate in second_degree:
            mutual = len(self.connections[candidate] & first_degree)
            scores[candidate] = mutual

        # Return top candidates by mutual connections
        ranked = sorted(scores.items(), key=lambda x: -x[1])
        return [user for user, score in ranked[:limit]]</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Google Maps: Shortest Path at Global Scale</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Google Maps serves over 1 billion users, processing 1 billion kilometers of directions daily. The road network graph has billions of nodes (intersections) and edges (road segments).</p>

                <h4>Why Not Just Dijkstra?</h4>
                <ul>
                    <li><strong>Problem:</strong> Dijkstra explores in all directions until finding destination</li>
                    <li><strong>At scale:</strong> NYC to LA would explore entire US road network</li>
                    <li><strong>Solution:</strong> Hierarchical graphs + precomputation</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># Simplified Contraction Hierarchies (used by Google Maps, OSRM)
import heapq

class ContractionHierarchies:
    """
    Preprocess graph to enable bidirectional search on "important" nodes only.
    Preprocessing: O(n log n) time, O(n) space
    Query: O(log n) average, vs O(n) for Dijkstra
    """
    def __init__(self, graph):
        self.graph = graph
        self.importance = {}  # Node importance ranking
        self.shortcuts = defaultdict(list)  # Added shortcut edges

    def preprocess(self):
        """
        Contract nodes in order of importance.
        Add shortcuts to preserve shortest paths.
        Google does this offline - takes hours for continent-scale.
        """
        # Simplified: importance = degree (real algorithm more complex)
        nodes = sorted(self.graph.keys(),
                      key=lambda n: len(self.graph[n]))

        for i, node in enumerate(nodes):
            self.importance[node] = i
            self._contract_node(node)

    def _contract_node(self, node):
        """Add shortcuts between neighbors if node is on shortest path."""
        neighbors = list(self.graph[node])
        for u in neighbors:
            for v in neighbors:
                if u != v:
                    # Check if shortest u->v goes through node
                    uv_through_node = (
                        self._edge_weight(u, node) +
                        self._edge_weight(node, v)
                    )
                    direct_uv = self._edge_weight(u, v)

                    if uv_through_node < direct_uv:
                        # Add shortcut
                        self.shortcuts[u].append((v, uv_through_node))

    def query(self, source, target):
        """
        Bidirectional Dijkstra, but only explore "upward" in hierarchy.
        Dramatically reduces search space.
        """
        # Forward search from source (upward in importance)
        forward_dist = {source: 0}
        forward_heap = [(0, source)]

        # Backward search from target (upward in importance)
        backward_dist = {target: 0}
        backward_heap = [(0, target)]

        best_dist = float('inf')

        while forward_heap or backward_heap:
            # Alternate between forward and backward
            # Only explore nodes with higher importance
            # Meet in the middle at high-importance "hub" nodes
            pass  # Full implementation omitted for brevity

        return best_dist

# Result: NYC to LA query in milliseconds, not minutes</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Facebook: Graph Partitioning for Social Feed</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Facebook's social graph has 3 billion users and trillions of edges. Storing this on a single machine is impossible. Graph partitioning determines which users are stored together.</p>

                <h4>The Challenge</h4>
                <ul>
                    <li><strong>Goal:</strong> Minimize cross-machine queries when loading a user's feed</li>
                    <li><strong>Constraint:</strong> Balanced partition sizes for even load distribution</li>
                    <li><strong>This is NP-hard:</strong> Facebook uses approximation algorithms</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># Simplified graph partitioning (real version uses METIS, Pregel)
class GraphPartitioner:
    """
    Assign users to servers to minimize cross-server edges.
    Facebook re-partitions periodically as friendships change.
    """
    def __init__(self, graph, num_partitions):
        self.graph = graph
        self.num_partitions = num_partitions
        self.assignment = {}  # node -> partition

    def partition_balanced(self):
        """
        Greedy balanced partitioning.
        Assign each node to partition with most existing friends.
        """
        partition_sizes = [0] * self.num_partitions
        max_size = len(self.graph) // self.num_partitions + 1

        for node in self.graph:
            # Count friends in each partition
            friend_counts = [0] * self.num_partitions
            for friend in self.graph[node]:
                if friend in self.assignment:
                    friend_counts[self.assignment[friend]] += 1

            # Assign to partition with most friends (if not full)
            for p in sorted(range(self.num_partitions),
                          key=lambda x: -friend_counts[x]):
                if partition_sizes[p] < max_size:
                    self.assignment[node] = p
                    partition_sizes[p] += 1
                    break

    def edge_cut_ratio(self):
        """Measure partitioning quality: % of edges crossing partitions."""
        cross_edges = 0
        total_edges = 0

        for node in self.graph:
            for neighbor in self.graph[node]:
                total_edges += 1
                if self.assignment[node] != self.assignment[neighbor]:
                    cross_edges += 1

        return cross_edges / total_edges if total_edges else 0

# Facebook achieves ~10% edge cut - 90% of friend data is local!</code></pre>
                </div>
            </div>
        </div>

        <!-- Quiz Section -->
        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Interview Follow-up Questions -->
        <h2 class="mt-4">Interview Follow-up Questions</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Common Follow-ups & What Interviewers Look For</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. "How would you detect a cycle in a directed vs undirected graph?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Undirected: DFS with parent tracking, or Union-Find</li>
                    <li>Directed: DFS with 3 colors (white/gray/black) or topological sort</li>
                    <li>Why the difference: back edge to parent is not a cycle in undirected graphs</li>
                </ul>
                <p><strong>Red flags:</strong> Using the same algorithm for both, not understanding edge classification.</p>

                <h4>2. "When would you use adjacency matrix vs adjacency list?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Matrix: Dense graphs, O(1) edge lookup needed, small graphs</li>
                    <li>List: Sparse graphs (most real-world graphs), memory efficiency</li>
                    <li>Real numbers: Social network with 1M users has 1M nodes but avg 500 edges each</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing space complexity: O(V^2) vs O(V+E).</p>

                <h4>3. "How would you handle negative edge weights?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Dijkstra fails with negative edges</li>
                    <li>Bellman-Ford: O(VE), handles negative weights, detects negative cycles</li>
                    <li>Real use case: arbitrage detection in currency exchange</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing Dijkstra's limitation.</p>

                <h4>4. "How does Union-Find achieve near O(1) operations?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Path compression: flatten tree on find()</li>
                    <li>Union by rank: attach smaller tree under larger</li>
                    <li>Combined: O(alpha(n)) - inverse Ackermann, practically O(1)</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing both optimizations are needed together.</p>

                <h4>5. "How would you find shortest path in a graph with billions of nodes?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Precomputation: Contraction Hierarchies, ALT, Hub Labeling</li>
                    <li>Partitioning: Divide graph into regions, precompute boundary distances</li>
                    <li>Trade-off: preprocessing time vs query time</li>
                </ul>
                <p><strong>Red flags:</strong> Only knowing Dijkstra/BFS without discussing scale.</p>
            </div>
        </div>

        <!-- Practice Problems -->
        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Medium</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/number-of-islands/" target="_blank">Number of Islands (LeetCode #200)</a></li>
                <li><a href="https://leetcode.com/problems/course-schedule/" target="_blank">Course Schedule (LeetCode #207)</a></li>
                <li><a href="https://leetcode.com/problems/clone-graph/" target="_blank">Clone Graph (LeetCode #133)</a></li>
                <li><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/" target="_blank">Connected Components (LeetCode #323)</a></li>
            </ul>

            <h4 class="mt-3">Hard</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/word-ladder/" target="_blank">Word Ladder (LeetCode #127)</a></li>
                <li><a href="https://leetcode.com/problems/alien-dictionary/" target="_blank">Alien Dictionary (LeetCode #269)</a></li>
            </ul>
        </div>

        <!-- Navigation -->
        <div class="flex flex-between mt-4">
            <a href="module-03.html" class="btn btn-secondary">&larr; Module 3</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Sidebar toggle for mobile
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            // Update sidebar links based on completion status
            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('coding', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "Which algorithm finds shortest path in an unweighted graph?",
                    options: ["DFS", "BFS", "Topological Sort", "Union-Find"],
                    correct: 1,
                    explanation: "BFS explores nodes level by level, guaranteeing shortest path in unweighted graphs."
                },
                {
                    question: "What does topological sort require?",
                    options: ["Weighted edges", "Directed Acyclic Graph (DAG)", "Connected graph", "Undirected graph"],
                    correct: 1,
                    explanation: "Topological sort only works on DAGs - cycles make ordering impossible."
                },
                {
                    question: "What's the time complexity of Union-Find operations with optimizations?",
                    options: ["O(n)", "O(log n)", "O(1) amortized", "O(n²)"],
                    correct: 2,
                    explanation: "With path compression and union by rank, operations are nearly O(1) - technically O(α(n))."
                }
            ];

            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();

            // Initialize BFS/DFS visualization
            initGraphVisualization();
        });

        function initGraphVisualization() {
            // Sample graph
            const nodes = ['A', 'B', 'C', 'D', 'E', 'F'];
            const edges = [
                ['A', 'B'], ['A', 'C'], ['B', 'D'], ['B', 'E'], ['C', 'F'], ['D', 'F']
            ];

            // Build adjacency list
            const graph = {};
            nodes.forEach(n => graph[n] = []);
            edges.forEach(([u, v]) => {
                graph[u].push(v);
                graph[v].push(u);
            });

            let mode = 'bfs';
            let visited = new Set();
            let order = [];
            let queue = [];
            let isPlaying = false;
            let playInterval = null;

            const vizContainer = document.getElementById('graph-viz');
            const orderDisplay = document.getElementById('traversal-order');
            const queueDisplay = document.getElementById('traversal-queue');
            const explanation = document.getElementById('graph-explanation');

            // Node positions (pre-computed for nice layout)
            const positions = {
                'A': { x: 60, y: 60 },
                'B': { x: 180, y: 40 },
                'C': { x: 180, y: 140 },
                'D': { x: 300, y: 40 },
                'E': { x: 300, y: 100 },
                'F': { x: 300, y: 160 }
            };

            function render() {
                let svg = '<svg width="100%" height="200" viewBox="0 0 380 200">';

                // Draw edges
                edges.forEach(([u, v]) => {
                    const p1 = positions[u];
                    const p2 = positions[v];
                    svg += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}"
                            stroke="#ddd" stroke-width="2"/>`;
                });

                // Draw nodes
                nodes.forEach(node => {
                    const pos = positions[node];
                    let fill = '#f0f0f0';
                    let stroke = '#ccc';

                    if (visited.has(node)) {
                        fill = 'rgba(16, 185, 129, 0.3)';
                        stroke = '#10b981';
                    }
                    if (queue.includes(node) && !visited.has(node)) {
                        fill = 'rgba(245, 158, 11, 0.3)';
                        stroke = '#f59e0b';
                    }
                    if (order.length > 0 && order[order.length - 1] === node) {
                        fill = 'rgba(37, 99, 235, 0.3)';
                        stroke = '#2563eb';
                    }

                    svg += `<circle cx="${pos.x}" cy="${pos.y}" r="25" fill="${fill}" stroke="${stroke}" stroke-width="3"/>`;
                    svg += `<text x="${pos.x}" y="${pos.y}" text-anchor="middle" dominant-baseline="central" font-weight="bold" font-size="16">${node}</text>`;
                });

                svg += '</svg>';
                vizContainer.innerHTML = svg;

                orderDisplay.textContent = order.join(' → ') || '(empty)';
                queueDisplay.textContent = queue.join(', ') || '(empty)';
            }

            function reset() {
                pause();
                visited = new Set();
                order = [];
                queue = ['A'];
                render();
            }

            function step() {
                if (queue.length === 0) {
                    pause();
                    explanation.innerHTML = '<p><strong>Complete!</strong> All reachable nodes have been visited.</p>';
                    return false;
                }

                let current;
                if (mode === 'bfs') {
                    current = queue.shift();
                } else {
                    current = queue.pop();
                }

                if (visited.has(current)) {
                    return true; // Skip already visited, continue
                }

                visited.add(current);
                order.push(current);

                // Add neighbors
                const neighbors = graph[current].filter(n => !visited.has(n));
                if (mode === 'bfs') {
                    neighbors.forEach(n => {
                        if (!queue.includes(n)) queue.push(n);
                    });
                } else {
                    neighbors.reverse().forEach(n => {
                        if (!queue.includes(n)) queue.push(n);
                    });
                }

                render();

                explanation.innerHTML = `<p>Visiting <strong>${current}</strong>. ${mode === 'bfs' ? 'Queue' : 'Stack'}: [${queue.join(', ')}]</p>`;

                return queue.length > 0;
            }

            function play() {
                if (isPlaying) return;
                isPlaying = true;
                playInterval = setInterval(() => {
                    if (!step()) {
                        pause();
                    }
                }, 800);
            }

            function pause() {
                isPlaying = false;
                if (playInterval) {
                    clearInterval(playInterval);
                    playInterval = null;
                }
            }

            // Event listeners
            document.getElementById('graph-bfs').addEventListener('click', function() {
                mode = 'bfs';
                document.getElementById('graph-bfs').classList.add('active');
                document.getElementById('graph-dfs').classList.remove('active');
                reset();
                explanation.innerHTML = '<p><strong>BFS</strong> uses a <strong>queue</strong> (FIFO). It explores all neighbors at depth d before moving to depth d+1.</p>';
            });

            document.getElementById('graph-dfs').addEventListener('click', function() {
                mode = 'dfs';
                document.getElementById('graph-dfs').classList.add('active');
                document.getElementById('graph-bfs').classList.remove('active');
                reset();
                explanation.innerHTML = '<p><strong>DFS</strong> uses a <strong>stack</strong> (LIFO). It goes as deep as possible before backtracking.</p>';
            });

            document.getElementById('graph-play').addEventListener('click', play);
            document.getElementById('graph-step').addEventListener('click', () => {
                pause();
                step();
            });
            document.getElementById('graph-reset').addEventListener('click', reset);

            // Initial render
            reset();
        }

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 4);
            alert('Module 4 marked as complete!');
            window.location.href = 'module-05.html';
        }
    </script>
</body>
</html>
