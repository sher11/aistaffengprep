<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 6: Backtracking - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <!-- Mermaid replaced with custom interactive animations -->
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
                <li><a href="../generative-ai/index.html">Gen AI</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Fundamentals</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Foundations
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Arrays & Two Pointers
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Patterns</div>
                    <a href="module-03.html" class="sidebar-link" data-module="3">
                        <span class="sidebar-link-number">3</span>Trees & Binary Search
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Graphs
                    </a>
                    <a href="module-05.html" class="sidebar-link" data-module="5">
                        <span class="sidebar-link-number">5</span>Dynamic Programming
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Advanced</div>
                    <a href="module-06.html" class="sidebar-link active" data-module="6">
                        <span class="sidebar-link-number">6</span>Backtracking
                    </a>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">7</span>Heaps & Sorting
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">8</span>Non-LeetCode Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">9</span>Interview Simulation
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Main Content -->
        <main class="main-content">
        <h1>Module 6: Backtracking & Recursion</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Understand the backtracking paradigm</li>
                <li>Generate permutations and combinations</li>
                <li>Solve constraint satisfaction problems</li>
                <li>Apply pruning to optimize solutions</li>
            </ul>
        </div>

        <h2 class="mt-4">Backtracking Template</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Core Pattern</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="diagram-container">
                    <!-- Interactive Backtracking Flow Animation -->
                    <div id="backtracking-flow-animation" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 16px; padding: 30px; position: relative; overflow: hidden; min-height: 480px;">
                        <style>
                            #backtracking-flow-animation .flow-node {
                                position: absolute;
                                padding: 12px 20px;
                                border-radius: 12px;
                                font-weight: 600;
                                font-size: 14px;
                                cursor: pointer;
                                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                                text-align: center;
                                z-index: 2;
                                white-space: nowrap;
                            }
                            #backtracking-flow-animation .flow-node:hover {
                                transform: scale(1.1);
                                box-shadow: 0 8px 25px rgba(0,0,0,0.4);
                            }
                            #backtracking-flow-animation .flow-node.active {
                                animation: pulse-glow-bt 1.5s ease-in-out infinite;
                            }
                            @keyframes pulse-glow-bt {
                                0%, 100% { box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
                                50% { box-shadow: 0 4px 30px rgba(102, 126, 234, 0.8); }
                            }
                            #backtracking-flow-animation .node-start { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; left: 50%; top: 15px; transform: translateX(-50%); }
                            #backtracking-flow-animation .node-base { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; left: 50%; top: 80px; transform: translateX(-50%); border-radius: 50%; width: 110px; height: 45px; display: flex; align-items: center; justify-content: center; padding: 0; }
                            #backtracking-flow-animation .node-result { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; left: 12%; top: 160px; }
                            #backtracking-flow-animation .node-foreach { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: #1a1a2e; left: 60%; top: 160px; }
                            #backtracking-flow-animation .node-valid { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: #1a1a2e; left: 60%; top: 240px; transform: translateX(-50%); border-radius: 50%; width: 100px; height: 45px; display: flex; align-items: center; justify-content: center; padding: 0; }
                            #backtracking-flow-animation .node-make { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); color: #1a1a2e; left: 25%; top: 320px; }
                            #backtracking-flow-animation .node-recurse { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; left: 25%; top: 390px; }
                            #backtracking-flow-animation .node-undo { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); color: #1a1a2e; left: 60%; top: 320px; }
                            #backtracking-flow-animation svg.flow-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
                            #backtracking-flow-animation .flow-line { stroke: rgba(255,255,255,0.4); stroke-width: 2; fill: none; }
                            #backtracking-flow-animation .flow-line.active { stroke: #38ef7d; stroke-width: 3; filter: drop-shadow(0 0 6px #38ef7d); }
                            #backtracking-flow-animation .flow-arrow { fill: rgba(255,255,255,0.6); }
                            #backtracking-flow-animation .flow-label { fill: rgba(255,255,255,0.9); font-size: 11px; font-weight: 600; }
                            #backtracking-flow-animation .control-panel { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 3; }
                            #backtracking-flow-animation .control-btn { padding: 10px 20px; border: none; border-radius: 25px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.3s; }
                            #backtracking-flow-animation .control-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(102, 126, 234, 0.5); }
                            #backtracking-flow-animation .bt-tooltip { position: absolute; background: rgba(0,0,0,0.95); color: white; padding: 12px 16px; border-radius: 10px; font-size: 12px; max-width: 220px; z-index: 10; opacity: 0; pointer-events: none; transition: opacity 0.3s; border: 1px solid rgba(102, 126, 234, 0.5); }
                            #backtracking-flow-animation .bt-tooltip.visible { opacity: 1; }
                            #backtracking-flow-animation .step-indicator { position: absolute; top: 15px; right: 20px; background: rgba(255,255,255,0.1); padding: 8px 15px; border-radius: 20px; color: white; font-size: 12px; }
                        </style>
                        <div class="step-indicator" id="bt-step-indicator">Click Play to animate</div>
                        <svg class="flow-lines" viewBox="0 0 400 450" preserveAspectRatio="xMidYMid meet">
                            <defs>
                                <marker id="arrowhead-bt" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" class="flow-arrow"/>
                                </marker>
                            </defs>
                            <!-- Start to Base case -->
                            <path class="flow-line" id="bt-line-0" d="M200,42 L200,70" marker-end="url(#arrowhead-bt)"/>
                            <!-- Base case Yes to Result -->
                            <path class="flow-line" id="bt-line-1" d="M155,102 L85,150" marker-end="url(#arrowhead-bt)"/>
                            <text class="flow-label" x="100" y="120">Yes</text>
                            <!-- Base case No to For each -->
                            <path class="flow-line" id="bt-line-2" d="M245,102 L280,150" marker-end="url(#arrowhead-bt)"/>
                            <text class="flow-label" x="275" y="120">No</text>
                            <!-- For each to Valid -->
                            <path class="flow-line" id="bt-line-3" d="M280,190 L260,230" marker-end="url(#arrowhead-bt)"/>
                            <!-- Valid Yes to Make -->
                            <path class="flow-line" id="bt-line-4" d="M210,262 L150,310" marker-end="url(#arrowhead-bt)"/>
                            <text class="flow-label" x="160" y="285">Yes</text>
                            <!-- Valid No back to For each -->
                            <path class="flow-line" id="bt-line-5" d="M310,262 L320,200 L310,190" marker-end="url(#arrowhead-bt)" stroke-dasharray="4,4"/>
                            <text class="flow-label" x="330" y="230">No</text>
                            <!-- Make to Recurse -->
                            <path class="flow-line" id="bt-line-6" d="M145,350 L145,380" marker-end="url(#arrowhead-bt)"/>
                            <!-- Recurse to Undo -->
                            <path class="flow-line" id="bt-line-7" d="M185,410 L280,360" marker-end="url(#arrowhead-bt)"/>
                            <!-- Undo back to For each -->
                            <path class="flow-line" id="bt-line-8" d="M310,320 L320,180 L310,175" marker-end="url(#arrowhead-bt)" stroke-dasharray="4,4"/>
                        </svg>
                        <div class="flow-node node-start" data-info="Entry point: Begin exploring the solution space with initial empty state">Start</div>
                        <div class="flow-node node-base" data-info="Check termination: Have we built a complete solution? (e.g., path length reached, all positions filled)">Base case?</div>
                        <div class="flow-node node-result" data-info="Solution found! Add a COPY of current state to results (not a reference, or it will change)">Add to result</div>
                        <div class="flow-node node-foreach" data-info="Iterate through all possible choices at the current decision point">For each choice</div>
                        <div class="flow-node node-valid" data-info="Constraint check: Does this choice satisfy all requirements? (pruning happens here)">Valid?</div>
                        <div class="flow-node node-make" data-info="Commit to choice: Update state, mark element as used, add to current path">Make choice</div>
                        <div class="flow-node node-recurse" data-info="Recursive call: Explore deeper from the new state (depth-first search)">Recurse</div>
                        <div class="flow-node node-undo" data-info="BACKTRACK: Undo the choice, restore previous state, then try the next option">Undo choice</div>
                        <div class="bt-tooltip" id="bt-tooltip"></div>
                        <div class="control-panel">
                            <button class="control-btn" onclick="animateBacktrackingFlow()">Play Animation</button>
                            <button class="control-btn" onclick="resetBacktrackingFlow()">Reset</button>
                        </div>
                        <script>
                            (function() {
                                const container = document.getElementById('backtracking-flow-animation');
                                const nodes = container.querySelectorAll('.flow-node');
                                const tooltip = document.getElementById('bt-tooltip');

                                nodes.forEach(node => {
                                    node.addEventListener('mouseenter', (e) => {
                                        const rect = container.getBoundingClientRect();
                                        tooltip.textContent = node.dataset.info;
                                        tooltip.style.left = Math.min(e.clientX - rect.left + 10, rect.width - 240) + 'px';
                                        tooltip.style.top = (e.clientY - rect.top - 50) + 'px';
                                        tooltip.classList.add('visible');
                                    });
                                    node.addEventListener('mouseleave', () => {
                                        tooltip.classList.remove('visible');
                                    });
                                });
                            })();

                            let btAnimationInterval;
                            function animateBacktrackingFlow() {
                                const container = document.getElementById('backtracking-flow-animation');
                                const nodes = container.querySelectorAll('.flow-node');
                                const lines = container.querySelectorAll('.flow-line');
                                const indicator = document.getElementById('bt-step-indicator');
                                const steps = [
                                    {node: 0, line: null, text: 'Start: Begin backtracking'},
                                    {node: 1, line: 0, text: 'Check: Is this a complete solution?'},
                                    {node: 3, line: 2, text: 'Not yet - try each available choice'},
                                    {node: 4, line: 3, text: 'Is choice [1] valid?'},
                                    {node: 5, line: 4, text: 'Yes! Make the choice'},
                                    {node: 6, line: 6, text: 'Recurse with new state...'},
                                    {node: 1, line: null, text: 'Check: Is this complete?'},
                                    {node: 3, line: 2, text: 'Try next choice'},
                                    {node: 4, line: 3, text: 'Is choice [2] valid?'},
                                    {node: 5, line: 4, text: 'Yes! Make the choice'},
                                    {node: 6, line: 6, text: 'Recurse deeper...'},
                                    {node: 1, line: null, text: 'Base case reached!'},
                                    {node: 2, line: 1, text: 'Add solution to results'},
                                    {node: 7, line: 7, text: 'Undo last choice (backtrack)'},
                                    {node: 3, line: 8, text: 'Try remaining choices...'},
                                ];
                                let step = 0;

                                clearInterval(btAnimationInterval);
                                nodes.forEach(n => n.classList.remove('active'));
                                lines.forEach(l => l.classList.remove('active'));

                                btAnimationInterval = setInterval(() => {
                                    nodes.forEach(n => n.classList.remove('active'));
                                    lines.forEach(l => l.classList.remove('active'));

                                    if (step < steps.length) {
                                        nodes[steps[step].node].classList.add('active');
                                        if (steps[step].line !== null) {
                                            lines[steps[step].line].classList.add('active');
                                        }
                                        indicator.textContent = steps[step].text;
                                        step++;
                                    } else {
                                        clearInterval(btAnimationInterval);
                                        indicator.textContent = 'Animation complete - Click Play to restart';
                                    }
                                }, 1200);
                            }

                            function resetBacktrackingFlow() {
                                clearInterval(btAnimationInterval);
                                const container = document.getElementById('backtracking-flow-animation');
                                container.querySelectorAll('.flow-node').forEach(n => n.classList.remove('active'));
                                container.querySelectorAll('.flow-line').forEach(l => l.classList.remove('active'));
                                document.getElementById('bt-step-indicator').textContent = 'Click Play to animate';
                            }
                        </script>
                    </div>
                </div>

                <div class="code-block">
                    <pre><code class="language-python">def backtrack(state, choices, result):
    # Base case: found a solution
    if is_solution(state):
        result.append(state.copy())
        return

    # Try each choice
    for choice in choices:
        if is_valid(choice, state):
            # Make choice
            state.append(choice)

            # Recurse
            backtrack(state, remaining_choices, result)

            # Undo choice (backtrack)
            state.pop()</code></pre>
                </div>
            </div>
        </div>

        <h2 class="mt-4">Permutations & Combinations</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Permutations</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def permutations(nums):
    """Generate all permutations of nums."""
    result = []

    def backtrack(path, remaining):
        if not remaining:
            result.append(path[:])
            return

        for i in range(len(remaining)):
            path.append(remaining[i])
            backtrack(path, remaining[:i] + remaining[i+1:])
            path.pop()

    backtrack([], nums)
    return result

# Example: [1,2,3] -> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Combinations & Subsets</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python"># All subsets
def subsets(nums):
    result = []

    def backtrack(start, path):
        result.append(path[:])  # Add current subset

        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)  # Move forward to avoid duplicates
            path.pop()

    backtrack(0, [])
    return result

# Combinations of size k
def combinations(n, k):
    result = []

    def backtrack(start, path):
        if len(path) == k:
            result.append(path[:])
            return

        for i in range(start, n + 1):
            path.append(i)
            backtrack(i + 1, path)
            path.pop()

    backtrack(1, [])
    return result</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>N-Queens</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def solve_n_queens(n):
    """Place n queens on n×n board so no two attack each other."""
    result = []
    board = [['.'] * n for _ in range(n)]

    # Track which columns and diagonals are under attack
    cols = set()
    diag1 = set()  # row - col
    diag2 = set()  # row + col

    def backtrack(row):
        if row == n:
            result.append([''.join(r) for r in board])
            return

        for col in range(n):
            if col in cols or (row - col) in diag1 or (row + col) in diag2:
                continue

            # Place queen
            board[row][col] = 'Q'
            cols.add(col)
            diag1.add(row - col)
            diag2.add(row + col)

            backtrack(row + 1)

            # Remove queen
            board[row][col] = '.'
            cols.remove(col)
            diag1.remove(row - col)
            diag2.remove(row + col)

    backtrack(0)
    return result</code></pre>
                </div>
            </div>
        </div>

        <!-- Pruning Strategies Section -->
        <h2 class="mt-4">Pruning Strategies</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Why Pruning Matters</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Pruning eliminates branches of the search tree that cannot lead to valid solutions. Without pruning, backtracking degenerates to brute-force enumeration. Effective pruning can reduce exponential time complexity by orders of magnitude.</p>

                <div class="diagram-container">
                    <!-- Interactive Pruning Visualization -->
                    <div id="pruning-animation" style="background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%); border-radius: 16px; padding: 30px; position: relative; overflow: hidden; min-height: 420px;">
                        <style>
                            #pruning-animation .prune-node {
                                position: absolute;
                                padding: 14px 22px;
                                border-radius: 12px;
                                font-weight: 600;
                                font-size: 13px;
                                cursor: pointer;
                                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                                box-shadow: 0 4px 20px rgba(0,0,0,0.4);
                                text-align: center;
                                z-index: 2;
                            }
                            #pruning-animation .prune-node:hover {
                                transform: scale(1.08) translateY(-3px);
                                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                            }
                            #pruning-animation .prune-node.highlight {
                                animation: prune-pulse 0.8s ease-in-out infinite;
                            }
                            @keyframes prune-pulse {
                                0%, 100% { transform: scale(1); }
                                50% { transform: scale(1.05); }
                            }
                            #pruning-animation .prune-node.pruned {
                                animation: shake-prune 0.5s ease-in-out;
                                opacity: 0.5;
                            }
                            @keyframes shake-prune {
                                0%, 100% { transform: translateX(0); }
                                20%, 60% { transform: translateX(-5px); }
                                40%, 80% { transform: translateX(5px); }
                            }
                            #pruning-animation .node-search { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; left: 50%; top: 20px; transform: translateX(-50%); }
                            #pruning-animation .node-check { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; left: 50%; top: 100px; transform: translateX(-50%); border-radius: 50%; width: 140px; height: 50px; display: flex; align-items: center; justify-content: center; padding: 0; }
                            #pruning-animation .node-explore { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; left: 18%; top: 200px; }
                            #pruning-animation .node-prune { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); color: white; left: 58%; top: 200px; font-size: 12px; }
                            #pruning-animation .node-recurse { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: #1a1a2e; left: 18%; top: 300px; }
                            #pruning-animation .node-speedup { background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%); color: white; left: 58%; top: 300px; }
                            #pruning-animation svg.prune-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
                            #pruning-animation .prune-line { stroke: rgba(255,255,255,0.4); stroke-width: 2.5; fill: none; transition: all 0.4s; }
                            #pruning-animation .prune-line.valid-path { stroke: #38ef7d; stroke-width: 3; filter: drop-shadow(0 0 8px #38ef7d); }
                            #pruning-animation .prune-line.pruned-path { stroke: #eb3349; stroke-width: 3; stroke-dasharray: 8,4; filter: drop-shadow(0 0 8px #eb3349); }
                            #pruning-animation .prune-arrow { fill: rgba(255,255,255,0.6); }
                            #pruning-animation .prune-label { fill: rgba(255,255,255,0.95); font-size: 12px; font-weight: 700; }
                            #pruning-animation .label-valid { fill: #38ef7d; }
                            #pruning-animation .label-invalid { fill: #f45c43; }
                            #pruning-animation .prune-controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 3; }
                            #pruning-animation .prune-btn { padding: 12px 24px; border: none; border-radius: 25px; background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s; }
                            #pruning-animation .prune-btn:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(17, 153, 142, 0.5); }
                            #pruning-animation .prune-btn.danger { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); }
                            #pruning-animation .prune-btn.danger:hover { box-shadow: 0 8px 25px rgba(235, 51, 73, 0.5); }
                            #pruning-animation .stats-panel { position: absolute; top: 15px; right: 15px; background: rgba(255,255,255,0.1); padding: 12px 18px; border-radius: 12px; color: white; font-size: 12px; backdrop-filter: blur(10px); }
                            #pruning-animation .stats-panel div { margin: 4px 0; }
                            #pruning-animation .stat-value { font-weight: 700; color: #38ef7d; }
                            #pruning-animation .stat-value.pruned { color: #f45c43; }
                        </style>
                        <div class="stats-panel">
                            <div>Explored: <span class="stat-value" id="prune-explored">0</span></div>
                            <div>Pruned: <span class="stat-value pruned" id="prune-pruned">0</span></div>
                            <div>Saved: <span class="stat-value" id="prune-saved">0%</span></div>
                        </div>
                        <svg class="prune-lines" viewBox="0 0 400 380" preserveAspectRatio="xMidYMid meet">
                            <defs>
                                <marker id="arrowhead-prune" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" class="prune-arrow"/>
                                </marker>
                            </defs>
                            <path class="prune-line" id="prune-line-1" d="M200,55 L200,90" marker-end="url(#arrowhead-prune)"/>
                            <path class="prune-line" id="prune-line-2" d="M145,130 L100,185" marker-end="url(#arrowhead-prune)"/>
                            <text class="prune-label label-valid" x="95" y="155">Valid</text>
                            <path class="prune-line" id="prune-line-3" d="M255,130 L290,185" marker-end="url(#arrowhead-prune)"/>
                            <text class="prune-label label-invalid" x="275" y="155">Invalid</text>
                            <path class="prune-line" id="prune-line-4" d="M100,240 L100,285" marker-end="url(#arrowhead-prune)"/>
                            <path class="prune-line" id="prune-line-5" d="M300,240 L300,285" marker-end="url(#arrowhead-prune)"/>
                        </svg>
                        <div class="prune-node node-search">Search Space</div>
                        <div class="prune-node node-check">Constraint Check</div>
                        <div class="prune-node node-explore" id="prune-explore">Explore Branch</div>
                        <div class="prune-node node-prune" id="prune-skip">PRUNE - Skip Subtree</div>
                        <div class="prune-node node-recurse" id="prune-recurse">Recursive call</div>
                        <div class="prune-node node-speedup" id="prune-speedup">Significant speedup!</div>
                        <div class="prune-controls">
                            <button class="prune-btn" onclick="demoPruningValid()">Demo Valid Path</button>
                            <button class="prune-btn danger" onclick="demoPruningInvalid()">Demo Pruning</button>
                            <button class="prune-btn" onclick="resetPruning()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">Reset</button>
                        </div>
                        <script>
                            let pruneExplored = 0, prunePruned = 0;

                            function updatePruneStats() {
                                document.getElementById('prune-explored').textContent = pruneExplored;
                                document.getElementById('prune-pruned').textContent = prunePruned;
                                const total = pruneExplored + prunePruned;
                                const saved = total > 0 ? Math.round((prunePruned / total) * 100) : 0;
                                document.getElementById('prune-saved').textContent = saved + '%';
                            }

                            function demoPruningValid() {
                                resetPruning();
                                const nodes = ['node-search', 'node-check', 'node-explore', 'node-recurse'];
                                const lines = ['prune-line-1', 'prune-line-2', 'prune-line-4'];

                                let step = 0;
                                const interval = setInterval(() => {
                                    if (step < nodes.length) {
                                        const node = document.querySelector('#pruning-animation .' + nodes[step]);
                                        if (node) node.classList.add('highlight');
                                        if (step > 0 && lines[step-1]) {
                                            document.getElementById(lines[step-1]).classList.add('valid-path');
                                        }
                                        step++;
                                    } else {
                                        clearInterval(interval);
                                        pruneExplored++;
                                        updatePruneStats();
                                    }
                                }, 600);
                            }

                            function demoPruningInvalid() {
                                resetPruning();
                                const container = document.getElementById('pruning-animation');

                                setTimeout(() => {
                                    container.querySelector('.node-search').classList.add('highlight');
                                    document.getElementById('prune-line-1').classList.add('valid-path');
                                }, 300);

                                setTimeout(() => {
                                    container.querySelector('.node-check').classList.add('highlight');
                                }, 600);

                                setTimeout(() => {
                                    document.getElementById('prune-line-3').classList.add('pruned-path');
                                    container.querySelector('.node-prune').classList.add('pruned');
                                    container.querySelector('.node-prune').classList.add('highlight');
                                }, 1000);

                                setTimeout(() => {
                                    document.getElementById('prune-line-5').classList.add('valid-path');
                                    container.querySelector('.node-speedup').classList.add('highlight');
                                    prunePruned++;
                                    updatePruneStats();
                                }, 1500);
                            }

                            function resetPruning() {
                                const container = document.getElementById('pruning-animation');
                                container.querySelectorAll('.prune-node').forEach(n => {
                                    n.classList.remove('highlight', 'pruned');
                                });
                                container.querySelectorAll('.prune-line').forEach(l => {
                                    l.classList.remove('valid-path', 'pruned-path');
                                });
                            }
                        </script>
                    </div>
                </div>

                <h4>Types of Pruning</h4>
                <ul>
                    <li><strong>Feasibility Pruning:</strong> Skip choices that violate constraints (e.g., invalid queen placement)</li>
                    <li><strong>Optimality Pruning:</strong> Skip branches that cannot improve on the best solution found so far</li>
                    <li><strong>Symmetry Pruning:</strong> Avoid exploring symmetric configurations (e.g., in N-Queens, only explore half the first row)</li>
                    <li><strong>Ordering Heuristics:</strong> Try most constrained choices first to fail early</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Pruning Examples with Code</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python"># Example 1: Combination Sum with Pruning
# Find all combinations that sum to target (can reuse elements)

def combination_sum(candidates, target):
    """
    Pruning strategies:
    1. Sort candidates to enable early termination
    2. Skip if current candidate exceeds remaining target
    3. Start from current index to avoid duplicate combinations
    """
    candidates.sort()  # Enable pruning
    result = []

    def backtrack(start, path, remaining):
        if remaining == 0:
            result.append(path[:])
            return

        for i in range(start, len(candidates)):
            # PRUNING: If current candidate exceeds remaining,
            # all subsequent (larger) candidates will too
            if candidates[i] > remaining:
                break  # Prune entire remaining branch

            path.append(candidates[i])
            # Allow reuse: pass i, not i+1
            backtrack(i, path, remaining - candidates[i])
            path.pop()

    backtrack(0, [], target)
    return result

# Example 2: Subsets with Duplicates - Pruning duplicates
def subsets_with_dup(nums):
    """
    When input has duplicates, prune to avoid duplicate subsets.
    Key insight: Skip duplicate elements at the same recursion level.
    """
    nums.sort()  # Group duplicates together
    result = []

    def backtrack(start, path):
        result.append(path[:])

        for i in range(start, len(nums)):
            # PRUNING: Skip duplicates at same level
            # i > start ensures we don't skip first occurrence
            if i > start and nums[i] == nums[i-1]:
                continue  # Prune this branch

            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()

    backtrack(0, [])
    return result

# Example: [1,2,2] -> [[], [1], [1,2], [1,2,2], [2], [2,2]]
# Without pruning: [[], [1], [1,2], [1,2,2], [1,2], [2], [2,2], [2]]  # duplicates!</code></pre>
                </div>
            </div>
        </div>

        <!-- Branch and Bound Section -->
        <h2 class="mt-4">Branch and Bound Optimization</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Branch and Bound Explained</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Branch and Bound extends backtracking for optimization problems by maintaining a bound on the best solution. Branches are pruned when their best possible outcome cannot beat the current best.</p>

                <div class="diagram-container">
                    <!-- Interactive Branch and Bound Animation -->
                    <div id="bnb-animation" style="background: linear-gradient(135deg, #1a1a2e 0%, #0f3460 50%, #16213e 100%); border-radius: 16px; padding: 25px; position: relative; overflow: hidden; min-height: 520px;">
                        <style>
                            #bnb-animation .bnb-node {
                                position: absolute;
                                padding: 10px 16px;
                                border-radius: 10px;
                                font-weight: 600;
                                font-size: 12px;
                                cursor: pointer;
                                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                                box-shadow: 0 4px 15px rgba(0,0,0,0.4);
                                text-align: center;
                                z-index: 2;
                                white-space: nowrap;
                            }
                            #bnb-animation .bnb-node:hover {
                                transform: scale(1.1);
                                z-index: 10;
                            }
                            #bnb-animation .bnb-node.active {
                                animation: bnb-glow 1s ease-in-out infinite;
                            }
                            @keyframes bnb-glow {
                                0%, 100% { box-shadow: 0 4px 15px rgba(0,0,0,0.4); }
                                50% { box-shadow: 0 4px 30px rgba(79, 172, 254, 0.8); }
                            }
                            #bnb-animation .bnb-node.pruned-node {
                                opacity: 0.4;
                                transform: scale(0.9);
                            }
                            #bnb-animation .bnb-node.solution-node {
                                animation: solution-found 0.6s ease-out;
                            }
                            @keyframes solution-found {
                                0% { transform: scale(1); }
                                50% { transform: scale(1.2); }
                                100% { transform: scale(1); }
                            }
                            #bnb-animation .node-current { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; left: 50%; top: 15px; transform: translateX(-50%); }
                            #bnb-animation .node-bound { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; left: 50%; top: 75px; transform: translateX(-50%); border-radius: 50%; width: 120px; height: 42px; display: flex; align-items: center; justify-content: center; padding: 0; }
                            #bnb-animation .node-compare { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: #1a1a2e; left: 50%; top: 140px; transform: translateX(-50%); border-radius: 50%; width: 150px; height: 45px; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 11px; }
                            #bnb-animation .node-explore { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: #1a1a2e; left: 20%; top: 220px; }
                            #bnb-animation .node-prune-bnb { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); color: white; left: 60%; top: 220px; font-size: 11px; }
                            #bnb-animation .node-leaf { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; left: 20%; top: 295px; transform: translateX(-50%); border-radius: 50%; width: 110px; height: 42px; display: flex; align-items: center; justify-content: center; padding: 0; font-size: 11px; }
                            #bnb-animation .node-update { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; left: 8%; top: 375px; font-size: 11px; }
                            #bnb-animation .node-branch { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); color: #1a1a2e; left: 32%; top: 375px; }
                            #bnb-animation svg.bnb-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
                            #bnb-animation .bnb-line { stroke: rgba(255,255,255,0.35); stroke-width: 2; fill: none; transition: all 0.4s; }
                            #bnb-animation .bnb-line.active-line { stroke: #4facfe; stroke-width: 3; filter: drop-shadow(0 0 6px #4facfe); }
                            #bnb-animation .bnb-line.prune-line { stroke: #eb3349; stroke-width: 3; stroke-dasharray: 6,4; }
                            #bnb-animation .bnb-line.success-line { stroke: #38ef7d; stroke-width: 3; filter: drop-shadow(0 0 6px #38ef7d); }
                            #bnb-animation .bnb-arrow { fill: rgba(255,255,255,0.5); }
                            #bnb-animation .bnb-label { fill: rgba(255,255,255,0.9); font-size: 11px; font-weight: 600; }
                            #bnb-animation .bnb-controls { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 3; flex-wrap: wrap; justify-content: center; }
                            #bnb-animation .bnb-btn { padding: 10px 18px; border: none; border-radius: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.3s; }
                            #bnb-animation .bnb-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(102, 126, 234, 0.5); }
                            #bnb-animation .best-display { position: absolute; top: 15px; right: 15px; background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); padding: 10px 18px; border-radius: 20px; color: white; font-size: 13px; font-weight: 700; }
                            #bnb-animation .bound-display { position: absolute; top: 15px; left: 15px; background: rgba(255,255,255,0.15); padding: 10px 18px; border-radius: 20px; color: white; font-size: 12px; backdrop-filter: blur(5px); }
                        </style>
                        <div class="best-display">Best: <span id="bnb-best">0</span></div>
                        <div class="bound-display">Bound: <span id="bnb-bound">--</span></div>
                        <svg class="bnb-lines" viewBox="0 0 400 460" preserveAspectRatio="xMidYMid meet">
                            <defs>
                                <marker id="arrowhead-bnb" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" class="bnb-arrow"/>
                                </marker>
                            </defs>
                            <path class="bnb-line" id="bnb-line-1" d="M200,42 L200,68" marker-end="url(#arrowhead-bnb)"/>
                            <path class="bnb-line" id="bnb-line-2" d="M200,98 L200,130" marker-end="url(#arrowhead-bnb)"/>
                            <path class="bnb-line" id="bnb-line-3" d="M145,163 L110,205" marker-end="url(#arrowhead-bnb)"/>
                            <text class="bnb-label" x="105" y="182">Yes</text>
                            <path class="bnb-line" id="bnb-line-4" d="M255,163 L285,205" marker-end="url(#arrowhead-bnb)"/>
                            <text class="bnb-label" x="280" y="182" style="fill: #f45c43;">No</text>
                            <path class="bnb-line" id="bnb-line-5" d="M105,255 L95,285" marker-end="url(#arrowhead-bnb)"/>
                            <path class="bnb-line" id="bnb-line-6" d="M60,320 L55,360" marker-end="url(#arrowhead-bnb)"/>
                            <text class="bnb-label" x="30" y="340">Yes</text>
                            <path class="bnb-line" id="bnb-line-7" d="M130,320 L155,360" marker-end="url(#arrowhead-bnb)"/>
                            <text class="bnb-label" x="160" y="340">No</text>
                            <path class="bnb-line" id="bnb-line-8" d="M195,395 C250,420 350,380 350,100 L250,50" marker-end="url(#arrowhead-bnb)" stroke-dasharray="4,4"/>
                        </svg>
                        <div class="bnb-node node-current">Current Node</div>
                        <div class="bnb-node node-bound">Calculate Bound</div>
                        <div class="bnb-node node-compare">Bound > Best?</div>
                        <div class="bnb-node node-explore">Explore children</div>
                        <div class="bnb-node node-prune-bnb" id="bnb-prune">PRUNE - Cannot improve</div>
                        <div class="bnb-node node-leaf">Is leaf/solution?</div>
                        <div class="bnb-node node-update" id="bnb-update">Update best</div>
                        <div class="bnb-node node-branch">Branch to children</div>
                        <div class="bnb-controls">
                            <button class="bnb-btn" onclick="animateBnBExplore()">Explore Path</button>
                            <button class="bnb-btn" onclick="animateBnBPrune()" style="background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);">Prune Path</button>
                            <button class="bnb-btn" onclick="animateBnBSolution()" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);">Find Solution</button>
                            <button class="bnb-btn" onclick="resetBnB()">Reset</button>
                        </div>
                        <script>
                            let bnbBest = 0;

                            function animateBnBExplore() {
                                resetBnB();
                                const container = document.getElementById('bnb-animation');
                                const nodes = container.querySelectorAll('.bnb-node');
                                const boundDisplay = document.getElementById('bnb-bound');
                                const sequence = [
                                    {idx: 0, bound: '150', line: null},
                                    {idx: 1, bound: '150', line: 'bnb-line-1'},
                                    {idx: 2, bound: '150 > ' + bnbBest + '?', line: 'bnb-line-2'},
                                    {idx: 3, bound: 'Yes! Explore', line: 'bnb-line-3'},
                                    {idx: 5, bound: 'Check leaf', line: 'bnb-line-5'},
                                    {idx: 7, bound: 'Not leaf, branch', line: 'bnb-line-7'},
                                ];
                                let step = 0;
                                const interval = setInterval(() => {
                                    nodes.forEach(n => n.classList.remove('active'));
                                    if (step < sequence.length) {
                                        nodes[sequence[step].idx].classList.add('active');
                                        boundDisplay.textContent = sequence[step].bound;
                                        if (sequence[step].line) {
                                            document.getElementById(sequence[step].line).classList.add('active-line');
                                        }
                                        step++;
                                    } else {
                                        clearInterval(interval);
                                    }
                                }, 800);
                            }

                            function animateBnBPrune() {
                                resetBnB();
                                bnbBest = 200;
                                document.getElementById('bnb-best').textContent = bnbBest;
                                const container = document.getElementById('bnb-animation');
                                const nodes = container.querySelectorAll('.bnb-node');
                                const boundDisplay = document.getElementById('bnb-bound');

                                setTimeout(() => { nodes[0].classList.add('active'); boundDisplay.textContent = '150'; document.getElementById('bnb-line-1').classList.add('active-line'); }, 400);
                                setTimeout(() => { nodes[1].classList.add('active'); document.getElementById('bnb-line-2').classList.add('active-line'); }, 800);
                                setTimeout(() => { nodes[2].classList.add('active'); boundDisplay.textContent = '150 < 200'; }, 1200);
                                setTimeout(() => {
                                    document.getElementById('bnb-line-4').classList.add('prune-line');
                                    document.getElementById('bnb-prune').classList.add('active');
                                    document.getElementById('bnb-prune').classList.add('pruned-node');
                                    boundDisplay.textContent = 'PRUNED!';
                                }, 1600);
                            }

                            function animateBnBSolution() {
                                resetBnB();
                                const container = document.getElementById('bnb-animation');
                                const nodes = container.querySelectorAll('.bnb-node');
                                const boundDisplay = document.getElementById('bnb-bound');

                                setTimeout(() => { nodes[0].classList.add('active'); document.getElementById('bnb-line-1').classList.add('success-line'); }, 300);
                                setTimeout(() => { nodes[1].classList.add('active'); boundDisplay.textContent = '250'; document.getElementById('bnb-line-2').classList.add('success-line'); }, 600);
                                setTimeout(() => { nodes[2].classList.add('active'); boundDisplay.textContent = '250 > ' + bnbBest; document.getElementById('bnb-line-3').classList.add('success-line'); }, 900);
                                setTimeout(() => { nodes[3].classList.add('active'); document.getElementById('bnb-line-5').classList.add('success-line'); }, 1200);
                                setTimeout(() => { nodes[5].classList.add('active'); boundDisplay.textContent = 'Leaf found!'; document.getElementById('bnb-line-6').classList.add('success-line'); }, 1500);
                                setTimeout(() => {
                                    document.getElementById('bnb-update').classList.add('active');
                                    document.getElementById('bnb-update').classList.add('solution-node');
                                    bnbBest = 250;
                                    document.getElementById('bnb-best').textContent = bnbBest;
                                    boundDisplay.textContent = 'Best updated!';
                                }, 1800);
                            }

                            function resetBnB() {
                                const container = document.getElementById('bnb-animation');
                                container.querySelectorAll('.bnb-node').forEach(n => n.classList.remove('active', 'pruned-node', 'solution-node'));
                                container.querySelectorAll('.bnb-line').forEach(l => l.classList.remove('active-line', 'prune-line', 'success-line'));
                                document.getElementById('bnb-bound').textContent = '--';
                                bnbBest = 0;
                                document.getElementById('bnb-best').textContent = '0';
                            }
                        </script>
                    </div>
                </div>

                <div class="code-block">
                    <pre><code class="language-python"># Branch and Bound for 0/1 Knapsack
# Find maximum value without exceeding weight capacity

def knapsack_branch_bound(weights, values, capacity):
    """
    Branch and Bound for 0/1 Knapsack.
    Uses upper bound calculation to prune unpromising branches.

    Upper bound = current value + (remaining capacity * best value/weight ratio)
    """
    n = len(weights)

    # Sort items by value/weight ratio (descending) for better bounds
    items = sorted(zip(weights, values), key=lambda x: x[1]/x[0], reverse=True)
    weights = [item[0] for item in items]
    values = [item[1] for item in items]

    best_value = [0]  # Use list for mutable closure

    def upper_bound(index, current_weight, current_value):
        """Calculate optimistic upper bound using fractional knapsack."""
        if current_weight > capacity:
            return 0  # Infeasible

        bound = current_value
        remaining_capacity = capacity - current_weight

        # Greedily add fractional items
        for i in range(index, n):
            if weights[i] <= remaining_capacity:
                bound += values[i]
                remaining_capacity -= weights[i]
            else:
                # Take fraction of this item
                bound += (remaining_capacity / weights[i]) * values[i]
                break

        return bound

    def branch_and_bound(index, current_weight, current_value):
        # Base case: processed all items
        if index == n:
            best_value[0] = max(best_value[0], current_value)
            return

        # PRUNING: Check if this branch can beat current best
        if upper_bound(index, current_weight, current_value) <= best_value[0]:
            return  # Prune - cannot improve

        # Branch 1: Include current item (if feasible)
        if current_weight + weights[index] <= capacity:
            branch_and_bound(
                index + 1,
                current_weight + weights[index],
                current_value + values[index]
            )

        # Branch 2: Exclude current item
        branch_and_bound(index + 1, current_weight, current_value)

    branch_and_bound(0, 0, 0)
    return best_value[0]

# Example usage:
# weights = [10, 20, 30]
# values = [60, 100, 120]
# capacity = 50
# Result: 220 (items 2 and 3)</code></pre>
                </div>

                <h4>When to Use Branch and Bound</h4>
                <ul>
                    <li><strong>Optimization problems:</strong> Finding max/min (not just feasibility)</li>
                    <li><strong>Good bound calculation:</strong> Tight bounds enable aggressive pruning</li>
                    <li><strong>NP-hard problems:</strong> Traveling Salesman, Job Scheduling, Knapsack</li>
                </ul>
            </div>
        </div>

        <!-- Full Sudoku Solver Section -->
        <h2 class="mt-4">Complete Sudoku Solver</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Sudoku Solver with Constraint Propagation</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Sudoku is a classic constraint satisfaction problem. We combine backtracking with constraint propagation for efficiency.</p>

                <div class="code-block">
                    <pre><code class="language-python">def solve_sudoku(board):
    """
    Solve Sudoku using backtracking with optimizations:
    1. Track valid candidates for each cell using sets
    2. Choose cell with fewest candidates (MRV heuristic)
    3. Propagate constraints when placing digits

    Time: O(9^(n*n)) worst case, but much better in practice
    Space: O(n*n) for the board state
    """

    def get_candidates(board, row, col):
        """Get valid digits for a cell."""
        if board[row][col] != '.':
            return set()

        candidates = set('123456789')

        # Remove digits in same row
        for c in range(9):
            candidates.discard(board[row][c])

        # Remove digits in same column
        for r in range(9):
            candidates.discard(board[r][col])

        # Remove digits in same 3x3 box
        box_row, box_col = 3 * (row // 3), 3 * (col // 3)
        for r in range(box_row, box_row + 3):
            for c in range(box_col, box_col + 3):
                candidates.discard(board[r][c])

        return candidates

    def find_empty_cell(board):
        """
        Find empty cell with fewest candidates (MRV heuristic).
        This dramatically reduces the search space.
        """
        min_candidates = 10
        best_cell = None

        for row in range(9):
            for col in range(9):
                if board[row][col] == '.':
                    candidates = get_candidates(board, row, col)
                    if len(candidates) < min_candidates:
                        min_candidates = len(candidates)
                        best_cell = (row, col, candidates)

                        # Early exit if only one candidate
                        if min_candidates == 1:
                            return best_cell

                        # No valid candidates - impossible state
                        if min_candidates == 0:
                            return (row, col, set())

        return best_cell

    def backtrack():
        cell = find_empty_cell(board)

        # No empty cells - puzzle solved!
        if cell is None:
            return True

        row, col, candidates = cell

        # No valid candidates - backtrack
        if not candidates:
            return False

        for digit in candidates:
            # Make choice
            board[row][col] = digit

            # Recurse
            if backtrack():
                return True

            # Undo choice (backtrack)
            board[row][col] = '.'

        return False

    backtrack()
    return board


# Alternative: More efficient version with precomputed constraints
class SudokuSolverOptimized:
    """
    Highly optimized Sudoku solver using:
    1. Bitmask representation for O(1) constraint checking
    2. Constraint propagation (naked singles)
    3. MRV (Minimum Remaining Values) heuristic
    """

    def __init__(self, board):
        self.board = board
        # Bitmasks: 1 if digit available, 0 if taken
        self.rows = [0b111111111] * 9  # 9 bits for digits 1-9
        self.cols = [0b111111111] * 9
        self.boxes = [0b111111111] * 9
        self.empty_cells = []

        # Initialize constraints from given numbers
        for r in range(9):
            for c in range(9):
                if board[r][c] != '.':
                    self._place(r, c, int(board[r][c]))
                else:
                    self.empty_cells.append((r, c))

    def _box_index(self, r, c):
        return (r // 3) * 3 + c // 3

    def _place(self, r, c, digit):
        """Place digit and update constraints."""
        bit = 1 << (digit - 1)
        self.rows[r] &= ~bit
        self.cols[c] &= ~bit
        self.boxes[self._box_index(r, c)] &= ~bit

    def _remove(self, r, c, digit):
        """Remove digit and restore constraints."""
        bit = 1 << (digit - 1)
        self.rows[r] |= bit
        self.cols[c] |= bit
        self.boxes[self._box_index(r, c)] |= bit

    def _get_candidates(self, r, c):
        """Get valid candidates using bitwise AND."""
        return self.rows[r] & self.cols[c] & self.boxes[self._box_index(r, c)]

    def _count_bits(self, n):
        """Count set bits (available candidates)."""
        count = 0
        while n:
            count += n & 1
            n >>= 1
        return count

    def solve(self):
        if not self.empty_cells:
            return True

        # MRV: Find cell with fewest candidates
        min_count = 10
        best_idx = 0
        for i, (r, c) in enumerate(self.empty_cells):
            candidates = self._get_candidates(r, c)
            count = self._count_bits(candidates)
            if count == 0:
                return False  # No valid digit - backtrack
            if count < min_count:
                min_count = count
                best_idx = i
                if count == 1:
                    break

        r, c = self.empty_cells.pop(best_idx)
        candidates = self._get_candidates(r, c)

        for digit in range(1, 10):
            if candidates & (1 << (digit - 1)):
                self.board[r][c] = str(digit)
                self._place(r, c, digit)

                if self.solve():
                    return True

                self._remove(r, c, digit)

        self.board[r][c] = '.'
        self.empty_cells.insert(best_idx, (r, c))
        return False</code></pre>
                </div>

                <h4>Key Optimizations Explained</h4>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: var(--border-color);">
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Technique</th>
                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">Impact</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">MRV Heuristic</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Reduces branching factor by choosing most constrained cell</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Bitmask Constraints</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">O(1) candidate lookup vs O(27) naive check</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Constraint Propagation</td>
                            <td style="padding: 0.75rem; border: 1px solid var(--border-color);">Auto-fill forced cells, detect conflicts early</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Real-World Applications Section -->
        <h2 class="mt-4">Real-World Applications at Scale</h2>

        <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; margin-bottom: 1.5rem;">
            <h3 style="color: white;">Why Backtracking Matters in Production</h3>
            <p>Backtracking powers critical systems handling billions of decisions daily. From scheduling 750K+ Amazon robots to verifying Intel CPUs with billions of gates, these algorithms run at massive scale with aggressive optimizations.</p>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Amazon Warehouse Robot Path Planning (750K+ Robots)</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Scale:</strong> Amazon operates 750,000+ robots across 175+ fulfillment centers, each making thousands of path decisions per hour.</p>

                <h4>The Problem: Multi-Agent Path Finding (MAPF)</h4>
                <p>Robots must navigate to shelves, pick items, and return to packing stations without collisions. This is a constraint satisfaction problem solved with backtracking + CBS (Conflict-Based Search).</p>

                <div class="diagram-container">
                    <!-- Interactive Amazon Robot Path Planning Animation -->
                    <div id="robot-path-animation" style="background: linear-gradient(135deg, #0c0c1e 0%, #1a1a3a 50%, #0f0f2a 100%); border-radius: 16px; padding: 25px; position: relative; overflow: hidden; min-height: 400px;">
                        <style>
                            #robot-path-animation .robot-node {
                                position: absolute;
                                padding: 12px 18px;
                                border-radius: 10px;
                                font-weight: 600;
                                font-size: 12px;
                                cursor: pointer;
                                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                                text-align: center;
                                z-index: 2;
                                white-space: nowrap;
                            }
                            #robot-path-animation .robot-node:hover {
                                transform: scale(1.08);
                                z-index: 10;
                            }
                            #robot-path-animation .robot-node.active {
                                animation: robot-pulse 0.8s ease-in-out infinite;
                            }
                            @keyframes robot-pulse {
                                0%, 100% { box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
                                50% { box-shadow: 0 4px 35px rgba(255, 165, 0, 0.7); }
                            }
                            #robot-path-animation .robot-node.conflict {
                                animation: conflict-shake 0.4s ease-in-out;
                            }
                            @keyframes conflict-shake {
                                0%, 100% { transform: translateX(0) rotate(0); }
                                25% { transform: translateX(-4px) rotate(-2deg); }
                                75% { transform: translateX(4px) rotate(2deg); }
                            }
                            #robot-path-animation .node-order { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; left: 3%; top: 50%; transform: translateY(-50%); }
                            #robot-path-animation .node-shelf { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: #1a1a2e; left: 18%; top: 50%; transform: translateY(-50%); }
                            #robot-path-animation .node-conflict { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; left: 38%; top: 50%; transform: translateY(-50%); border-radius: 50%; width: 100px; height: 45px; display: flex; align-items: center; justify-content: center; padding: 0; }
                            #robot-path-animation .node-execute { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; left: 58%; top: 25%; }
                            #robot-path-animation .node-backtrack { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); color: white; left: 58%; top: 75%; font-size: 11px; }
                            #robot-path-animation .node-constraint { background: linear-gradient(135deg, #f7971e 0%, #ffd200 100%); color: #1a1a2e; left: 75%; top: 75%; font-size: 11px; }
                            #robot-path-animation .node-retrieved { background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%); color: white; left: 82%; top: 25%; }
                            #robot-path-animation svg.robot-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
                            #robot-path-animation .robot-line { stroke: rgba(255,255,255,0.3); stroke-width: 2.5; fill: none; transition: all 0.4s; }
                            #robot-path-animation .robot-line.flow-active { stroke: #38ef7d; stroke-width: 3; filter: drop-shadow(0 0 8px #38ef7d); }
                            #robot-path-animation .robot-line.backtrack-active { stroke: #eb3349; stroke-width: 3; stroke-dasharray: 8,4; filter: drop-shadow(0 0 8px #eb3349); }
                            #robot-path-animation .robot-line.constraint-active { stroke: #ffd200; stroke-width: 3; filter: drop-shadow(0 0 8px #ffd200); }
                            #robot-path-animation .robot-arrow { fill: rgba(255,255,255,0.5); }
                            #robot-path-animation .robot-label { fill: rgba(255,255,255,0.9); font-size: 11px; font-weight: 600; }
                            #robot-path-animation .robot-controls { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 3; }
                            #robot-path-animation .robot-btn { padding: 10px 20px; border: none; border-radius: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.3s; }
                            #robot-path-animation .robot-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(102, 126, 234, 0.5); }
                            #robot-path-animation .warehouse-grid { position: absolute; top: 10px; right: 10px; width: 120px; height: 120px; background: rgba(255,255,255,0.08); border-radius: 8px; display: grid; grid-template-columns: repeat(5, 1fr); grid-template-rows: repeat(5, 1fr); gap: 2px; padding: 5px; }
                            #robot-path-animation .grid-cell { background: rgba(255,255,255,0.1); border-radius: 3px; transition: all 0.3s; }
                            #robot-path-animation .grid-cell.robot { background: #4facfe; }
                            #robot-path-animation .grid-cell.target { background: #38ef7d; }
                            #robot-path-animation .grid-cell.obstacle { background: #eb3349; }
                            #robot-path-animation .grid-cell.path { background: rgba(79, 172, 254, 0.5); }
                            #robot-path-animation .status-bar { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.1); padding: 8px 15px; border-radius: 15px; color: white; font-size: 11px; backdrop-filter: blur(5px); }
                        </style>
                        <div class="status-bar" id="robot-status">Status: Awaiting order</div>
                        <div class="warehouse-grid" id="warehouse-grid">
                            <!-- Grid cells will be generated by JS -->
                        </div>
                        <svg class="robot-lines" viewBox="0 0 500 300" preserveAspectRatio="xMidYMid meet">
                            <defs>
                                <marker id="arrowhead-robot" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" class="robot-arrow"/>
                                </marker>
                            </defs>
                            <path class="robot-line" id="robot-line-1" d="M70,150 L100,150" marker-end="url(#arrowhead-robot)"/>
                            <path class="robot-line" id="robot-line-2" d="M150,150 L190,150" marker-end="url(#arrowhead-robot)"/>
                            <path class="robot-line" id="robot-line-3" d="M270,130 L300,90" marker-end="url(#arrowhead-robot)"/>
                            <text class="robot-label" x="270" y="100">No</text>
                            <path class="robot-line" id="robot-line-4" d="M270,170 L300,210" marker-end="url(#arrowhead-robot)"/>
                            <text class="robot-label" x="265" y="200" style="fill: #f45c43;">Yes</text>
                            <path class="robot-line" id="robot-line-5" d="M365,220 L385,220" marker-end="url(#arrowhead-robot)"/>
                            <path class="robot-line" id="robot-line-6" d="M420,200 C450,170 450,160 270,145" marker-end="url(#arrowhead-robot)" stroke-dasharray="4,4"/>
                            <path class="robot-line" id="robot-line-7" d="M345,75 L390,75" marker-end="url(#arrowhead-robot)"/>
                        </svg>
                        <div class="robot-node node-order">Order Received</div>
                        <div class="robot-node node-shelf">Find Shelf</div>
                        <div class="robot-node node-conflict">Conflict?</div>
                        <div class="robot-node node-execute">Execute Path</div>
                        <div class="robot-node node-backtrack" id="robot-backtrack">Backtrack & Replan</div>
                        <div class="robot-node node-constraint" id="robot-constraint">Add Constraint</div>
                        <div class="robot-node node-retrieved">Item Retrieved!</div>
                        <div class="robot-controls">
                            <button class="robot-btn" onclick="simulateNoConflict()">No Conflict</button>
                            <button class="robot-btn" onclick="simulateConflict()" style="background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);">Conflict!</button>
                            <button class="robot-btn" onclick="resetRobotPath()">Reset</button>
                        </div>
                        <script>
                            // Initialize warehouse grid
                            (function() {
                                const grid = document.getElementById('warehouse-grid');
                                for (let i = 0; i < 25; i++) {
                                    const cell = document.createElement('div');
                                    cell.className = 'grid-cell';
                                    cell.id = 'grid-cell-' + i;
                                    grid.appendChild(cell);
                                }
                            })();

                            function updateGrid(robotPos, targetPos, obstacles, path) {
                                for (let i = 0; i < 25; i++) {
                                    document.getElementById('grid-cell-' + i).className = 'grid-cell';
                                }
                                obstacles.forEach(o => document.getElementById('grid-cell-' + o).classList.add('obstacle'));
                                path.forEach(p => document.getElementById('grid-cell-' + p).classList.add('path'));
                                if (targetPos !== null) document.getElementById('grid-cell-' + targetPos).classList.add('target');
                                if (robotPos !== null) document.getElementById('grid-cell-' + robotPos).classList.add('robot');
                            }

                            function simulateNoConflict() {
                                resetRobotPath();
                                const container = document.getElementById('robot-path-animation');
                                const nodes = container.querySelectorAll('.robot-node');
                                const status = document.getElementById('robot-status');

                                const steps = [
                                    {node: 0, line: null, status: 'Order received!', grid: {robot: 20, target: 4, obstacles: [], path: []}},
                                    {node: 1, line: 'robot-line-1', status: 'Finding shelf location...', grid: {robot: 20, target: 4, obstacles: [], path: [15, 10, 5]}},
                                    {node: 2, line: 'robot-line-2', status: 'Checking for conflicts...', grid: {robot: 15, target: 4, obstacles: [], path: [10, 5]}},
                                    {node: 3, line: 'robot-line-3', status: 'No conflict! Executing path...', grid: {robot: 10, target: 4, obstacles: [], path: [5]}},
                                    {node: 6, line: 'robot-line-7', status: 'Item retrieved successfully!', grid: {robot: 4, target: null, obstacles: [], path: []}},
                                ];

                                let step = 0;
                                const interval = setInterval(() => {
                                    nodes.forEach(n => n.classList.remove('active', 'conflict'));
                                    container.querySelectorAll('.robot-line').forEach(l => l.classList.remove('flow-active', 'backtrack-active', 'constraint-active'));

                                    if (step < steps.length) {
                                        nodes[steps[step].node].classList.add('active');
                                        if (steps[step].line) document.getElementById(steps[step].line).classList.add('flow-active');
                                        status.textContent = 'Status: ' + steps[step].status;
                                        const g = steps[step].grid;
                                        updateGrid(g.robot, g.target, g.obstacles, g.path);
                                        step++;
                                    } else {
                                        clearInterval(interval);
                                    }
                                }, 1000);
                            }

                            function simulateConflict() {
                                resetRobotPath();
                                const container = document.getElementById('robot-path-animation');
                                const nodes = container.querySelectorAll('.robot-node');
                                const status = document.getElementById('robot-status');

                                setTimeout(() => {
                                    nodes[0].classList.add('active');
                                    document.getElementById('robot-line-1').classList.add('flow-active');
                                    status.textContent = 'Status: Order received!';
                                    updateGrid(20, 4, [], []);
                                }, 500);

                                setTimeout(() => {
                                    nodes[1].classList.add('active');
                                    document.getElementById('robot-line-2').classList.add('flow-active');
                                    status.textContent = 'Status: Finding shelf...';
                                    updateGrid(20, 4, [11, 12], [15, 10, 5]);
                                }, 1200);

                                setTimeout(() => {
                                    nodes[2].classList.add('active');
                                    status.textContent = 'Status: CONFLICT DETECTED!';
                                    nodes[2].classList.add('conflict');
                                    updateGrid(15, 4, [11, 12, 10], [5]);
                                }, 1900);

                                setTimeout(() => {
                                    document.getElementById('robot-line-4').classList.add('backtrack-active');
                                    document.getElementById('robot-backtrack').classList.add('active');
                                    status.textContent = 'Status: Backtracking...';
                                    updateGrid(15, 4, [11, 12, 10], []);
                                }, 2600);

                                setTimeout(() => {
                                    document.getElementById('robot-line-5').classList.add('constraint-active');
                                    document.getElementById('robot-constraint').classList.add('active');
                                    status.textContent = 'Status: Adding constraint, replanning...';
                                    updateGrid(15, 4, [11, 12, 10], [16, 17, 18, 13, 8, 3]);
                                }, 3300);

                                setTimeout(() => {
                                    document.getElementById('robot-line-6').classList.add('flow-active');
                                    nodes[2].classList.add('active');
                                    status.textContent = 'Status: New path found! Executing...';
                                    updateGrid(8, 4, [11, 12, 10], [3]);
                                }, 4000);

                                setTimeout(() => {
                                    document.getElementById('robot-line-3').classList.add('flow-active');
                                    nodes[3].classList.add('active');
                                    updateGrid(3, 4, [11, 12, 10], []);
                                }, 4700);

                                setTimeout(() => {
                                    document.getElementById('robot-line-7').classList.add('flow-active');
                                    nodes[6].classList.add('active');
                                    status.textContent = 'Status: Item retrieved after replanning!';
                                    updateGrid(4, null, [11, 12, 10], []);
                                }, 5400);
                            }

                            function resetRobotPath() {
                                const container = document.getElementById('robot-path-animation');
                                container.querySelectorAll('.robot-node').forEach(n => n.classList.remove('active', 'conflict'));
                                container.querySelectorAll('.robot-line').forEach(l => l.classList.remove('flow-active', 'backtrack-active', 'constraint-active'));
                                document.getElementById('robot-status').textContent = 'Status: Awaiting order';
                                updateGrid(null, null, [], []);
                            }
                        </script>
                    </div>
                </div>

                <div class="code-block">
                    <pre><code class="language-python"># Simplified Multi-Agent Path Finding with Conflict-Based Search
# Similar approach used in Amazon robotics

class WarehousePathPlanner:
    """
    Constraint-based backtracking for warehouse robot coordination.
    Scale: Amazon plans ~10,000 paths/second per warehouse.
    """

    def __init__(self, grid_size, obstacles):
        self.grid = grid_size  # Typically 100x100+ cells
        self.obstacles = set(obstacles)
        self.reservation_table = {}  # (x, y, time) -> robot_id

    def find_path(self, robot_id, start, goal, constraints=None):
        """
        A* with time dimension + backtracking on conflicts.
        Constraints: set of (x, y, time) that robot must avoid.
        """
        if constraints is None:
            constraints = set()

        # State: (x, y, time)
        # Using A* with backtracking when conflicts detected
        from heapq import heappush, heappop

        def heuristic(pos):
            return abs(pos[0] - goal[0]) + abs(pos[1] - goal[1])

        # Priority queue: (f_score, time, x, y, path)
        pq = [(heuristic(start), 0, start[0], start[1], [start])]
        visited = set()

        while pq:
            _, time, x, y, path = heappop(pq)

            if (x, y) == goal:
                return path

            if (x, y, time) in visited:
                continue
            visited.add((x, y, time))

            # Try all moves: stay, up, down, left, right
            for dx, dy in [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = x + dx, y + dy
                next_time = time + 1

                # Check constraints (from higher-priority robots)
                if (nx, ny, next_time) in constraints:
                    continue  # BACKTRACK - conflict with constraint

                # Check bounds and obstacles
                if not (0 <= nx < self.grid[0] and 0 <= ny < self.grid[1]):
                    continue
                if (nx, ny) in self.obstacles:
                    continue

                f_score = next_time + heuristic((nx, ny))
                heappush(pq, (f_score, next_time, nx, ny, path + [(nx, ny)]))

        return None  # No path found - triggers replanning

    def resolve_conflicts(self, paths):
        """
        CBS-style conflict resolution using backtracking.
        When robots collide, add constraints and replan.
        """
        for i, path_i in enumerate(paths):
            for j, path_j in enumerate(paths[i+1:], i+1):
                # Check for vertex and edge conflicts
                for t in range(min(len(path_i), len(path_j))):
                    if path_i[t] == path_j[t]:
                        # Vertex conflict - one robot must wait
                        return ('vertex', i, j, path_i[t], t)
        return None  # No conflicts</code></pre>
                </div>

                <h4>Key Insight: Constraint Propagation at Scale</h4>
                <p>Amazon's system uses hierarchical planning: high-level assigns zones, low-level handles path finding. When conflicts occur, the system backtracks to try alternative assignments, propagating constraints down.</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Google/Microsoft Meeting Scheduler (Billions of Constraints)</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Scale:</strong> Google Calendar processes 500M+ users, scheduling millions of meetings daily with complex constraints (attendee availability, room capacity, timezone, recurring patterns).</p>

                <div class="code-block">
                    <pre><code class="language-python"># Meeting scheduler using backtracking with constraint propagation
# Similar to Google Calendar's Speedy Meetings / Find Time features

class MeetingScheduler:
    """
    Production meeting scheduling with backtracking.
    Handles: availability, rooms, priorities, timezones.
    """

    def __init__(self):
        self.calendars = {}  # user_id -> set of busy slots
        self.rooms = {}      # room_id -> {capacity, busy_slots}

    def schedule_meeting(self, attendees, duration, time_range,
                         room_required=True, priority='normal'):
        """
        Find slot where all attendees are free.
        Uses backtracking with constraint propagation.

        Args:
            attendees: List of user IDs (required + optional)
            duration: Meeting length in minutes
            time_range: (start_date, end_date) to search
            room_required: Whether physical room needed
            priority: 'high' allows suggesting time swaps
        """
        required = attendees['required']
        optional = attendees.get('optional', [])

        # Generate candidate slots (e.g., 30-min increments)
        candidates = self._generate_slots(time_range, duration)

        # Sort by optimization criteria (working hours, attendee preferences)
        candidates.sort(key=lambda s: self._slot_score(s, required))

        for slot in candidates:
            # Check constraints for this slot
            conflicts = self._check_conflicts(slot, duration, required)

            if not conflicts:
                # All required attendees free
                if room_required:
                    room = self._find_room(slot, duration, len(required))
                    if room:
                        return {'slot': slot, 'room': room, 'conflicts': []}
                else:
                    return {'slot': slot, 'room': None, 'conflicts': []}

            # BACKTRACKING: If high priority, try to resolve conflicts
            if priority == 'high' and len(conflicts) <= 2:
                resolution = self._try_resolve_conflicts(
                    slot, duration, conflicts
                )
                if resolution:
                    return resolution

        # No slot found - suggest alternatives
        return self._suggest_alternatives(required, duration, time_range)

    def _check_conflicts(self, slot, duration, attendees):
        """Check which attendees have conflicts."""
        conflicts = []
        end_time = slot + duration

        for user_id in attendees:
            busy = self.calendars.get(user_id, set())
            for busy_start, busy_end in busy:
                # Overlap check
                if not (end_time <= busy_start or slot >= busy_end):
                    conflicts.append({
                        'user': user_id,
                        'conflict': (busy_start, busy_end)
                    })
                    break

        return conflicts

    def _try_resolve_conflicts(self, slot, duration, conflicts):
        """
        Backtracking: Try to move conflicting meetings.
        Only for high-priority meetings (exec scheduling).
        """
        for conflict in conflicts:
            # Can the conflicting meeting be rescheduled?
            alt_slot = self._find_alternative_for_meeting(
                conflict['conflict'],
                conflict['user']
            )
            if alt_slot:
                return {
                    'slot': slot,
                    'requires_reschedule': [{
                        'user': conflict['user'],
                        'move_to': alt_slot
                    }]
                }
        return None</code></pre>
                </div>

                <h4>Production Optimizations</h4>
                <ul>
                    <li><strong>Interval trees:</strong> O(log n) availability queries instead of scanning all events</li>
                    <li><strong>Caching:</strong> Pre-compute "free/busy" blocks per user</li>
                    <li><strong>Pruning:</strong> Skip weekends, holidays, outside working hours early</li>
                    <li><strong>Constraint propagation:</strong> If one required attendee only has 2 free slots, check those first</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Industry Applications of Backtracking</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. Google Maps Route Planning</h4>
                <p>Google processes over 1 billion kilometers of directions daily. While A* handles most cases, complex multi-stop routes use constraint-based backtracking with aggressive pruning:</p>
                <ul>
                    <li>Vehicle routing with time windows (delivery scheduling)</li>
                    <li>Multi-modal transportation optimization</li>
                    <li>Real-time traffic constraint propagation</li>
                </ul>

                <h4>2. Compiler Register Allocation</h4>
                <p>LLVM and GCC use graph coloring with backtracking for register allocation. Modern CPUs have 16-32 general-purpose registers, and optimal allocation directly impacts performance:</p>
                <ul>
                    <li>Variables as nodes, conflicts as edges</li>
                    <li>Colors represent physical registers</li>
                    <li>Backtracking when greedy coloring fails</li>
                </ul>

                <div class="code-block">
                    <pre><code class="language-python"># Register allocation via graph coloring (simplified LLVM approach)
# Backtracking when greedy coloring fails

class RegisterAllocator:
    """
    Simplified register allocation using graph coloring with backtracking.
    Real compilers (GCC, LLVM) use this for x86-64's 16 general-purpose registers.
    """

    def __init__(self, num_registers=16):
        self.num_registers = num_registers  # x86-64 has 16 GP registers
        self.interference_graph = {}  # variable -> set of conflicting variables

    def build_interference_graph(self, live_ranges):
        """
        Build graph where edges = variables that are live simultaneously.
        Two variables that interfere cannot share a register.
        """
        for var, (start, end) in live_ranges.items():
            self.interference_graph[var] = set()

            for other_var, (other_start, other_end) in live_ranges.items():
                if var != other_var:
                    # Check if live ranges overlap
                    if not (end < other_start or start > other_end):
                        self.interference_graph[var].add(other_var)

    def allocate(self):
        """
        Allocate registers using graph coloring with backtracking.
        Returns: {variable: register_number} or None if impossible.
        """
        variables = list(self.interference_graph.keys())
        assignment = {}

        def backtrack(var_idx):
            if var_idx == len(variables):
                return True  # All variables assigned

            var = variables[var_idx]
            neighbors = self.interference_graph[var]

            # Find used registers among neighbors
            used_registers = {
                assignment[n] for n in neighbors if n in assignment
            }

            # Try each available register
            for reg in range(self.num_registers):
                if reg not in used_registers:
                    assignment[var] = reg

                    if backtrack(var_idx + 1):
                        return True

                    # BACKTRACK: remove assignment
                    del assignment[var]

            return False  # Need to spill to memory

        # Order by degree (most constrained first - MRV heuristic)
        variables.sort(
            key=lambda v: len(self.interference_graph[v]),
            reverse=True
        )

        if backtrack(0):
            return assignment
        return None  # Some variables must spill to stack</code></pre>
                </div>

                <h4>3. SAT Solvers (Boolean Satisfiability)</h4>
                <p>Modern SAT solvers (MiniSat, Z3) power critical infrastructure. Used in:</p>
                <ul>
                    <li>Hardware verification at Intel/AMD (billions of gate combinations)</li>
                    <li>Cryptographic analysis</li>
                    <li>Package dependency resolution (apt, npm, pip)</li>
                </ul>
                <p>DPLL algorithm combines backtracking with unit propagation, solving industrial instances with millions of variables.</p>

                <h4>4. npm/pip Dependency Resolution</h4>
                <p><strong>Scale:</strong> npm handles 2+ billion package downloads per week, resolving complex version constraints.</p>

                <div class="code-block">
                    <pre><code class="language-python"># Simplified package dependency resolver (npm/pip style)
# Uses backtracking when version conflicts arise

class DependencyResolver:
    """
    Resolve package dependencies with version constraints.
    npm, pip, and cargo all use variations of this approach.

    Scale: npm resolves billions of installs weekly with trees
    having 1000+ transitive dependencies.
    """

    def __init__(self, registry):
        self.registry = registry  # package -> {version -> dependencies}

    def resolve(self, requirements):
        """
        Resolve all dependencies, returning locked versions.
        Uses backtracking on version conflicts.

        Args:
            requirements: {"react": "^18.0.0", "lodash": ">=4.0"}
        Returns:
            {"react": "18.2.0", "lodash": "4.17.21", ...}
        """
        locked = {}  # package -> resolved version
        constraints = {}  # package -> list of version constraints

        def add_constraint(package, constraint, source):
            if package not in constraints:
                constraints[package] = []
            constraints[package].append((constraint, source))

        def satisfies_all(package, version):
            """Check if version satisfies all constraints."""
            for constraint, _ in constraints.get(package, []):
                if not self._version_satisfies(version, constraint):
                    return False
            return True

        def backtrack(packages_to_resolve):
            if not packages_to_resolve:
                return True  # All resolved

            package = packages_to_resolve.pop()

            # Get available versions (newest first)
            versions = self.registry.get_versions(package)
            versions.sort(reverse=True)  # Try newest first

            for version in versions:
                if not satisfies_all(package, version):
                    continue  # Skip - doesn't satisfy constraints

                # Try this version
                locked[package] = version

                # Add transitive dependencies
                deps = self.registry.get_dependencies(package, version)
                new_packages = []

                for dep_pkg, dep_constraint in deps.items():
                    add_constraint(dep_pkg, dep_constraint,
                                   f"{package}@{version}")

                    if dep_pkg in locked:
                        # Already locked - check compatibility
                        if not satisfies_all(dep_pkg, locked[dep_pkg]):
                            # CONFLICT - backtrack
                            self._remove_constraints(package, version)
                            del locked[package]
                            continue
                    else:
                        new_packages.append(dep_pkg)

                # Recurse with new dependencies
                if backtrack(packages_to_resolve + new_packages):
                    return True

                # BACKTRACK
                self._remove_constraints(package, version)
                del locked[package]

            packages_to_resolve.append(package)  # Put back
            return False

        # Add root constraints
        for package, constraint in requirements.items():
            add_constraint(package, constraint, "root")

        if backtrack(list(requirements.keys())):
            return locked
        raise Exception("Could not resolve dependencies")</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Uber/Lyft Driver-Rider Matching</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Scale:</strong> Uber processes 17+ million trips daily, matching drivers and riders with constraints on location, time, vehicle type, and driver ratings.</p>

                <div class="code-block">
                    <pre><code class="language-python"># Batch matching with backtracking for ride-sharing optimization
# Similar to Uber Pool / Lyft Shared matching

class RideShareMatcher:
    """
    Match riders to drivers with constraints.
    Backtracking used when greedy matching leaves riders unserved.

    Scale: Uber matches 17M+ rides/day across 10K+ cities.
    """

    def __init__(self, max_detour_minutes=10):
        self.max_detour = max_detour_minutes

    def batch_match(self, riders, drivers):
        """
        Match batch of riders to available drivers.
        Objective: Minimize total wait time while respecting constraints.

        Uses backtracking when greedy assignment is suboptimal.
        """
        # Sort riders by request time (FIFO fairness)
        riders = sorted(riders, key=lambda r: r['request_time'])

        assignment = {}  # rider_id -> driver_id
        driver_capacity = {d['id']: d['capacity'] for d in drivers}

        def estimate_pickup_time(driver, rider):
            """ETA considering current route and traffic."""
            # Real systems use ML models for accurate ETAs
            return self._calculate_eta(
                driver['current_location'],
                rider['pickup_location'],
                driver.get('current_route', [])
            )

        def can_add_rider(driver, new_rider, current_riders):
            """Check if adding rider keeps detour within limits."""
            if driver_capacity[driver['id']] <= len(current_riders):
                return False

            # Calculate detour for existing riders
            new_route = self._optimize_route(
                driver['current_location'],
                [r['pickup_location'] for r in current_riders + [new_rider]],
                [r['dropoff_location'] for r in current_riders + [new_rider]]
            )

            for existing in current_riders:
                original_eta = existing['original_eta']
                new_eta = self._eta_in_route(new_route, existing['dropoff_location'])
                if new_eta - original_eta > self.max_detour:
                    return False  # Detour too long for existing rider

            return True

        def backtrack(rider_idx, current_assignment, rider_groups):
            if rider_idx == len(riders):
                return True  # All riders assigned

            rider = riders[rider_idx]

            # Try each driver (sorted by proximity)
            nearby_drivers = self._get_nearby_drivers(
                rider['pickup_location'], drivers
            )

            for driver in nearby_drivers:
                current_riders = rider_groups.get(driver['id'], [])

                if can_add_rider(driver, rider, current_riders):
                    # Make assignment
                    current_assignment[rider['id']] = driver['id']
                    rider_groups.setdefault(driver['id'], []).append(rider)

                    if backtrack(rider_idx + 1, current_assignment, rider_groups):
                        return True

                    # BACKTRACK
                    del current_assignment[rider['id']]
                    rider_groups[driver['id']].remove(rider)

            # Try leaving rider unmatched (will retry next batch)
            return backtrack(rider_idx + 1, current_assignment, rider_groups)

        rider_groups = {}
        backtrack(0, assignment, rider_groups)
        return assignment</code></pre>
                </div>
            </div>
        </div>

                <div class="code-block">
                    <pre><code class="language-python"># Simplified DPLL (basis of modern SAT solvers)
def dpll(clauses, assignment=None):
    """
    Davis-Putnam-Logemann-Loveland algorithm.
    Core of SAT solvers that verify Intel CPUs, prove theorems,
    and resolve package dependencies.
    """
    if assignment is None:
        assignment = {}

    # Unit propagation: if clause has one literal, must be true
    changed = True
    while changed:
        changed = False
        for clause in clauses:
            unassigned = [lit for lit in clause
                         if abs(lit) not in assignment]

            if not unassigned:
                # All literals false - clause unsatisfied
                if all(assignment.get(abs(lit), lit < 0) == (lit < 0)
                       for lit in clause):
                    return None  # Conflict - backtrack

            elif len(unassigned) == 1:
                # Unit clause - force assignment
                lit = unassigned[0]
                assignment[abs(lit)] = lit > 0
                changed = True

    # Check if all clauses satisfied
    if all(any(assignment.get(abs(lit), None) == (lit > 0)
               for lit in clause) for clause in clauses):
        return assignment

    # Pick unassigned variable (VSIDS heuristic in real solvers)
    unassigned_vars = set()
    for clause in clauses:
        for lit in clause:
            if abs(lit) not in assignment:
                unassigned_vars.add(abs(lit))

    if not unassigned_vars:
        return None

    var = next(iter(unassigned_vars))

    # Try True
    assignment[var] = True
    result = dpll(clauses, assignment.copy())
    if result:
        return result

    # Backtrack, try False
    assignment[var] = False
    return dpll(clauses, assignment.copy())</code></pre>
                </div>
            </div>
        </div>

        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Interview Follow-up Questions Section -->
        <h2 class="mt-4">Interview Follow-up Questions</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Common Follow-ups & What Interviewers Look For</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. "How would you optimize this backtracking solution?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Mention specific pruning strategies (constraint propagation, bounds)</li>
                    <li>Discuss ordering heuristics (most constrained variable first)</li>
                    <li>Consider memoization if subproblems overlap</li>
                </ul>
                <p><strong>Red flags:</strong> Only suggesting "use DP instead" without understanding when backtracking is necessary (constraint satisfaction vs optimization).</p>

                <h4>2. "What's the time complexity? Can you prove it?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Branching factor analysis (e.g., N-Queens: up to N choices per row)</li>
                    <li>Depth of recursion tree</li>
                    <li>Impact of pruning on average case vs worst case</li>
                </ul>
                <p><strong>Red flags:</strong> Saying "exponential" without specifics. Know that N-Queens is O(N!) worst case but often much better due to pruning.</p>

                <h4>3. "How would you handle duplicate elements in the input?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Sort first to group duplicates</li>
                    <li>Skip duplicates at the same recursion level: <code>if i > start and nums[i] == nums[i-1]: continue</code></li>
                    <li>Explain WHY this works (same element at same position produces identical subtree)</li>
                </ul>
                <p><strong>Red flags:</strong> Using a set to deduplicate results (inefficient), not understanding why sorting helps.</p>

                <h4>4. "Can you solve this iteratively instead of recursively?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Understanding that backtracking = DFS with pruning</li>
                    <li>Explicit stack to track state (choice + position)</li>
                    <li>Manual backtracking when popping from stack</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing recursion can always be converted to iteration with explicit stack.</p>

                <h4>5. "What if we need the optimal solution, not just any valid one?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Transition from backtracking to branch-and-bound</li>
                    <li>Maintain global best and prune branches that can't improve</li>
                    <li>Discuss bound calculation strategies</li>
                </ul>
                <p><strong>Red flags:</strong> Not distinguishing between satisfiability (any solution) and optimization (best solution).</p>
            </div>
        </div>

        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Medium</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/subsets/" target="_blank">Subsets (LeetCode #78)</a></li>
                <li><a href="https://leetcode.com/problems/permutations/" target="_blank">Permutations (LeetCode #46)</a></li>
                <li><a href="https://leetcode.com/problems/combination-sum/" target="_blank">Combination Sum (LeetCode #39)</a></li>
                <li><a href="https://leetcode.com/problems/word-search/" target="_blank">Word Search (LeetCode #79)</a></li>
            </ul>
            <h4 class="mt-3">Hard</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/n-queens/" target="_blank">N-Queens (LeetCode #51)</a></li>
                <li><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank">Sudoku Solver (LeetCode #37)</a></li>
            </ul>
        </div>

        <div class="flex flex-between mt-4">
            <a href="module-05.html" class="btn btn-secondary">&larr; Module 5</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Sidebar toggle for mobile
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            // Update sidebar links based on completion status
            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('coding', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "What is the key difference between permutations and combinations?",
                    options: ["Size of output", "Order matters in permutations", "Time complexity", "Input type"],
                    correct: 1,
                    explanation: "Permutations consider order (ABC ≠ CBA), combinations don't ({A,B,C} = {C,B,A})."
                },
                {
                    question: "Why do we 'undo the choice' in backtracking?",
                    options: ["To save memory", "To explore other branches", "Required by Python", "For efficiency"],
                    correct: 1,
                    explanation: "Undoing allows us to try other choices from the same position, exploring the full solution space."
                },
                {
                    question: "What is the MRV (Minimum Remaining Values) heuristic in backtracking?",
                    options: ["Choose the largest value first", "Choose the variable with fewest valid options", "Minimize recursion depth", "Maximize pruning opportunities"],
                    correct: 1,
                    explanation: "MRV chooses the most constrained variable (fewest valid choices), causing failures earlier and reducing search space."
                },
                {
                    question: "How does branch-and-bound differ from regular backtracking?",
                    options: ["It uses iteration instead of recursion", "It maintains bounds to prune non-optimal branches", "It only works on graphs", "It doesn't undo choices"],
                    correct: 1,
                    explanation: "Branch-and-bound extends backtracking for optimization by pruning branches that cannot improve the best solution found."
                }
            ];
            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });
        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 6);
            alert('Module 6 marked as complete!');
            window.location.href = 'module-07.html';
        }
    </script>
</body>
</html>
