<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 5: Dynamic Programming - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <nav style="margin-bottom: 1rem;">
            <a href="index.html">&larr; Back to Coding Rounds</a>
        </nav>

        <h1>Module 5: Dynamic Programming</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Identify when a problem can be solved with DP</li>
                <li>Design state representations for DP problems</li>
                <li>Implement both memoization and tabulation approaches</li>
                <li>Optimize space complexity in DP solutions</li>
            </ul>
        </div>

        <!-- DP Identification -->
        <h2 class="mt-4">Identifying DP Problems</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Key Properties</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>A problem can be solved with DP if it has:</p>

                <div class="diagram-container">
                    <div class="mermaid">
flowchart TD
    A[DP Problem] --> B[Overlapping Subproblems]
    A --> C[Optimal Substructure]
    B --> D["Same subproblems<br>solved multiple times"]
    C --> E["Optimal solution built from<br>optimal sub-solutions"]
                    </div>
                </div>

                <h4>Common DP Signals</h4>
                <ul>
                    <li>"Find the minimum/maximum..."</li>
                    <li>"Count the number of ways..."</li>
                    <li>"Is it possible to..."</li>
                    <li>"Find the longest/shortest..."</li>
                </ul>
            </div>
        </div>

        <!-- 1D DP -->
        <h2 class="mt-4">1D Dynamic Programming</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Climbing Stairs & House Robber</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code># Climbing Stairs: Ways to reach step n (1 or 2 steps)
def climb_stairs(n):
    if n <= 2:
        return n

    # dp[i] = ways to reach step i
    prev2, prev1 = 1, 2  # Space optimized

    for i in range(3, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr

    return prev1

# House Robber: Max money without robbing adjacent houses
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]

    # dp[i] = max money robbing from houses 0..i
    prev2, prev1 = nums[0], max(nums[0], nums[1])

    for i in range(2, len(nums)):
        curr = max(prev1, prev2 + nums[i])
        prev2, prev1 = prev1, curr

    return prev1</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Coin Change</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>def coin_change(coins, amount):
    """
    Minimum coins to make amount.
    dp[i] = minimum coins needed to make amount i
    """
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base case: 0 coins for amount 0

    for a in range(1, amount + 1):
        for coin in coins:
            if coin <= a and dp[a - coin] != float('inf'):
                dp[a] = min(dp[a], dp[a - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# Example: coins = [1, 2, 5], amount = 11
# dp = [0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3]
# Answer: 3 (5 + 5 + 1)</code></pre>
                </div>
            </div>
        </div>

        <!-- 2D DP -->
        <h2 class="mt-4">2D Dynamic Programming</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Longest Common Subsequence</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>def longest_common_subsequence(text1, text2):
    """
    dp[i][j] = LCS length of text1[:i] and text2[:j]
    Time: O(m*n), Space: O(m*n) or O(min(m,n)) optimized
    """
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

# Example: "abcde", "ace" -> 3 ("ace")</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Edit Distance</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>def edit_distance(word1, word2):
    """
    Minimum operations to convert word1 to word2.
    Operations: insert, delete, replace
    dp[i][j] = edit distance between word1[:i] and word2[:j]
    """
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Base cases
    for i in range(m + 1):
        dp[i][0] = i  # Delete all characters
    for j in range(n + 1):
        dp[0][j] = j  # Insert all characters

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]  # No operation needed
            else:
                dp[i][j] = 1 + min(
                    dp[i-1][j],    # Delete
                    dp[i][j-1],    # Insert
                    dp[i-1][j-1]   # Replace
                )

    return dp[m][n]</code></pre>
                </div>
            </div>
        </div>

        <!-- Knapsack Pattern -->
        <h2 class="mt-4">Knapsack Pattern</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>0/1 Knapsack</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>def knapsack(weights, values, capacity):
    """
    Max value with weight limit. Each item used at most once.
    dp[i][w] = max value using items 0..i with capacity w
    """
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # Don't take item i
            dp[i][w] = dp[i-1][w]

            # Take item i (if it fits)
            if weights[i-1] <= w:
                dp[i][w] = max(
                    dp[i][w],
                    dp[i-1][w - weights[i-1]] + values[i-1]
                )

    return dp[n][capacity]

# Space optimized (single array)
def knapsack_optimized(weights, values, capacity):
    dp = [0] * (capacity + 1)

    for i in range(len(weights)):
        # Traverse backward to avoid using same item twice
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])

    return dp[capacity]</code></pre>
                </div>
            </div>
        </div>

        <!-- Pattern Recognition -->
        <h2 class="mt-4">DP Pattern Recognition</h2>

        <div class="diagram-container">
            <div class="mermaid">
flowchart TD
    A[DP Problem] --> B{Linear sequence?}
    B -->|Yes| C{Decision at each step?}
    B -->|No| D{Two sequences?}

    C -->|Yes| E["1D DP<br>House Robber"]
    C -->|No| F["1D DP Linear<br>Climbing Stairs"]

    D -->|Yes| G["2D String DP<br>LCS, Edit Distance"]
    D -->|No| H{Subset/Partition?}

    H -->|Yes| I["Knapsack Pattern"]
    H -->|No| J{Grid?}

    J -->|Yes| K["2D Grid DP<br>Unique Paths"]
            </div>
        </div>

        <!-- Quiz Section -->
        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Practice Problems -->
        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Easy</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank">Climbing Stairs (LeetCode #70)</a></li>
                <li><a href="https://leetcode.com/problems/house-robber/" target="_blank">House Robber (LeetCode #198)</a></li>
            </ul>

            <h4 class="mt-3">Medium</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/coin-change/" target="_blank">Coin Change (LeetCode #322)</a></li>
                <li><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank">Longest Increasing Subsequence (LeetCode #300)</a></li>
                <li><a href="https://leetcode.com/problems/unique-paths/" target="_blank">Unique Paths (LeetCode #62)</a></li>
                <li><a href="https://leetcode.com/problems/word-break/" target="_blank">Word Break (LeetCode #139)</a></li>
            </ul>

            <h4 class="mt-3">Hard</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/edit-distance/" target="_blank">Edit Distance (LeetCode #72)</a></li>
                <li><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank">Longest Common Subsequence (LeetCode #1143)</a></li>
            </ul>
        </div>

        <!-- Navigation -->
        <div class="flex flex-between mt-4">
            <a href="module-04.html" class="btn btn-secondary">&larr; Module 4</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const quizQuestions = [
                {
                    question: "What are the two key properties of DP problems?",
                    options: [
                        "Sorted input and unique elements",
                        "Overlapping subproblems and optimal substructure",
                        "Linear time and constant space",
                        "Binary decisions and greedy choices"
                    ],
                    correct: 1,
                    explanation: "DP requires overlapping subproblems (same problems solved multiple times) and optimal substructure (optimal solution from optimal sub-solutions)."
                },
                {
                    question: "In the knapsack problem, why traverse backward in the space-optimized solution?",
                    options: [
                        "It's faster",
                        "To avoid using the same item twice",
                        "To maintain sorted order",
                        "Required by Python"
                    ],
                    correct: 1,
                    explanation: "Backward traversal ensures we use the previous row's values, preventing using an item multiple times."
                },
                {
                    question: "What's the recurrence relation for Coin Change?",
                    options: [
                        "dp[i] = dp[i-1] + dp[i-2]",
                        "dp[i] = min(dp[i-coin] + 1) for all coins",
                        "dp[i] = max(dp[i-1], dp[i-2] + nums[i])",
                        "dp[i][j] = dp[i-1][j-1] + 1"
                    ],
                    correct: 1,
                    explanation: "For each amount, try all coins and take the minimum."
                }
            ];

            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 5);
            alert('Module 5 marked as complete!');
            window.location.href = 'module-06.html';
        }
    </script>
</body>
</html>
