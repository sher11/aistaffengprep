<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 5: Dynamic Programming - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Fundamentals</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Foundations
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Arrays & Two Pointers
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Patterns</div>
                    <a href="module-03.html" class="sidebar-link" data-module="3">
                        <span class="sidebar-link-number">3</span>Trees & Binary Search
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Graphs
                    </a>
                    <a href="module-05.html" class="sidebar-link active" data-module="5">
                        <span class="sidebar-link-number">5</span>Dynamic Programming
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Advanced</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">6</span>Backtracking
                    </a>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">7</span>Heaps & Sorting
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">8</span>Non-LeetCode Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">9</span>Interview Simulation
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">â˜°</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Main Content -->
        <main class="main-content">
        <h1>Module 5: Dynamic Programming</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Identify when a problem can be solved with DP</li>
                <li>Design state representations for DP problems</li>
                <li>Implement both memoization and tabulation approaches</li>
                <li>Optimize space complexity in DP solutions</li>
            </ul>
        </div>

        <!-- DP Identification -->
        <h2 class="mt-4">Identifying DP Problems</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Key Properties</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>A problem can be solved with DP if it has:</p>

                <div class="diagram-container">
                    <div class="mermaid">
flowchart TD
    A[DP Problem] --> B[Overlapping Subproblems]
    A --> C[Optimal Substructure]
    B --> D["Same subproblems<br>solved multiple times"]
    C --> E["Optimal solution built from<br>optimal sub-solutions"]
                    </div>
                </div>

                <h4>Common DP Signals</h4>
                <ul>
                    <li>"Find the minimum/maximum..."</li>
                    <li>"Count the number of ways..."</li>
                    <li>"Is it possible to..."</li>
                    <li>"Find the longest/shortest..."</li>
                </ul>
            </div>
        </div>

        <!-- 1D DP -->
        <h2 class="mt-4">1D Dynamic Programming</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Climbing Stairs & House Robber</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code># Climbing Stairs: Ways to reach step n (1 or 2 steps)
def climb_stairs(n):
    if n <= 2:
        return n

    # dp[i] = ways to reach step i
    prev2, prev1 = 1, 2  # Space optimized

    for i in range(3, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr

    return prev1

# House Robber: Max money without robbing adjacent houses
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]

    # dp[i] = max money robbing from houses 0..i
    prev2, prev1 = nums[0], max(nums[0], nums[1])

    for i in range(2, len(nums)):
        curr = max(prev1, prev2 + nums[i])
        prev2, prev1 = prev1, curr

    return prev1</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Coin Change</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>def coin_change(coins, amount):
    """
    Minimum coins to make amount.
    dp[i] = minimum coins needed to make amount i
    """
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base case: 0 coins for amount 0

    for a in range(1, amount + 1):
        for coin in coins:
            if coin <= a and dp[a - coin] != float('inf'):
                dp[a] = min(dp[a], dp[a - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# Example: coins = [1, 2, 5], amount = 11
# dp = [0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3]
# Answer: 3 (5 + 5 + 1)</code></pre>
                </div>
            </div>
        </div>

        <!-- 2D DP -->
        <h2 class="mt-4">2D Dynamic Programming</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Longest Common Subsequence</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>def longest_common_subsequence(text1, text2):
    """
    dp[i][j] = LCS length of text1[:i] and text2[:j]
    Time: O(m*n), Space: O(m*n) or O(min(m,n)) optimized
    """
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

# Example: "abcde", "ace" -> 3 ("ace")</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Edit Distance</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>def edit_distance(word1, word2):
    """
    Minimum operations to convert word1 to word2.
    Operations: insert, delete, replace
    dp[i][j] = edit distance between word1[:i] and word2[:j]
    """
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Base cases
    for i in range(m + 1):
        dp[i][0] = i  # Delete all characters
    for j in range(n + 1):
        dp[0][j] = j  # Insert all characters

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]  # No operation needed
            else:
                dp[i][j] = 1 + min(
                    dp[i-1][j],    # Delete
                    dp[i][j-1],    # Insert
                    dp[i-1][j-1]   # Replace
                )

    return dp[m][n]</code></pre>
                </div>
            </div>
        </div>

        <!-- Knapsack Pattern -->
        <h2 class="mt-4">Knapsack Pattern</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>0/1 Knapsack</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code>def knapsack(weights, values, capacity):
    """
    Max value with weight limit. Each item used at most once.
    dp[i][w] = max value using items 0..i with capacity w
    """
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # Don't take item i
            dp[i][w] = dp[i-1][w]

            # Take item i (if it fits)
            if weights[i-1] <= w:
                dp[i][w] = max(
                    dp[i][w],
                    dp[i-1][w - weights[i-1]] + values[i-1]
                )

    return dp[n][capacity]

# Space optimized (single array)
def knapsack_optimized(weights, values, capacity):
    dp = [0] * (capacity + 1)

    for i in range(len(weights)):
        # Traverse backward to avoid using same item twice
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])

    return dp[capacity]</code></pre>
                </div>
            </div>
        </div>

        <!-- Pattern Recognition -->
        <h2 class="mt-4">DP Pattern Recognition</h2>

        <div class="diagram-container">
            <div class="mermaid">
flowchart TD
    A[DP Problem] --> B{Linear sequence?}
    B -->|Yes| C{Decision at each step?}
    B -->|No| D{Two sequences?}

    C -->|Yes| E["1D DP<br>House Robber"]
    C -->|No| F["1D DP Linear<br>Climbing Stairs"]

    D -->|Yes| G["2D String DP<br>LCS, Edit Distance"]
    D -->|No| H{Subset/Partition?}

    H -->|Yes| I["Knapsack Pattern"]
    H -->|No| J{Grid?}

    J -->|Yes| K["2D Grid DP<br>Unique Paths"]
            </div>
        </div>

        <!-- Real-World Scale Examples -->
        <h2 class="mt-4">Real-World Scale Examples</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Netflix/Spotify: Recommendation Systems Using DP</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Netflix's recommendation engine generates $1B+ in annual value. Spotify's Discover Weekly reaches 100M+ listeners. Both use dynamic programming in their recommendation pipelines.</p>

                <h4>Sequence Alignment for Music Playlists</h4>
                <p>Finding similar listening patterns between users is essentially a variant of Longest Common Subsequence (LCS).</p>

                <div class="code-block">
                    <pre><code># Spotify-style playlist similarity using LCS variant
def playlist_similarity(playlist_a, playlist_b, genre_weights):
    """
    Modified LCS that considers genre similarity, not just exact matches.
    Used to find users with similar taste for collaborative filtering.

    Time: O(m*n), Space: O(min(m,n)) with optimization
    """
    m, n = len(playlist_a), len(playlist_b)
    # Space-optimized: only keep two rows
    prev = [0] * (n + 1)
    curr = [0] * (n + 1)

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            song_a = playlist_a[i-1]
            song_b = playlist_b[j-1]

            if song_a == song_b:
                # Exact match: full score
                curr[j] = prev[j-1] + 1.0
            else:
                # Partial match based on genre similarity
                genre_sim = get_genre_similarity(song_a, song_b, genre_weights)
                if genre_sim > 0.7:  # Similar genre
                    curr[j] = max(prev[j-1] + genre_sim * 0.5,
                                 prev[j], curr[j-1])
                else:
                    curr[j] = max(prev[j], curr[j-1])

        prev, curr = curr, [0] * (n + 1)

    return prev[n] / max(m, n)  # Normalize by length

# Netflix: Similar approach for "users who watched X also watched Y"
# At scale: approximate with MinHash/LSH, not exact DP</code></pre>
                </div>

                <h4>Knapsack for Content Budget Allocation</h4>
                <p>Netflix spends $17B/year on content. Deciding which shows to license is a knapsack problem: maximize viewer engagement within budget constraints.</p>

                <div class="code-block">
                    <pre><code># Simplified Netflix content acquisition optimization
def content_acquisition(shows, budget, regional_quotas):
    """
    0/1 Knapsack with multiple constraints:
    - Total budget
    - Regional content quotas (EU requires 30% European content)
    - Genre diversity requirements

    This is multi-dimensional knapsack - NP-hard, solved with DP + heuristics.
    """
    n = len(shows)
    # dp[budget_used][eu_content_hours] = max engagement
    dp = {}

    for show in shows:
        cost = show['license_cost']
        hours = show['runtime_hours']
        engagement = show['predicted_views'] * show['avg_watch_time']
        is_eu = show['region'] == 'EU'

        # Update DP table (simplified - real version has more dimensions)
        new_dp = {}
        for (b, eu), eng in dp.items():
            # Don't take this show
            if (b, eu) not in new_dp or new_dp[(b, eu)] < eng:
                new_dp[(b, eu)] = eng

            # Take this show (if within budget)
            new_b = b + cost
            new_eu = eu + (hours if is_eu else 0)
            if new_b <= budget:
                new_eng = eng + engagement
                if (new_b, new_eu) not in new_dp or new_dp[(new_b, new_eu)] < new_eng:
                    new_dp[(new_b, new_eu)] = new_eng

        dp = new_dp

    # Find best allocation meeting EU quota
    eu_quota = budget * 0.3  # 30% must be EU content
    best = max((eng for (b, eu), eng in dp.items() if eu >= eu_quota), default=0)
    return best</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Google Docs: Edit Distance for Operational Transform</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Google Docs supports 100M+ concurrent users editing documents. Edit distance algorithms power conflict resolution when multiple users edit simultaneously.</p>

                <h4>Operational Transformation</h4>
                <div class="code-block">
                    <pre><code># Google Docs-style diff detection using edit distance
def compute_edit_operations(old_text, new_text):
    """
    Compute minimum edit operations to transform old_text to new_text.
    Used for:
    1. Showing "Track Changes" in documents
    2. Syncing edits between users
    3. Version history compression

    Time: O(m*n), but optimized with diagonal banding for similar texts.
    """
    m, n = len(old_text), len(new_text)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    ops = [[None] * (n + 1) for _ in range(m + 1)]

    # Base cases
    for i in range(m + 1):
        dp[i][0] = i
        ops[i][0] = ('delete', i-1) if i > 0 else None
    for j in range(n + 1):
        dp[0][j] = j
        ops[0][j] = ('insert', j-1) if j > 0 else None

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if old_text[i-1] == new_text[j-1]:
                dp[i][j] = dp[i-1][j-1]
                ops[i][j] = ('match', i-1, j-1)
            else:
                choices = [
                    (dp[i-1][j] + 1, ('delete', i-1)),
                    (dp[i][j-1] + 1, ('insert', j-1)),
                    (dp[i-1][j-1] + 1, ('replace', i-1, j-1))
                ]
                dp[i][j], ops[i][j] = min(choices, key=lambda x: x[0])

    # Backtrack to get operations
    operations = []
    i, j = m, n
    while i > 0 or j > 0:
        op = ops[i][j]
        if op[0] == 'match':
            i, j = i-1, j-1
        elif op[0] == 'delete':
            operations.append(('DELETE', op[1], old_text[op[1]]))
            i -= 1
        elif op[0] == 'insert':
            operations.append(('INSERT', op[1], new_text[op[1]]))
            j -= 1
        else:  # replace
            operations.append(('REPLACE', op[1], old_text[op[1]], new_text[op[2]]))
            i, j = i-1, j-1

    return list(reversed(operations))

# At Google scale: use Myers diff algorithm O(ND) where D = edit distance
# Most edits are small, so D << m*n</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Amazon: Warehouse Robot Path Planning</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Amazon has 750,000+ robots in its fulfillment centers. Path planning for robots avoiding collisions is solved with DP-based algorithms.</p>

                <h4>Multi-Agent Path Finding</h4>
                <div class="code-block">
                    <pre><code># Simplified Amazon warehouse robot path planning
def robot_path_with_obstacles(grid, robots, goals):
    """
    Find collision-free paths for multiple robots.
    Each robot must reach its goal without colliding with others.

    This is a DP problem over (time, position_robot1, position_robot2, ...)
    State space explodes exponentially - Amazon uses hierarchical decomposition.
    """
    from functools import lru_cache
    rows, cols = len(grid), len(grid[0])

    @lru_cache(maxsize=None)
    def min_cost(time, positions):
        """
        DP: minimum cost to reach goals from current positions at given time.
        positions = tuple of (row, col) for each robot
        """
        # Base case: all robots at goals
        if all(pos == goal for pos, goal in zip(positions, goals)):
            return 0

        # Time limit to prevent infinite loops
        if time > rows * cols * 2:
            return float('inf')

        min_total = float('inf')

        # Try all combinations of moves (each robot: up/down/left/right/wait)
        for moves in generate_move_combinations(len(robots)):
            new_positions = []
            valid = True

            for i, (pos, move) in enumerate(zip(positions, moves)):
                new_pos = apply_move(pos, move)

                # Check bounds and obstacles
                if not is_valid(new_pos, grid):
                    valid = False
                    break

                # Check collision with other robots' new positions
                if new_pos in new_positions:
                    valid = False
                    break

                new_positions.append(new_pos)

            if valid:
                future_cost = min_cost(time + 1, tuple(new_positions))
                move_cost = sum(1 for m in moves if m != 'wait')
                min_total = min(min_total, move_cost + future_cost)

        return min_total

    return min_cost(0, tuple(r['start'] for r in robots))

# Real Amazon: Conflict-Based Search (CBS) with DP for individual paths
# Handles 1000s of robots with bounded-suboptimal solutions</code></pre>
                </div>
            </div>
        </div>

        <!-- Quiz Section -->
        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Interview Follow-up Questions -->
        <h2 class="mt-4">Interview Follow-up Questions</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Common Follow-ups & What Interviewers Look For</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. "How would you optimize the space complexity of this DP solution?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Identify which previous states are needed (often just previous row)</li>
                    <li>Rolling array technique: O(n*m) to O(min(n,m))</li>
                    <li>Trade-off: can't reconstruct solution path without full table</li>
                </ul>
                <p><strong>Red flags:</strong> Not recognizing when space optimization is possible.</p>

                <h4>2. "When would you use memoization vs tabulation?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Memoization (top-down): Only computes needed states, easier to write</li>
                    <li>Tabulation (bottom-up): No recursion overhead, easier to optimize space</li>
                    <li>Memoization better when not all states needed (sparse state space)</li>
                </ul>
                <p><strong>Red flags:</strong> Always defaulting to one approach without justification.</p>

                <h4>3. "How do you identify the recurrence relation?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Ask: "What decision do I make at each step?"</li>
                    <li>Define state clearly: dp[i] = "answer for subproblem using first i elements"</li>
                    <li>Express dp[i] in terms of smaller subproblems</li>
                </ul>
                <p><strong>Red flags:</strong> Jumping to code without defining state and recurrence.</p>

                <h4>4. "This DP is O(n^3). Can you make it faster?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Monotonic queue/stack optimization for certain patterns</li>
                    <li>Divide and conquer DP (Knuth optimization)</li>
                    <li>Convex hull trick for slope queries</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing that DP can sometimes be optimized beyond naive recurrence.</p>

                <h4>5. "How would you handle this if the input size is too large for DP?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Approximation algorithms (greedy with bounded error)</li>
                    <li>State space reduction (only consider "interesting" states)</li>
                    <li>Heuristics + pruning (branch and bound)</li>
                </ul>
                <p><strong>Red flags:</strong> Saying "DP won't work" without suggesting alternatives.</p>
            </div>
        </div>

        <!-- Practice Problems -->
        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Easy</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank">Climbing Stairs (LeetCode #70)</a></li>
                <li><a href="https://leetcode.com/problems/house-robber/" target="_blank">House Robber (LeetCode #198)</a></li>
            </ul>

            <h4 class="mt-3">Medium</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/coin-change/" target="_blank">Coin Change (LeetCode #322)</a></li>
                <li><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank">Longest Increasing Subsequence (LeetCode #300)</a></li>
                <li><a href="https://leetcode.com/problems/unique-paths/" target="_blank">Unique Paths (LeetCode #62)</a></li>
                <li><a href="https://leetcode.com/problems/word-break/" target="_blank">Word Break (LeetCode #139)</a></li>
            </ul>

            <h4 class="mt-3">Hard</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/edit-distance/" target="_blank">Edit Distance (LeetCode #72)</a></li>
                <li><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank">Longest Common Subsequence (LeetCode #1143)</a></li>
            </ul>
        </div>

        <!-- Navigation -->
        <div class="flex flex-between mt-4">
            <a href="module-04.html" class="btn btn-secondary">&larr; Module 4</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
        </main>
    </div>

    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Sidebar toggle for mobile
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            // Update sidebar links based on completion status
            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('coding', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "What are the two key properties of DP problems?",
                    options: [
                        "Sorted input and unique elements",
                        "Overlapping subproblems and optimal substructure",
                        "Linear time and constant space",
                        "Binary decisions and greedy choices"
                    ],
                    correct: 1,
                    explanation: "DP requires overlapping subproblems (same problems solved multiple times) and optimal substructure (optimal solution from optimal sub-solutions)."
                },
                {
                    question: "In the knapsack problem, why traverse backward in the space-optimized solution?",
                    options: [
                        "It's faster",
                        "To avoid using the same item twice",
                        "To maintain sorted order",
                        "Required by Python"
                    ],
                    correct: 1,
                    explanation: "Backward traversal ensures we use the previous row's values, preventing using an item multiple times."
                },
                {
                    question: "What's the recurrence relation for Coin Change?",
                    options: [
                        "dp[i] = dp[i-1] + dp[i-2]",
                        "dp[i] = min(dp[i-coin] + 1) for all coins",
                        "dp[i] = max(dp[i-1], dp[i-2] + nums[i])",
                        "dp[i][j] = dp[i-1][j-1] + 1"
                    ],
                    correct: 1,
                    explanation: "For each amount, try all coins and take the minimum."
                }
            ];

            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();
        });

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 5);
            alert('Module 5 marked as complete!');
            window.location.href = 'module-06.html';
        }
    </script>
</body>
</html>
