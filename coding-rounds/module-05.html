<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 5: Dynamic Programming - Staff Engineer Prep</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">StaffEngPrep</a>
            <ul class="nav-links">
                <li><a href="index.html" style="color: var(--primary-color);">Coding</a></li>
                <li><a href="../system-design/index.html">System Design</a></li>
                <li><a href="../company-specific/index.html">Companies</a></li>
                <li><a href="../behavioral/index.html">Behavioral</a></li>
                <li><a href="../generative-ai/index.html">Gen AI</a></li>
            </ul>
        </div>
    </nav>

    <div class="layout-with-sidebar">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar" id="sidebar">
            <nav class="sidebar-nav">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Getting Started</div>
                    <a href="index.html" class="sidebar-link">Introduction</a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Fundamentals</div>
                    <a href="module-01.html" class="sidebar-link" data-module="1">
                        <span class="sidebar-link-number">1</span>Foundations
                    </a>
                    <a href="module-02.html" class="sidebar-link" data-module="2">
                        <span class="sidebar-link-number">2</span>Arrays & Two Pointers
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Core Patterns</div>
                    <a href="module-03.html" class="sidebar-link" data-module="3">
                        <span class="sidebar-link-number">3</span>Trees & Binary Search
                    </a>
                    <a href="module-04.html" class="sidebar-link" data-module="4">
                        <span class="sidebar-link-number">4</span>Graphs
                    </a>
                    <a href="module-05.html" class="sidebar-link active" data-module="5">
                        <span class="sidebar-link-number">5</span>Dynamic Programming
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Advanced</div>
                    <a href="module-06.html" class="sidebar-link" data-module="6">
                        <span class="sidebar-link-number">6</span>Backtracking
                    </a>
                    <a href="module-07.html" class="sidebar-link" data-module="7">
                        <span class="sidebar-link-number">7</span>Heaps & Sorting
                    </a>
                    <a href="module-08.html" class="sidebar-link" data-module="8">
                        <span class="sidebar-link-number">8</span>Non-LeetCode Problems
                    </a>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-section-title">Interview Prep</div>
                    <a href="module-09.html" class="sidebar-link" data-module="9">
                        <span class="sidebar-link-number">9</span>Interview Simulation
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle" id="sidebarToggle">☰</button>
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Main Content -->
        <main class="main-content">
        <h1>Module 5: Dynamic Programming</h1>

        <div class="card mt-3">
            <h3>Learning Objectives</h3>
            <ul>
                <li>Identify when a problem can be solved with DP</li>
                <li>Design state representations for DP problems</li>
                <li>Implement both memoization and tabulation approaches</li>
                <li>Optimize space complexity in DP solutions</li>
            </ul>
        </div>

        <!-- DP Identification -->
        <h2 class="mt-4">Identifying DP Problems</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Key Properties</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>A problem can be solved with DP if it has:</p>

                <div class="diagram-container">
                    <div class="mermaid">
flowchart TD
    A[DP Problem] --> B[Overlapping Subproblems]
    A --> C[Optimal Substructure]
    B --> D["Same subproblems<br>solved multiple times"]
    C --> E["Optimal solution built from<br>optimal sub-solutions"]
                    </div>
                </div>

                <h4>Common DP Signals</h4>
                <ul>
                    <li>"Find the minimum/maximum..."</li>
                    <li>"Count the number of ways..."</li>
                    <li>"Is it possible to..."</li>
                    <li>"Find the longest/shortest..."</li>
                </ul>
            </div>
        </div>

        <!-- Interactive DP Visualization -->
        <h2 class="mt-4">Interactive: Watch DP in Action</h2>

        <div class="interactive-demo">
            <h4>Fibonacci / Climbing Stairs Visualization</h4>
            <p class="text-muted">Watch how the DP table fills up step by step. Each cell shows the number of ways to reach that step.</p>

            <div class="viz-controls">
                <button id="dp-play" class="active">▶ Play</button>
                <button id="dp-pause">⏸ Pause</button>
                <button id="dp-reset">↺ Reset</button>
                <button id="dp-step">Step →</button>
                <div class="speed-slider">
                    <label>Speed:</label>
                    <input type="range" id="dp-speed" min="100" max="1000" value="500">
                </div>
            </div>

            <div id="dp-array-viz" class="mt-2" style="min-height: 80px;"></div>

            <div class="step-indicator">
                <span>Step: <span class="current-step" id="dp-step-num">0</span> / <span id="dp-total-steps">10</span></span>
            </div>

            <div id="dp-explanation" class="callout callout-info mt-2">
                <p>Click <strong>Play</strong> to watch the DP array fill up, or <strong>Step</strong> to go one step at a time.</p>
            </div>
        </div>

        <div class="key-insight">
            <p><strong>The key to DP:</strong> Instead of recalculating fib(3) multiple times (exponential), we store it once and reuse it (linear). This transforms O(2<sup>n</sup>) into O(n).</p>
        </div>

        <!-- 1D DP -->
        <h2 class="mt-4">1D Dynamic Programming</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span>Climbing Stairs & House Robber</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python"># Climbing Stairs: Ways to reach step n (1 or 2 steps)
def climb_stairs(n):
    if n <= 2:
        return n

    # dp[i] = ways to reach step i
    prev2, prev1 = 1, 2  # Space optimized

    for i in range(3, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr

    return prev1

# House Robber: Max money without robbing adjacent houses
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]

    # dp[i] = max money robbing from houses 0..i
    prev2, prev1 = nums[0], max(nums[0], nums[1])

    for i in range(2, len(nums)):
        curr = max(prev1, prev2 + nums[i])
        prev2, prev1 = prev1, curr

    return prev1</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Coin Change</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def coin_change(coins, amount):
    """
    Minimum coins to make amount.
    dp[i] = minimum coins needed to make amount i
    """
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base case: 0 coins for amount 0

    for a in range(1, amount + 1):
        for coin in coins:
            if coin <= a and dp[a - coin] != float('inf'):
                dp[a] = min(dp[a], dp[a - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# Example: coins = [1, 2, 5], amount = 11
# dp = [0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3]
# Answer: 3 (5 + 5 + 1)</code></pre>
                </div>
            </div>
        </div>

        <!-- 2D DP -->
        <h2 class="mt-4">2D Dynamic Programming</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Longest Common Subsequence</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def longest_common_subsequence(text1, text2):
    """
    dp[i][j] = LCS length of text1[:i] and text2[:j]
    Time: O(m*n), Space: O(m*n) or O(min(m,n)) optimized
    """
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

# Example: "abcde", "ace" -> 3 ("ace")</code></pre>
                </div>
            </div>
        </div>

        <!-- Interactive 2D DP Visualization -->
        <div class="interactive-demo">
            <h4>Edit Distance Visualization</h4>
            <p class="text-muted">Watch how the 2D DP table fills to compute minimum edits to transform one word into another.</p>

            <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
                <div>
                    <label>Word 1: </label>
                    <input type="text" id="edit-word1" value="kitten" style="padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 0.25rem;">
                </div>
                <div>
                    <label>Word 2: </label>
                    <input type="text" id="edit-word2" value="sitting" style="padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 0.25rem;">
                </div>
                <button id="edit-start" class="btn btn-primary btn-sm">Visualize</button>
            </div>

            <div class="viz-controls">
                <button id="edit-play">▶ Play</button>
                <button id="edit-pause">⏸ Pause</button>
                <button id="edit-reset">↺ Reset</button>
                <button id="edit-step">Step →</button>
            </div>

            <div id="edit-grid-viz" class="mt-2" style="overflow-x: auto;"></div>

            <div id="edit-explanation" class="callout callout-info mt-2">
                <p>Enter two words and click <strong>Visualize</strong> to see how Edit Distance is computed.</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Edit Distance</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def edit_distance(word1, word2):
    """
    Minimum operations to convert word1 to word2.
    Operations: insert, delete, replace
    dp[i][j] = edit distance between word1[:i] and word2[:j]
    """
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Base cases
    for i in range(m + 1):
        dp[i][0] = i  # Delete all characters
    for j in range(n + 1):
        dp[0][j] = j  # Insert all characters

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]  # No operation needed
            else:
                dp[i][j] = 1 + min(
                    dp[i-1][j],    # Delete
                    dp[i][j-1],    # Insert
                    dp[i-1][j-1]   # Replace
                )

    return dp[m][n]</code></pre>
                </div>
            </div>
        </div>

        <!-- Knapsack Pattern -->
        <h2 class="mt-4">Knapsack Pattern</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>0/1 Knapsack</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre><code class="language-python">def knapsack(weights, values, capacity):
    """
    Max value with weight limit. Each item used at most once.
    dp[i][w] = max value using items 0..i with capacity w
    """
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # Don't take item i
            dp[i][w] = dp[i-1][w]

            # Take item i (if it fits)
            if weights[i-1] <= w:
                dp[i][w] = max(
                    dp[i][w],
                    dp[i-1][w - weights[i-1]] + values[i-1]
                )

    return dp[n][capacity]

# Space optimized (single array)
def knapsack_optimized(weights, values, capacity):
    dp = [0] * (capacity + 1)

    for i in range(len(weights)):
        # Traverse backward to avoid using same item twice
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])

    return dp[capacity]</code></pre>
                </div>
            </div>
        </div>

        <!-- Pattern Recognition -->
        <h2 class="mt-4">DP Pattern Recognition</h2>

        <div class="diagram-container">
            <div class="mermaid">
flowchart TD
    A[DP Problem] --> B{Linear sequence?}
    B -->|Yes| C{Decision at each step?}
    B -->|No| D{Two sequences?}

    C -->|Yes| E["1D DP<br>House Robber"]
    C -->|No| F["1D DP Linear<br>Climbing Stairs"]

    D -->|Yes| G["2D String DP<br>LCS, Edit Distance"]
    D -->|No| H{Subset/Partition?}

    H -->|Yes| I["Knapsack Pattern"]
    H -->|No| J{Grid?}

    J -->|Yes| K["2D Grid DP<br>Unique Paths"]
            </div>
        </div>

        <!-- Real-World Scale Examples -->
        <h2 class="mt-4">Real-World Scale Examples</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Netflix/Spotify: Recommendation Systems Using DP</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Netflix's recommendation engine generates $1B+ in annual value. Spotify's Discover Weekly reaches 100M+ listeners. Both use dynamic programming in their recommendation pipelines.</p>

                <h4>Sequence Alignment for Music Playlists</h4>
                <p>Finding similar listening patterns between users is essentially a variant of Longest Common Subsequence (LCS).</p>

                <div class="code-block">
                    <pre><code class="language-python"># Spotify-style playlist similarity using LCS variant
def playlist_similarity(playlist_a, playlist_b, genre_weights):
    """
    Modified LCS that considers genre similarity, not just exact matches.
    Used to find users with similar taste for collaborative filtering.

    Time: O(m*n), Space: O(min(m,n)) with optimization
    """
    m, n = len(playlist_a), len(playlist_b)
    # Space-optimized: only keep two rows
    prev = [0] * (n + 1)
    curr = [0] * (n + 1)

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            song_a = playlist_a[i-1]
            song_b = playlist_b[j-1]

            if song_a == song_b:
                # Exact match: full score
                curr[j] = prev[j-1] + 1.0
            else:
                # Partial match based on genre similarity
                genre_sim = get_genre_similarity(song_a, song_b, genre_weights)
                if genre_sim > 0.7:  # Similar genre
                    curr[j] = max(prev[j-1] + genre_sim * 0.5,
                                 prev[j], curr[j-1])
                else:
                    curr[j] = max(prev[j], curr[j-1])

        prev, curr = curr, [0] * (n + 1)

    return prev[n] / max(m, n)  # Normalize by length

# Netflix: Similar approach for "users who watched X also watched Y"
# At scale: approximate with MinHash/LSH, not exact DP</code></pre>
                </div>

                <h4>Knapsack for Content Budget Allocation</h4>
                <p>Netflix spends $17B/year on content. Deciding which shows to license is a knapsack problem: maximize viewer engagement within budget constraints.</p>

                <div class="code-block">
                    <pre><code class="language-python"># Simplified Netflix content acquisition optimization
def content_acquisition(shows, budget, regional_quotas):
    """
    0/1 Knapsack with multiple constraints:
    - Total budget
    - Regional content quotas (EU requires 30% European content)
    - Genre diversity requirements

    This is multi-dimensional knapsack - NP-hard, solved with DP + heuristics.
    """
    n = len(shows)
    # dp[budget_used][eu_content_hours] = max engagement
    dp = {}

    for show in shows:
        cost = show['license_cost']
        hours = show['runtime_hours']
        engagement = show['predicted_views'] * show['avg_watch_time']
        is_eu = show['region'] == 'EU'

        # Update DP table (simplified - real version has more dimensions)
        new_dp = {}
        for (b, eu), eng in dp.items():
            # Don't take this show
            if (b, eu) not in new_dp or new_dp[(b, eu)] < eng:
                new_dp[(b, eu)] = eng

            # Take this show (if within budget)
            new_b = b + cost
            new_eu = eu + (hours if is_eu else 0)
            if new_b <= budget:
                new_eng = eng + engagement
                if (new_b, new_eu) not in new_dp or new_dp[(new_b, new_eu)] < new_eng:
                    new_dp[(new_b, new_eu)] = new_eng

        dp = new_dp

    # Find best allocation meeting EU quota
    eu_quota = budget * 0.3  # 30% must be EU content
    best = max((eng for (b, eu), eng in dp.items() if eu >= eu_quota), default=0)
    return best</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Google Docs: Edit Distance for Operational Transform</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Google Docs supports 100M+ concurrent users editing documents. Edit distance algorithms power conflict resolution when multiple users edit simultaneously.</p>

                <h4>Operational Transformation</h4>
                <div class="code-block">
                    <pre><code class="language-python"># Google Docs-style diff detection using edit distance
def compute_edit_operations(old_text, new_text):
    """
    Compute minimum edit operations to transform old_text to new_text.
    Used for:
    1. Showing "Track Changes" in documents
    2. Syncing edits between users
    3. Version history compression

    Time: O(m*n), but optimized with diagonal banding for similar texts.
    """
    m, n = len(old_text), len(new_text)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    ops = [[None] * (n + 1) for _ in range(m + 1)]

    # Base cases
    for i in range(m + 1):
        dp[i][0] = i
        ops[i][0] = ('delete', i-1) if i > 0 else None
    for j in range(n + 1):
        dp[0][j] = j
        ops[0][j] = ('insert', j-1) if j > 0 else None

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if old_text[i-1] == new_text[j-1]:
                dp[i][j] = dp[i-1][j-1]
                ops[i][j] = ('match', i-1, j-1)
            else:
                choices = [
                    (dp[i-1][j] + 1, ('delete', i-1)),
                    (dp[i][j-1] + 1, ('insert', j-1)),
                    (dp[i-1][j-1] + 1, ('replace', i-1, j-1))
                ]
                dp[i][j], ops[i][j] = min(choices, key=lambda x: x[0])

    # Backtrack to get operations
    operations = []
    i, j = m, n
    while i > 0 or j > 0:
        op = ops[i][j]
        if op[0] == 'match':
            i, j = i-1, j-1
        elif op[0] == 'delete':
            operations.append(('DELETE', op[1], old_text[op[1]]))
            i -= 1
        elif op[0] == 'insert':
            operations.append(('INSERT', op[1], new_text[op[1]]))
            j -= 1
        else:  # replace
            operations.append(('REPLACE', op[1], old_text[op[1]], new_text[op[2]]))
            i, j = i-1, j-1

    return list(reversed(operations))

# At Google scale: use Myers diff algorithm O(ND) where D = edit distance
# Most edits are small, so D << m*n</code></pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Amazon: Warehouse Robot Path Planning</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <p>Amazon has 750,000+ robots in its fulfillment centers. Path planning for robots avoiding collisions is solved with DP-based algorithms.</p>

                <h4>Multi-Agent Path Finding</h4>
                <div class="code-block">
                    <pre><code class="language-python"># Simplified Amazon warehouse robot path planning
def robot_path_with_obstacles(grid, robots, goals):
    """
    Find collision-free paths for multiple robots.
    Each robot must reach its goal without colliding with others.

    This is a DP problem over (time, position_robot1, position_robot2, ...)
    State space explodes exponentially - Amazon uses hierarchical decomposition.
    """
    from functools import lru_cache
    rows, cols = len(grid), len(grid[0])

    @lru_cache(maxsize=None)
    def min_cost(time, positions):
        """
        DP: minimum cost to reach goals from current positions at given time.
        positions = tuple of (row, col) for each robot
        """
        # Base case: all robots at goals
        if all(pos == goal for pos, goal in zip(positions, goals)):
            return 0

        # Time limit to prevent infinite loops
        if time > rows * cols * 2:
            return float('inf')

        min_total = float('inf')

        # Try all combinations of moves (each robot: up/down/left/right/wait)
        for moves in generate_move_combinations(len(robots)):
            new_positions = []
            valid = True

            for i, (pos, move) in enumerate(zip(positions, moves)):
                new_pos = apply_move(pos, move)

                # Check bounds and obstacles
                if not is_valid(new_pos, grid):
                    valid = False
                    break

                # Check collision with other robots' new positions
                if new_pos in new_positions:
                    valid = False
                    break

                new_positions.append(new_pos)

            if valid:
                future_cost = min_cost(time + 1, tuple(new_positions))
                move_cost = sum(1 for m in moves if m != 'wait')
                min_total = min(min_total, move_cost + future_cost)

        return min_total

    return min_cost(0, tuple(r['start'] for r in robots))

# Real Amazon: Conflict-Based Search (CBS) with DP for individual paths
# Handles 1000s of robots with bounded-suboptimal solutions</code></pre>
                </div>
            </div>
        </div>

        <!-- Flashcards for Spaced Repetition -->
        <h2 class="mt-4">Flashcards: Key Concepts</h2>
        <p class="text-muted">Click cards to flip. Review these concepts regularly for retention.</p>
        <div id="dp-flashcards" class="mt-2"></div>

        <!-- Quiz Section -->
        <h2 class="mt-4">Self-Check Quiz</h2>
        <div class="quiz-container" id="module-quiz"></div>

        <!-- Interview Follow-up Questions -->
        <h2 class="mt-4">Interview Follow-up Questions</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span>Common Follow-ups & What Interviewers Look For</span>
                <span class="collapsible-icon">&#9660;</span>
            </div>
            <div class="collapsible-content">
                <h4>1. "How would you optimize the space complexity of this DP solution?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Identify which previous states are needed (often just previous row)</li>
                    <li>Rolling array technique: O(n*m) to O(min(n,m))</li>
                    <li>Trade-off: can't reconstruct solution path without full table</li>
                </ul>
                <p><strong>Red flags:</strong> Not recognizing when space optimization is possible.</p>

                <h4>2. "When would you use memoization vs tabulation?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Memoization (top-down): Only computes needed states, easier to write</li>
                    <li>Tabulation (bottom-up): No recursion overhead, easier to optimize space</li>
                    <li>Memoization better when not all states needed (sparse state space)</li>
                </ul>
                <p><strong>Red flags:</strong> Always defaulting to one approach without justification.</p>

                <h4>3. "How do you identify the recurrence relation?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Ask: "What decision do I make at each step?"</li>
                    <li>Define state clearly: dp[i] = "answer for subproblem using first i elements"</li>
                    <li>Express dp[i] in terms of smaller subproblems</li>
                </ul>
                <p><strong>Red flags:</strong> Jumping to code without defining state and recurrence.</p>

                <h4>4. "This DP is O(n^3). Can you make it faster?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Monotonic queue/stack optimization for certain patterns</li>
                    <li>Divide and conquer DP (Knuth optimization)</li>
                    <li>Convex hull trick for slope queries</li>
                </ul>
                <p><strong>Red flags:</strong> Not knowing that DP can sometimes be optimized beyond naive recurrence.</p>

                <h4>5. "How would you handle this if the input size is too large for DP?"</h4>
                <p><strong>What they're looking for:</strong></p>
                <ul>
                    <li>Approximation algorithms (greedy with bounded error)</li>
                    <li>State space reduction (only consider "interesting" states)</li>
                    <li>Heuristics + pruning (branch and bound)</li>
                </ul>
                <p><strong>Red flags:</strong> Saying "DP won't work" without suggesting alternatives.</p>
            </div>
        </div>

        <!-- Practice Problems -->
        <h2 class="mt-4">Practice Problems</h2>
        <div class="card">
            <h4>Easy</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank">Climbing Stairs (LeetCode #70)</a></li>
                <li><a href="https://leetcode.com/problems/house-robber/" target="_blank">House Robber (LeetCode #198)</a></li>
            </ul>

            <h4 class="mt-3">Medium</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/coin-change/" target="_blank">Coin Change (LeetCode #322)</a></li>
                <li><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank">Longest Increasing Subsequence (LeetCode #300)</a></li>
                <li><a href="https://leetcode.com/problems/unique-paths/" target="_blank">Unique Paths (LeetCode #62)</a></li>
                <li><a href="https://leetcode.com/problems/word-break/" target="_blank">Word Break (LeetCode #139)</a></li>
            </ul>

            <h4 class="mt-3">Hard</h4>
            <ul>
                <li><a href="https://leetcode.com/problems/edit-distance/" target="_blank">Edit Distance (LeetCode #72)</a></li>
                <li><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank">Longest Common Subsequence (LeetCode #1143)</a></li>
            </ul>
        </div>

        <!-- Navigation -->
        <div class="flex flex-between mt-4">
            <a href="module-04.html" class="btn btn-secondary">&larr; Module 4</a>
            <button class="btn btn-primary" onclick="completeModule()">Mark Complete &rarr;</button>
        </div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="../assets/js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Sidebar toggle for mobile
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');

            sidebarToggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                sidebarOverlay.classList.toggle('open');
            });

            sidebarOverlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            });

            // Update sidebar links based on completion status
            document.querySelectorAll('.sidebar-link[data-module]').forEach(link => {
                const moduleNum = parseInt(link.dataset.module);
                if (StaffEngPrep.ProgressTracker.isModuleComplete('coding', moduleNum)) {
                    link.classList.add('completed');
                }
            });

            const quizQuestions = [
                {
                    question: "What are the two key properties of DP problems?",
                    options: [
                        "Sorted input and unique elements",
                        "Overlapping subproblems and optimal substructure",
                        "Linear time and constant space",
                        "Binary decisions and greedy choices"
                    ],
                    correct: 1,
                    explanation: "DP requires overlapping subproblems (same problems solved multiple times) and optimal substructure (optimal solution from optimal sub-solutions)."
                },
                {
                    question: "In the knapsack problem, why traverse backward in the space-optimized solution?",
                    options: [
                        "It's faster",
                        "To avoid using the same item twice",
                        "To maintain sorted order",
                        "Required by Python"
                    ],
                    correct: 1,
                    explanation: "Backward traversal ensures we use the previous row's values, preventing using an item multiple times."
                },
                {
                    question: "What's the recurrence relation for Coin Change?",
                    options: [
                        "dp[i] = dp[i-1] + dp[i-2]",
                        "dp[i] = min(dp[i-coin] + 1) for all coins",
                        "dp[i] = max(dp[i-1], dp[i-2] + nums[i])",
                        "dp[i][j] = dp[i-1][j-1] + 1"
                    ],
                    correct: 1,
                    explanation: "For each amount, try all coins and take the minimum."
                }
            ];

            const quiz = new StaffEngPrep.Quiz('module-quiz', quizQuestions);
            quiz.render();

            // Flashcards
            const flashcards = new StaffEngPrep.Flashcards('dp-flashcards', [
                {
                    question: "What are the two key properties required for a DP solution?",
                    answer: "1. Overlapping Subproblems\n2. Optimal Substructure",
                    explanation: "Without overlapping subproblems, memoization provides no benefit. Without optimal substructure, we can't build optimal solutions from sub-solutions."
                },
                {
                    question: "What's the difference between memoization and tabulation?",
                    answer: "Memoization: Top-down, recursive, lazy computation.\nTabulation: Bottom-up, iterative, computes all states.",
                    explanation: "Memoization is often easier to write; tabulation avoids recursion overhead and is easier to space-optimize."
                },
                {
                    question: "How do you identify the recurrence relation for a DP problem?",
                    answer: "1. Define what dp[i] represents\n2. Ask: what decision do I make at step i?\n3. Express dp[i] in terms of smaller subproblems",
                    explanation: "The recurrence is the heart of any DP solution. Always define your state clearly first."
                },
                {
                    question: "In 0/1 Knapsack, why traverse backward when space-optimizing?",
                    answer: "To avoid using the same item twice. Forward traversal would use already-updated values from the current row.",
                    explanation: "This is a critical detail - getting it wrong gives unbounded knapsack instead of 0/1!"
                },
                {
                    question: "What's the time/space complexity of Edit Distance?",
                    answer: "Time: O(m × n)\nSpace: O(m × n), optimizable to O(min(m, n))",
                    explanation: "We fill an m×n table. Space can be optimized since we only need the previous row."
                }
            ]);
            flashcards.render();

            // Interactive DP Visualizations
            initDPVisualization();
            initEditDistanceVisualization();
        });

        function initDPVisualization() {
            const n = 10;
            let dp = new Array(n + 1).fill(null);
            let currentStep = 0;
            let isPlaying = false;
            let playInterval = null;
            let speed = 500;

            const vizContainer = document.getElementById('dp-array-viz');
            const stepNum = document.getElementById('dp-step-num');
            const totalSteps = document.getElementById('dp-total-steps');
            const explanation = document.getElementById('dp-explanation');
            const playBtn = document.getElementById('dp-play');
            const pauseBtn = document.getElementById('dp-pause');
            const resetBtn = document.getElementById('dp-reset');
            const stepBtn = document.getElementById('dp-step');
            const speedSlider = document.getElementById('dp-speed');

            totalSteps.textContent = n;

            function render() {
                let html = '<div class="array-viz">';
                for (let i = 0; i <= n; i++) {
                    let classes = 'array-cell';
                    if (i === currentStep && currentStep > 0) {
                        classes += ' current';
                    } else if (dp[i] !== null && i < currentStep) {
                        classes += ' sorted';
                    }
                    html += `
                        <div class="${classes}">
                            <span class="cell-value">${dp[i] !== null ? dp[i] : '?'}</span>
                            <span class="cell-index">n=${i}</span>
                        </div>
                    `;
                }
                html += '</div>';
                vizContainer.innerHTML = html;
                stepNum.textContent = currentStep;
            }

            function step() {
                if (currentStep > n) {
                    pause();
                    explanation.innerHTML = '<p><strong>Complete!</strong> We\'ve computed all values. Notice how each cell only depends on the two previous cells. This is why we can optimize space to O(1).</p>';
                    return;
                }

                if (currentStep === 0) {
                    dp[0] = 1;
                    explanation.innerHTML = '<p><strong>Base case:</strong> dp[0] = 1 (one way to stay at ground)</p>';
                } else if (currentStep === 1) {
                    dp[1] = 1;
                    explanation.innerHTML = '<p><strong>Base case:</strong> dp[1] = 1 (one way to reach step 1: take 1 step)</p>';
                } else {
                    dp[currentStep] = dp[currentStep - 1] + dp[currentStep - 2];
                    explanation.innerHTML = `<p><strong>dp[${currentStep}]</strong> = dp[${currentStep - 1}] + dp[${currentStep - 2}] = ${dp[currentStep - 1]} + ${dp[currentStep - 2]} = <strong>${dp[currentStep]}</strong></p>
                    <p class="text-muted">We can reach step ${currentStep} either from step ${currentStep - 1} (${dp[currentStep - 1]} ways) or step ${currentStep - 2} (${dp[currentStep - 2]} ways).</p>`;
                }

                currentStep++;
                render();
            }

            function play() {
                if (isPlaying) return;
                isPlaying = true;
                playBtn.classList.add('active');
                pauseBtn.classList.remove('active');
                playInterval = setInterval(() => {
                    if (currentStep > n) {
                        pause();
                        return;
                    }
                    step();
                }, speed);
            }

            function pause() {
                isPlaying = false;
                pauseBtn.classList.add('active');
                playBtn.classList.remove('active');
                if (playInterval) {
                    clearInterval(playInterval);
                    playInterval = null;
                }
            }

            function reset() {
                pause();
                dp = new Array(n + 1).fill(null);
                currentStep = 0;
                explanation.innerHTML = '<p>Click <strong>Play</strong> to watch the DP array fill up, or <strong>Step</strong> to go one step at a time.</p>';
                render();
            }

            playBtn.addEventListener('click', play);
            pauseBtn.addEventListener('click', pause);
            resetBtn.addEventListener('click', reset);
            stepBtn.addEventListener('click', () => {
                pause();
                step();
            });
            speedSlider.addEventListener('input', (e) => {
                speed = 1100 - parseInt(e.target.value);
                if (isPlaying) {
                    pause();
                    play();
                }
            });

            // Initial render
            render();
        }

        function initEditDistanceVisualization() {
            let word1 = 'kitten';
            let word2 = 'sitting';
            let dp = [];
            let currentI = 0;
            let currentJ = 0;
            let isPlaying = false;
            let playInterval = null;

            const gridViz = document.getElementById('edit-grid-viz');
            const explanation = document.getElementById('edit-explanation');
            const word1Input = document.getElementById('edit-word1');
            const word2Input = document.getElementById('edit-word2');
            const startBtn = document.getElementById('edit-start');
            const playBtn = document.getElementById('edit-play');
            const pauseBtn = document.getElementById('edit-pause');
            const resetBtn = document.getElementById('edit-reset');
            const stepBtn = document.getElementById('edit-step');

            function initGrid() {
                word1 = word1Input.value || 'cat';
                word2 = word2Input.value || 'cut';
                const m = word1.length;
                const n = word2.length;

                dp = [];
                for (let i = 0; i <= m; i++) {
                    dp[i] = new Array(n + 1).fill(null);
                }

                currentI = 0;
                currentJ = 0;
                render();
            }

            function render() {
                const m = word1.length;
                const n = word2.length;

                let html = '<table class="comparison-table" style="font-size: 0.85rem;">';

                // Header row
                html += '<thead><tr><th></th><th></th>';
                for (let j = 0; j < n; j++) {
                    html += `<th>${word2[j]}</th>`;
                }
                html += '</tr></thead><tbody>';

                // Data rows
                for (let i = 0; i <= m; i++) {
                    html += '<tr>';
                    html += `<td style="font-weight: 600;">${i === 0 ? '' : word1[i - 1]}</td>`;

                    for (let j = 0; j <= n; j++) {
                        let cellClass = '';
                        if (i === currentI && j === currentJ && dp[i][j] !== null) {
                            cellClass = 'style="background: rgba(37, 99, 235, 0.3); font-weight: bold;"';
                        } else if (dp[i][j] !== null) {
                            cellClass = 'style="background: rgba(16, 185, 129, 0.1);"';
                        }
                        html += `<td ${cellClass}>${dp[i][j] !== null ? dp[i][j] : '-'}</td>`;
                    }
                    html += '</tr>';
                }

                html += '</tbody></table>';
                gridViz.innerHTML = html;
            }

            function step() {
                const m = word1.length;
                const n = word2.length;

                if (currentI > m) {
                    pause();
                    explanation.innerHTML = `<p><strong>Complete!</strong> Edit distance = <strong>${dp[m][n]}</strong>. This means it takes ${dp[m][n]} operations to transform "${word1}" into "${word2}".</p>`;
                    return false;
                }

                // Fill current cell
                if (currentI === 0) {
                    dp[0][currentJ] = currentJ;
                    explanation.innerHTML = `<p><strong>Base case:</strong> dp[0][${currentJ}] = ${currentJ} (insert ${currentJ} characters)</p>`;
                } else if (currentJ === 0) {
                    dp[currentI][0] = currentI;
                    explanation.innerHTML = `<p><strong>Base case:</strong> dp[${currentI}][0] = ${currentI} (delete ${currentI} characters)</p>`;
                } else {
                    const char1 = word1[currentI - 1];
                    const char2 = word2[currentJ - 1];

                    if (char1 === char2) {
                        dp[currentI][currentJ] = dp[currentI - 1][currentJ - 1];
                        explanation.innerHTML = `<p><strong>Match:</strong> '${char1}' = '${char2}', so dp[${currentI}][${currentJ}] = dp[${currentI - 1}][${currentJ - 1}] = ${dp[currentI][currentJ]}</p>`;
                    } else {
                        const del = dp[currentI - 1][currentJ];
                        const ins = dp[currentI][currentJ - 1];
                        const rep = dp[currentI - 1][currentJ - 1];
                        dp[currentI][currentJ] = 1 + Math.min(del, ins, rep);

                        let op = 'replace';
                        if (del <= ins && del <= rep) op = 'delete';
                        else if (ins <= del && ins <= rep) op = 'insert';

                        explanation.innerHTML = `<p><strong>Mismatch:</strong> '${char1}' ≠ '${char2}'</p>
                        <p>dp[${currentI}][${currentJ}] = 1 + min(delete=${del}, insert=${ins}, replace=${rep}) = <strong>${dp[currentI][currentJ]}</strong> (${op})</p>`;
                    }
                }

                render();

                // Move to next cell
                currentJ++;
                if (currentJ > n) {
                    currentJ = 0;
                    currentI++;
                }

                return true;
            }

            function play() {
                if (isPlaying) return;
                isPlaying = true;
                playInterval = setInterval(() => {
                    if (!step()) {
                        pause();
                    }
                }, 300);
            }

            function pause() {
                isPlaying = false;
                if (playInterval) {
                    clearInterval(playInterval);
                    playInterval = null;
                }
            }

            function reset() {
                pause();
                initGrid();
                explanation.innerHTML = '<p>Click <strong>Play</strong> to animate, or <strong>Step</strong> to go one cell at a time.</p>';
            }

            startBtn.addEventListener('click', () => {
                reset();
            });

            playBtn.addEventListener('click', play);
            pauseBtn.addEventListener('click', pause);
            resetBtn.addEventListener('click', reset);
            stepBtn.addEventListener('click', () => {
                pause();
                step();
            });

            // Initialize
            initGrid();
        }

        function completeModule() {
            StaffEngPrep.ProgressTracker.markModuleComplete('coding', 5);
            alert('Module 5 marked as complete!');
            window.location.href = 'module-06.html';
        }
    </script>
</body>
</html>
